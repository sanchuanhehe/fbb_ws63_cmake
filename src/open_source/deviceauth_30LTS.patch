File deviceauth/.git is a directory while file deviceauth_new/.git is a regular file
diff -Naru deviceauth/bundle.json deviceauth_new/bundle.json
--- deviceauth/bundle.json	2025-02-12 16:28:17.649093500 +0800
+++ deviceauth_new/bundle.json	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
-{
-    "name": "@ohos/security_deviceauth",
-    "version": "",
-    "description": "设备认证",
-    "homePage": "https://gitee.com/openharmony",
-    "license": "Apache V2",
-    "repository": "https://gitee.com/openharmony/security_deviceauth",
-    "domain": "os",
-    "language": "",
-    "publishAs": "code-segment",
-    "private": false,
-    "scripts": {},
-    "tags": [
-        "base"
-    ],
-    "keywords": [
-        "security",
-        "deviceauth"
-    ],
-    "envs": [],
-    "dirs": [],
-    "author": {
-        "name": "",
-        "email": "",
-        "url": ""
-    },
-    "contributors": [
-        {
-            "name": "",
-            "email": "",
-            "url": ""
-        }
-    ],
-    "segment": {
-        "destPath": "base/security/deviceauth"
-    },
-    "component": {
-        "name": "device_auth",
-        "subsystem": "security",
-        "syscap": [
-            "SystemCapability.Security.DeviceAuth"
-        ],
-        "features": [],
-        "adapted_system_type": [
-            "small",
-            "standard"
-        ],
-        "rom": "",
-        "ram": "",
-        "deps": {
-            "components": [],
-            "third_party": []
-        },
-        "build": {
-            "sub_component": [],
-            "inner_kits": [],
-            "test": []
-        }
-    }
-}
\ No newline at end of file
diff -Naru deviceauth/CMakeLists.txt deviceauth_new/CMakeLists.txt
--- deviceauth/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ deviceauth_new/CMakeLists.txt	2025-02-12 15:01:27.762543400 +0800
@@ -0,0 +1,111 @@
+#===============================================================================
+# @brief    cmake file
+# Copyright (c) HiSilicon (Shanghai) Technologies Co., Ltd. 2023-2023. All rights reserved.
+#===============================================================================
+set(COMPONENT_NAME "deviceauth")
+
+set(CMAKE_DEVICEAUTH_SOURCE_DIR
+    ${CMAKE_CURRENT_SOURCE_DIR})
+
+set(SOURCES
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/hichain.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/auth_info/add_auth_info.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/auth_info/add_auth_info_client.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/auth_info/auth_info.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info_client.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/auth_info/remove_auth_info_client.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/hichain.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/huks_adapter/huks_adapter.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/json/commonutil.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/json/jsonutil.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/key_agreement.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/key_agreement_client.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/key_agreement_server.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/pake_client.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/pake_server.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/sec_clone_server.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/sts_client.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/sts_server.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/log/log.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/schedule/build_object.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/schedule/distribution.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/add_auth_info_data.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/add_auth_info_request.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/add_auth_info_response.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/auth_ack_request.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/auth_ack_response.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/auth_start_request.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/auth_start_response.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/exchange_auth_data.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/exchange_request.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/exchange_response.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/import_add_auth_data.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/inform_message.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/key_agreement_version.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/key_agreement_version.h
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/pake_client_confirm.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/pake_request.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/pake_response.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/pake_server_confirm.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/parsedata.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/rmv_auth_info_data.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/rmv_auth_info_request.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/rmv_auth_info_response.c
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/sec_clone_data.c
+)
+
+set(PUBLIC_HEADER
+    # hichain.h
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/interfaces/innerkits/deviceauth_lite/
+)
+
+set(PRIVATE_HEADER
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/base/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/huks_adapter/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/json/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/key_agreement/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/log/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/schedule/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/struct/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/frameworks/deviceauth_lite/source/auth_info/
+    ${CMAKE_DEVICEAUTH_SOURCE_DIR}/interfaces/innerkits/deviceauth_lite/
+)
+
+# use this when you want to add ccflags like -include xxx
+set(COMPONENT_PUBLIC_CCFLAGS
+)
+
+set(COMPONENT_CCFLAGS
+    -Wno-error=logical-op
+    -Wno-error=sign-compare
+    -Wno-error=jump-misses-init
+    -Wno-sign-compare
+    -Wno-jump-misses-init
+    -Wno-error=unused-parameter
+    -Wno-unused-parameter
+    -Wno-unused-but-set-variable
+    -Wno-error=unused-variable
+)
+
+set(PRIVATE_DEFINES
+    _SCANTY_MEMORY_
+    _CUT_STS_CLIENT_
+    _CUT_REMOVE_
+    _CUT_ADD_
+    _CUT_LOG_
+)
+
+set(PUBLIC_DEFINES
+)
+set(WHOLE_LINK
+    true
+)
+
+set(MAIN_COMPONENT
+    false
+)
+
+set(LIB_OUT_PATH ${BIN_DIR}/${CHIP}/libs/wifi/${TARGET_COMMAND})
+
+build_component()
\ No newline at end of file
diff -Naru deviceauth/frameworks/deviceauth_lite/BUILD.gn deviceauth_new/frameworks/deviceauth_lite/BUILD.gn
--- deviceauth/frameworks/deviceauth_lite/BUILD.gn	2025-02-12 16:28:17.787974700 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/BUILD.gn	2025-02-12 15:01:27.766543400 +0800
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2020-2021 Huawei Device Co., Ltd.
+# Copyright (c) 2020-2022 Huawei Device Co., Ltd.
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
@@ -13,16 +13,19 @@
 # limitations under the License.
 #
 
-import("//build/lite/config/component/lite_component.gni")
+import("//build/ohos.gni")
 
-lite_component("hichainsdk") {
-  features = [
-    "//base/security/deviceauth/frameworks/deviceauth_lite/source:hichainsdk",
-  ]
+group("hichainsdk") {
+  deps = []
+  if (os_level == "mini" || os_level == "small") {
+    deps += [ "//base/security/device_auth/frameworks/deviceauth_lite/source:hichainsdk" ]
+  }
 }
 
-if (ohos_build_type == "debug" && ohos_kernel_type == "liteos_a") {
-  group("unittest") {
-    deps = ["//base/security/deviceauth/frameworks/deviceauth_lite/unittest:deviceauth_test"]
+group("deviceauth_lite_test_build") {
+  testonly = true
+  deps = []
+  if (os_level == "small") {
+    deps += [ "//base/security/device_auth/frameworks/deviceauth_lite/unittest:deviceauth_test" ]
   }
 }
diff -Naru deviceauth/frameworks/deviceauth_lite/source/auth_info/add_auth_info.c deviceauth_new/frameworks/deviceauth_lite/source/auth_info/add_auth_info.c
--- deviceauth/frameworks/deviceauth_lite/source/auth_info/add_auth_info.c	2025-02-12 16:28:17.813270900 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/auth_info/add_auth_info.c	2025-02-12 15:01:27.770543400 +0800
@@ -15,7 +15,7 @@
 
 #include "add_auth_info.h"
 #include <string.h>
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "base.h"
 #include "mem_stat.h"
@@ -192,7 +192,7 @@
     uint32_t len = (data->length / BYTE_TO_HEX_OPER_LENGTH) + 1;
     uint8_t *receive_data = (uint8_t *)MALLOC(len);
     if (receive_data == NULL) {
-        LOGE("malloc inport signed auth info receive data failed");
+        LOGE("malloc import signed auth info receive data failed");
         return HC_MALLOC_FAILED;
     }
     (void)memset_s(receive_data, len, 0, len);
diff -Naru deviceauth/frameworks/deviceauth_lite/source/auth_info/add_auth_info_client.c deviceauth_new/frameworks/deviceauth_lite/source/auth_info/add_auth_info_client.c
--- deviceauth/frameworks/deviceauth_lite/source/auth_info/add_auth_info_client.c	2025-02-12 16:28:17.867335200 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/auth_info/add_auth_info_client.c	2025-02-12 15:01:27.770543400 +0800
@@ -14,7 +14,7 @@
  */
 
 #include "add_auth_info_client.h"
-#include <securec.h>
+#include "securec.h"
 #include "huks_adapter.h"
 #include "log.h"
 #include "mem_stat.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/auth_info/auth_info.c deviceauth_new/frameworks/deviceauth_lite/source/auth_info/auth_info.c
--- deviceauth/frameworks/deviceauth_lite/source/auth_info/auth_info.c	2025-02-12 16:28:17.916935100 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/auth_info/auth_info.c	2025-02-12 15:01:27.770543400 +0800
@@ -14,7 +14,7 @@
  */
 
 #include "auth_info.h"
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "huks_adapter.h"
@@ -78,7 +78,7 @@
     struct aes_aad aes_aad;
     (void)memset_s(&aes_aad, sizeof(aes_aad), 0, sizeof(aes_aad));
     if (strcpy_s((char *)aes_aad.aad, sizeof(aes_aad.aad), aad) != EOK) {
-        LOGE("What happened was that the probability was zero"); /* caller perceives memery error, no return */
+        LOGE("What happened was that the probability was zero"); /* caller perceives memory error, no return */
     }
     aes_aad.length = strlen(aad);
     int32_t ret = aes_gcm_encrypt((struct var_buffer *)key, plain, &aes_aad, payload);
@@ -104,7 +104,7 @@
     struct aes_aad aes_aad;
     (void)memset_s(&aes_aad, sizeof(aes_aad), 0, sizeof(aes_aad));
     if (strcpy_s((char *)aes_aad.aad, sizeof(aes_aad.aad), aad) != EOK) {
-        LOGE("What happened was that the probability was zero"); /* caller perceives memery error, no return */
+        LOGE("What happened was that the probability was zero"); /* caller perceives memory error, no return */
     }
     aes_aad.length = strlen(aad);
     int32_t ret = aes_gcm_decrypt((struct var_buffer *)key, payload, &aes_aad, plain);
diff -Naru deviceauth/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info.c deviceauth_new/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info.c
--- deviceauth/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info.c	2025-02-12 16:28:17.973975700 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info.c	2025-02-12 15:01:27.770543400 +0800
@@ -16,7 +16,7 @@
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_) || defined(_CUT_EXCHANGE_) || defined(_CUT_EXCHANGE_SERVER_))
 
 #include "exchange_auth_info.h"
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "base.h"
 #include "mem_stat.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info_client.c deviceauth_new/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info_client.c
--- deviceauth/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info_client.c	2025-02-12 16:28:18.058790200 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/auth_info/exchange_auth_info_client.c	2025-02-12 15:01:27.770543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_CLIENT_) || defined(_CUT_EXCHANGE_) || defined(_CUT_EXCHANGE_CLIENT_))
 #include "exchange_auth_info_client.h"
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "base.h"
 #include "mem_stat.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/auth_info/remove_auth_info_client.c deviceauth_new/frameworks/deviceauth_lite/source/auth_info/remove_auth_info_client.c
--- deviceauth/frameworks/deviceauth_lite/source/auth_info/remove_auth_info_client.c	2025-02-12 16:28:18.239832000 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/auth_info/remove_auth_info_client.c	2025-02-12 15:01:27.770543400 +0800
@@ -16,7 +16,7 @@
 #include "remove_auth_info_client.h"
 #include <string.h>
 #include <stdlib.h>
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "base.h"
 #include "mem_stat.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/BUILD.gn deviceauth_new/frameworks/deviceauth_lite/source/BUILD.gn
--- deviceauth/frameworks/deviceauth_lite/source/BUILD.gn	2025-02-12 16:28:18.439720600 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/BUILD.gn	2025-02-12 15:01:27.770543400 +0800
@@ -63,7 +63,7 @@
 config("hichain_config") {
   include_dirs = [
     "//third_party/bounds_checking_function/include",
-    "//base/security/deviceauth/interfaces/innerkits/deviceauth_lite",
+    "//base/security/device_auth/interfaces/innerkits/deviceauth_lite",
     "//third_party/cJSON",
     "base",
     "huks_adapter",
@@ -88,9 +88,14 @@
   static_library("hichainsdk") {
     sources = hichian_sources
     public_configs = [ ":hichain_config" ]
-    deps = [
-      "//base/security/huks/interfaces/innerkits/huks_lite:huks_3.0_sdk"
-    ]
+    deps =
+        [ "//base/security/huks/interfaces/innerkits/huks_lite:huks_3.0_sdk" ]
+    if (board_toolchain_type == "iccarm") {
+      cflags = [
+        "--diag_suppress",
+        "Pe1097,Pe546,Pe188,Pe111",
+      ]
+    }
   }
 } else {
   shared_library("hichainsdk") {
diff -Naru deviceauth/frameworks/deviceauth_lite/source/hichain.c deviceauth_new/frameworks/deviceauth_lite/source/hichain.c
--- deviceauth/frameworks/deviceauth_lite/source/hichain.c	2025-02-12 16:28:18.478903400 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/hichain.c	2025-02-12 15:01:27.770543400 +0800
@@ -13,7 +13,7 @@
  * limitations under the License.
  */
 
-#include <securec.h>
+#include "securec.h"
 #include "commonutil.h"
 #include "distribution.h"
 #include "log.h"
@@ -242,7 +242,7 @@
         LOGE("Generate derived dek failed");
         return ret;
     }
-    if (memcpy_s(dek, sizeof(struct hc_key_alias), &dek_alias, sizeof(struct hc_key_alias)) != HC_OK) {
+    if (memcpy_s(dek, sizeof(struct hc_key_alias), &dek_alias, sizeof(struct hc_key_alias)) != EOK) {
         return HC_INNER_ERROR;
     }
 
@@ -1175,7 +1175,7 @@
     (void)memset_s(auth_id_list, length, 0, length);
 
     uint32_t peers_num = list_trust_peers(handle, user_type, NULL, &auth_id_list);
-    LOGI("peers_num %d", peers_num);
+    LOGI("peers_num %u", peers_num);
     for (uint32_t loop = 0; loop < peers_num; loop++) {
         struct hc_key_alias key_alias = generate_key_alias(&service_id, &auth_id_list[loop], user_type);
         if (key_alias.length == 0) {
diff -Naru deviceauth/frameworks/deviceauth_lite/source/huks_adapter/huks_adapter.c deviceauth_new/frameworks/deviceauth_lite/source/huks_adapter/huks_adapter.c
--- deviceauth/frameworks/deviceauth_lite/source/huks_adapter/huks_adapter.c	2025-02-12 16:28:18.532472900 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/huks_adapter/huks_adapter.c	2025-02-12 15:01:27.798543400 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd.
+ * Copyright (c) 2020-2022 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
diff -Naru deviceauth/frameworks/deviceauth_lite/source/json/commonutil.c deviceauth_new/frameworks/deviceauth_lite/source/json/commonutil.c
--- deviceauth/frameworks/deviceauth_lite/source/json/commonutil.c	2025-02-12 16:28:18.617288400 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/json/commonutil.c	2025-02-12 15:01:27.798543400 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020 Huawei Device Co., Ltd.
+ * Copyright (c) 2020-2022 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -14,7 +14,7 @@
  */
 
 #include "commonutil.h"
-#include <securec.h>
+#include "securec.h"
 #include "base.h"
 #include "log.h"
 #include "mem_stat.h"
@@ -22,7 +22,8 @@
 
 char hex_to_char(uint8_t hex)
 {
-    return (hex > 9) ? hex + 0x37 : hex + 0x30; /* Convert to the corresponding character */
+    /* Convert to the corresponding character, hex + 0x37 -> A-F, hex + 0x30 -> 0-9 */
+    return (hex > 9) ? hex + 0x37 : hex + 0x30;
 }
 
 void byte_to_hex_string(const uint8_t *hex, int32_t hex_len, uint8_t *buf, int32_t buf_len)
@@ -117,22 +118,6 @@
     return HC_OK;
 }
 
-void hex_string_convert(uint32_t length, const uint8_t *hex, const char *field, json_pobject parent)
-{
-    int32_t org_cha_len = length;
-    int32_t tmp_cha_data_hex_len = org_cha_len * BYTE_TO_HEX_OPER_LENGTH + 1;
-    uint8_t *tmp_cha_data_hex = (uint8_t *)MALLOC(tmp_cha_data_hex_len);
-
-    if (tmp_cha_data_hex == NULL) {
-        return;
-    }
-    (void)memset_s(tmp_cha_data_hex, tmp_cha_data_hex_len, 0, tmp_cha_data_hex_len);
-    byte_to_hex_string(hex, org_cha_len, tmp_cha_data_hex, org_cha_len * BYTE_TO_HEX_OPER_LENGTH);
-    add_string_to_object(parent, field, (char *)tmp_cha_data_hex);
-    FREE(tmp_cha_data_hex);
-    tmp_cha_data_hex = NULL;
-}
-
 int32_t memory_copy_error(const char *fun, unsigned int line)
 {
     (void)fun;
diff -Naru deviceauth/frameworks/deviceauth_lite/source/json/commonutil.h deviceauth_new/frameworks/deviceauth_lite/source/json/commonutil.h
--- deviceauth/frameworks/deviceauth_lite/source/json/commonutil.h	2025-02-12 16:28:18.646056500 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/json/commonutil.h	2025-02-12 15:01:27.798543400 +0800
@@ -28,7 +28,6 @@
 
 int32_t byte_convert(json_pobject obj, const char *field, uint8_t *hex, uint32_t *length, uint32_t max_len);
 int32_t string_convert(json_pobject obj, const char *field, uint8_t *str, uint32_t *length, uint32_t max_len);
-void hex_string_convert(uint32_t length, const uint8_t *hex, const char *field, json_pobject parent);
 
 int32_t memory_copy_error(const char *fun, unsigned int line);
 
diff -Naru deviceauth/frameworks/deviceauth_lite/source/json/jsonutil.c deviceauth_new/frameworks/deviceauth_lite/source/json/jsonutil.c
--- deviceauth/frameworks/deviceauth_lite/source/json/jsonutil.c	2025-02-12 16:28:18.674825100 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/json/jsonutil.c	2025-02-12 15:01:27.798543400 +0800
@@ -27,10 +27,10 @@
     return (void *)root;
 }
 
-void free_json(json_handle hanlde)
+void free_json(json_handle handle)
 {
-    if (hanlde != NULL) {
-        cJSON_Delete((cJSON *)hanlde);
+    if (handle != NULL) {
+        cJSON_Delete((cJSON *)handle);
     }
 }
 
diff -Naru deviceauth/frameworks/deviceauth_lite/source/json/jsonutil.h deviceauth_new/frameworks/deviceauth_lite/source/json/jsonutil.h
--- deviceauth/frameworks/deviceauth_lite/source/json/jsonutil.h	2025-02-12 16:28:18.711529800 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/json/jsonutil.h	2025-02-12 15:01:27.798543400 +0800
@@ -22,7 +22,7 @@
 typedef void *json_pobject;
 
 json_handle parse_json(const char *data);
-void free_json(json_handle hanlde);
+void free_json(json_handle handle);
 
 json_pobject get_json_obj(json_pobject parent, const char *field);
 int32_t get_json_int(json_pobject obj, const char *field);
diff -Naru deviceauth/frameworks/deviceauth_lite/source/key_agreement/key_agreement_server.c deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/key_agreement_server.c
--- deviceauth/frameworks/deviceauth_lite/source/key_agreement/key_agreement_server.c	2025-02-12 16:28:18.859833600 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/key_agreement_server.c	2025-02-12 15:01:27.798543400 +0800
@@ -62,7 +62,7 @@
     }
     set_state(base, START_RESPONSE);
     set_last_time_sec(base);
-    DBG_OUT("Object %u receive start request data send start response data succcess", base->sn);
+    DBG_OUT("Object %u receive start request data send start response data success", base->sn);
     return HC_OK;
 }
 
@@ -94,7 +94,7 @@
     }
     set_state(base, PROTOCOL_FINISH);
     set_last_time_sec(base);
-    DBG_OUT("Object %u receive end request data send end response data succcess", base->sn);
+    DBG_OUT("Object %u receive end request data send end response data success", base->sn);
     return HC_OK;
 }
 #endif /* DESC */
diff -Naru deviceauth/frameworks/deviceauth_lite/source/key_agreement/pake_client.c deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/pake_client.c
--- deviceauth/frameworks/deviceauth_lite/source/key_agreement/pake_client.c	2025-02-12 16:28:18.951593900 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/pake_client.c	2025-02-12 15:01:27.798543400 +0800
@@ -20,7 +20,7 @@
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_CLIENT_))
 
 #include <string.h>
-#include <securec.h>
+#include "securec.h"
 #include "huks_adapter.h"
 #include "commonutil.h"
 
diff -Naru deviceauth/frameworks/deviceauth_lite/source/key_agreement/pake_server.c deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/pake_server.c
--- deviceauth/frameworks/deviceauth_lite/source/key_agreement/pake_server.c	2025-02-12 16:28:19.042857000 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/pake_server.c	2025-02-12 15:01:27.798543400 +0800
@@ -18,7 +18,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "huks_adapter.h"
 #include "mem_stat.h"
 
diff -Naru deviceauth/frameworks/deviceauth_lite/source/key_agreement/sec_clone_server.c deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/sec_clone_server.c
--- deviceauth/frameworks/deviceauth_lite/source/key_agreement/sec_clone_server.c	2025-02-12 16:28:19.119241000 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/sec_clone_server.c	2025-02-12 15:01:27.798543400 +0800
@@ -18,7 +18,7 @@
 #include "sec_clone_server.h"
 #include <stdlib.h>
 #include <string.h>
-#include <securec.h>
+#include "securec.h"
 #include "huks_adapter.h"
 #include "log.h"
 #include "commonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/key_agreement/sts_client.c deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/sts_client.c
--- deviceauth/frameworks/deviceauth_lite/source/key_agreement/sts_client.c	2025-02-12 16:28:19.216953500 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/sts_client.c	2025-02-12 15:01:27.798543400 +0800
@@ -17,7 +17,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_CLIENT_))
 #include <string.h>
-#include <securec.h>
+#include "securec.h"
 #include "huks_adapter.h"
 #include "log.h"
 #include "commonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/key_agreement/sts_server.c deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/sts_server.c
--- deviceauth/frameworks/deviceauth_lite/source/key_agreement/sts_server.c	2025-02-12 16:28:19.292841900 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/key_agreement/sts_server.c	2025-02-12 15:01:27.798543400 +0800
@@ -18,7 +18,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "commonutil.h"
 #include "distribution.h"
 #include "mem_stat.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/log/log.c deviceauth_new/frameworks/deviceauth_lite/source/log/log.c
--- deviceauth/frameworks/deviceauth_lite/source/log/log.c	2025-02-12 16:28:19.361786100 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/log/log.c	2025-02-12 15:01:27.802543400 +0800
@@ -16,7 +16,7 @@
 #ifndef _HC_DEBUG_
 
 #include "log.h"
-#include <securec.h>
+#include "securec.h"
 #include "base.h"
 
 #if defined(_WINDOWS)
diff -Naru deviceauth/frameworks/deviceauth_lite/source/schedule/build_object.c deviceauth_new/frameworks/deviceauth_lite/source/schedule/build_object.c
--- deviceauth/frameworks/deviceauth_lite/source/schedule/build_object.c	2025-02-12 16:28:19.428249800 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/schedule/build_object.c	2025-02-12 15:01:27.802543400 +0800
@@ -14,7 +14,7 @@
  */
 
 #include "build_object.h"
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "auth_info.h"
 
diff -Naru deviceauth/frameworks/deviceauth_lite/source/schedule/distribution.c deviceauth_new/frameworks/deviceauth_lite/source/schedule/distribution.c
--- deviceauth/frameworks/deviceauth_lite/source/schedule/distribution.c	2025-02-12 16:28:19.503642100 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/schedule/distribution.c	2025-02-12 15:01:27.802543400 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020 Huawei Device Co., Ltd.
+ * Copyright (c) 2020-2022 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -14,7 +14,7 @@
  */
 
 #include "distribution.h"
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "pake_client.h"
 #include "pake_server.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/add_auth_info_data.c deviceauth_new/frameworks/deviceauth_lite/source/struct/add_auth_info_data.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/add_auth_info_data.c	2025-02-12 16:28:19.577051500 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/add_auth_info_data.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_) || defined(_CUT_ADD_) || defined(_CUT_ADD_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/add_auth_info_request.c deviceauth_new/frameworks/deviceauth_lite/source/struct/add_auth_info_request.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/add_auth_info_request.c	2025-02-12 16:28:19.613756000 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/add_auth_info_request.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_) || defined(_CUT_ADD_) || defined(_CUT_ADD_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/add_auth_info_response.c deviceauth_new/frameworks/deviceauth_lite/source/struct/add_auth_info_response.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/add_auth_info_response.c	2025-02-12 16:28:19.643515700 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/add_auth_info_response.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_) || defined(_CUT_ADD_) || defined(_CUT_ADD_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
@@ -56,8 +56,9 @@
     }
     (void)memset_s(add_auth_info_response->cipher.val, add_auth_info_response->cipher.size,
                    0, add_auth_info_response->cipher.size);
-    if (hex_string_to_byte(add_return, len_add_return, add_auth_info_response->cipher.val) != HC_OK)
+    if (hex_string_to_byte(add_return, len_add_return, add_auth_info_response->cipher.val) != HC_OK) {
         goto error;
+    }
     free_payload(obj, data_type);
     return (void *)add_auth_info_response;
 error:
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/auth_ack_request.c deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_ack_request.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/auth_ack_request.c	2025-02-12 16:28:19.674762500 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_ack_request.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/auth_ack_response.c deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_ack_response.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/auth_ack_response.c	2025-02-12 16:28:19.709484500 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_ack_response.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/auth_start_request.c deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_start_request.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/auth_start_request.c	2025-02-12 16:28:19.743211100 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_start_request.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
@@ -90,8 +90,8 @@
     }
 }
 
-static char *make_requst_json_str(struct sts_start_request_data *auth_start_request,
-                                  struct sts_start_request_data_hex tmp_hex)
+static char *make_request_json_str(struct sts_start_request_data *auth_start_request,
+                                   struct sts_start_request_data_hex tmp_hex)
 {
     char *tmp_str = (char *)MALLOC(RET_STR_LENGTH);
     if (tmp_str == NULL) {
@@ -156,7 +156,7 @@
         FREE(tmp_hex.tmp_cha_data_hex);
         return NULL;
     }
-    char *ret_str = make_requst_json_str(auth_start_request, tmp_hex);
+    char *ret_str = make_request_json_str(auth_start_request, tmp_hex);
     FREE(tmp_hex.tmp_epk_data_hex);
     FREE(tmp_hex.tmp_cha_data_hex);
     FREE(tmp_hex.tmp_type_data_hex);
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/auth_start_response.c deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_start_response.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/auth_start_response.c	2025-02-12 16:28:19.778426900 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/auth_start_response.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/exchange_auth_data.c deviceauth_new/frameworks/deviceauth_lite/source/struct/exchange_auth_data.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/exchange_auth_data.c	2025-02-12 16:28:19.822074800 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/exchange_auth_data.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_) || defined(_CUT_EXCHANGE_) || defined(_CUT_EXCHANGE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/exchange_request.c deviceauth_new/frameworks/deviceauth_lite/source/struct/exchange_request.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/exchange_request.c	2025-02-12 16:28:19.876139800 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/exchange_request.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_) || defined(_CUT_EXCHANGE_) || defined(_CUT_EXCHANGE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/exchange_response.c deviceauth_new/frameworks/deviceauth_lite/source/struct/exchange_response.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/exchange_response.c	2025-02-12 16:28:19.918795800 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/exchange_response.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_) || defined(_CUT_EXCHANGE_) || defined(_CUT_EXCHANGE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/import_add_auth_data.c deviceauth_new/frameworks/deviceauth_lite/source/struct/import_add_auth_data.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/import_add_auth_data.c	2025-02-12 16:28:19.951035200 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/import_add_auth_data.c	2025-02-12 15:01:27.802543400 +0800
@@ -13,7 +13,7 @@
  * limitations under the License.
  */
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/inform_message.c deviceauth_new/frameworks/deviceauth_lite/source/struct/inform_message.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/inform_message.c	2025-02-12 16:28:19.988235400 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/inform_message.c	2025-02-12 15:01:27.802543400 +0800
@@ -13,7 +13,7 @@
  * limitations under the License.
  */
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/key_agreement_version.c deviceauth_new/frameworks/deviceauth_lite/source/struct/key_agreement_version.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/key_agreement_version.c	2025-02-12 16:28:20.021963700 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/key_agreement_version.c	2025-02-12 15:01:27.802543400 +0800
@@ -14,7 +14,7 @@
  */
 
 #include "key_agreement_version.h"
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/pake_client_confirm.c deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_client_confirm.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/pake_client_confirm.c	2025-02-12 16:28:20.081980200 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_client_confirm.c	2025-02-12 15:01:27.802543400 +0800
@@ -16,7 +16,7 @@
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_))
 
 #include <log.h>
-#include <securec.h>
+#include "securec.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
 #include "commonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/pake_request.c deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_request.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/pake_request.c	2025-02-12 16:28:20.111739600 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_request.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/pake_response.c deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_response.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/pake_response.c	2025-02-12 16:28:20.148940200 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_response.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/pake_server_confirm.c deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_server_confirm.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/pake_server_confirm.c	2025-02-12 16:28:20.182172000 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/pake_server_confirm.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_PAKE_) || defined(_CUT_PAKE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/parsedata.c deviceauth_new/frameworks/deviceauth_lite/source/struct/parsedata.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/parsedata.c	2025-02-12 16:28:20.215900800 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/parsedata.c	2025-02-12 15:01:27.802543400 +0800
@@ -14,7 +14,7 @@
  */
 
 #include "parsedata.h"
-#include <securec.h>
+#include "securec.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
 #include "log.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/rmv_auth_info_data.c deviceauth_new/frameworks/deviceauth_lite/source/struct/rmv_auth_info_data.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/rmv_auth_info_data.c	2025-02-12 16:28:20.305180700 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/rmv_auth_info_data.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_) || defined(_CUT_REMOVE_) || defined(_CUT_REMOVE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/rmv_auth_info_request.c deviceauth_new/frameworks/deviceauth_lite/source/struct/rmv_auth_info_request.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/rmv_auth_info_request.c	2025-02-12 16:28:20.340893300 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/rmv_auth_info_request.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_) || defined(_CUT_REMOVE_) || defined(_CUT_REMOVE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
@@ -56,8 +56,9 @@
     }
     (void)memset_s(rmv_auth_info_request->cipher.val, rmv_auth_info_request->cipher.size,
                    0, rmv_auth_info_request->cipher.size);
-    if (hex_string_to_byte(add_return, len_rmv_return, rmv_auth_info_request->cipher.val) != HC_OK)
+    if (hex_string_to_byte(add_return, len_rmv_return, rmv_auth_info_request->cipher.val) != HC_OK) {
         goto error;
+    }
     free_payload(obj, data_type);
     return (void *)rmv_auth_info_request;
 error:
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/rmv_auth_info_response.c deviceauth_new/frameworks/deviceauth_lite/source/struct/rmv_auth_info_response.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/rmv_auth_info_response.c	2025-02-12 16:28:20.376111300 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/rmv_auth_info_response.c	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #if !(defined(_CUT_STS_) || defined(_CUT_STS_SERVER_) || defined(_CUT_REMOVE_) || defined(_CUT_REMOVE_SERVER_))
 
-#include <securec.h>
+#include "securec.h"
 #include "log.h"
 #include "mem_stat.h"
 #include "jsonutil.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/source/struct/sec_clone_data.c deviceauth_new/frameworks/deviceauth_lite/source/struct/sec_clone_data.c
--- deviceauth/frameworks/deviceauth_lite/source/struct/sec_clone_data.c	2025-02-12 16:28:20.422237600 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/source/struct/sec_clone_data.c	2025-02-12 15:01:27.802543400 +0800
@@ -16,7 +16,7 @@
 #if (defined(_SUPPORT_SEC_CLONE_) || defined(_SUPPORT_SEC_CLONE_SERVER_))
 
 #include <string.h>
-#include <securec.h>
+#include "securec.h"
 #include "jsonutil.h"
 #include "commonutil.h"
 #include "exchange_auth_info.h"
diff -Naru deviceauth/frameworks/deviceauth_lite/unittest/BUILD.gn deviceauth_new/frameworks/deviceauth_lite/unittest/BUILD.gn
--- deviceauth/frameworks/deviceauth_lite/unittest/BUILD.gn	2025-02-12 16:28:20.457948600 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/unittest/BUILD.gn	2025-02-12 15:01:27.802543400 +0800
@@ -18,14 +18,11 @@
 unittest("deviceauth_test") {
   output_extension = "bin"
   output_dir = "$root_out_dir/test/unittest/security"
-  sources = [
-    "deviceauth_test.cpp"
-  ]
-  include_dirs = [
-    "//base/security/deviceauth/interfaces/innerkits/deviceauth_lite"
-  ]
+  sources = [ "deviceauth_test.cpp" ]
+  include_dirs =
+      [ "//base/security/device_auth/interfaces/innerkits/deviceauth_lite" ]
   deps = [
-    "//base/security/deviceauth/frameworks/deviceauth_lite/source:hichainsdk",
-    "//base/security/huks/interfaces/innerkits/huks_lite:huks_3.0_sdk"
+    "//base/security/device_auth/frameworks/deviceauth_lite/source:hichainsdk",
+    "//base/security/huks/interfaces/innerkits/huks_lite:huks_3.0_sdk",
   ]
 }
diff -Naru deviceauth/frameworks/deviceauth_lite/unittest/deviceauth_test.cpp deviceauth_new/frameworks/deviceauth_lite/unittest/deviceauth_test.cpp
--- deviceauth/frameworks/deviceauth_lite/unittest/deviceauth_test.cpp	2025-02-12 16:28:20.484238300 +0800
+++ deviceauth_new/frameworks/deviceauth_lite/unittest/deviceauth_test.cpp	2025-02-12 15:01:27.802543400 +0800
@@ -15,7 +15,7 @@
 
 #include "deviceauth_test.h"
 #include <gtest/gtest.h>
-#include <securec.h>
+#include "securec.h"
 #include "hichain.h"
 
 #define LOG(format, ...) (printf(format"\n", ##__VA_ARGS__))
@@ -53,8 +53,7 @@
 {
     LOG("--------Transmit--------");
     LOG("identity session_id[%d] package_name[%s]", identity->session_id, identity->package_name.name);
-    LOG("data[%s]", (char *)data);
-    LOG("length[%d]", length);
+    LOG("length[%u]", length);
     LOG("--------Transmit--------");
 }
 
diff -Naru deviceauth/frameworks/inc/ipc_sdk.h deviceauth_new/frameworks/inc/ipc_sdk.h
--- deviceauth/frameworks/inc/ipc_sdk.h	2025-02-12 16:28:20.564590000 +0800
+++ deviceauth_new/frameworks/inc/ipc_sdk.h	2025-02-12 15:01:27.802543400 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Copyright (C) 2021-2022 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -22,9 +22,6 @@
 extern "C" {
 #endif
 
-#define IPC_RESULT_NUM_1 1
-#define IPC_RESULT_NUM_2 2
-
 #define IPC_CALL_BACK_STUB_AUTH_ID 0
 #define IPC_CALL_BACK_STUB_BIND_ID 1
 
@@ -43,7 +40,6 @@
 #define PARAM_TYPE_BIND 12
 #define PARAM_TYPE_UNBIND 13
 #define PARAM_TYPE_GROUP_TYPE 14
-#define PARAM_TYPE_CREDENTIAL 15
 #define PARAM_TYPE_MGR_APPID 16
 #define PARAM_TYPE_FRIEND_APPID 17
 #define PARAM_TYPE_QUERY_PARAMS 18
@@ -60,6 +56,9 @@
 #define PARAM_TYPE_DEVICE_INFO 29
 #define PARAM_TYPE_AUTH_PARAMS 30
 #define PARAM_TYPE_CB_OBJECT 31
+#define PARAM_TYPE_OS_ACCOUNT_ID 32
+#define PARAM_TYPE_RETURN_DATA 33
+#define PARAM_TYPE_REQ_JSON 34
 
 enum {
     IPC_CALL_ID_REG_CB = 1,
@@ -71,18 +70,9 @@
     IPC_CALL_ID_ADD_GROUP_MEMBER,
     IPC_CALL_ID_DEL_GROUP_MEMBER,
     IPC_CALL_ID_GM_PROC_DATA,
-    IPC_CALL_ID_CFM_REQUEST,
-    IPC_CALL_ID_BIND_PEER,
-    IPC_CALL_ID_UNBIND_PEER,
-    IPC_CALL_ID_PROC_LIGHT_DATA,
-    IPC_CALL_ID_SAVE_CREDENTIAL,
     IPC_CALL_ID_APPLY_REG_INFO,
-    IPC_CALL_ID_ADD_GROUP_MGR,
-    IPC_CALL_ID_ADD_GROUP_FRIEND,
-    IPC_CALL_ID_DEL_GROUP_MGR,
-    IPC_CALL_ID_DEL_GROUP_FRIEND,
-    IPC_CALL_ID_GET_GROUP_MGR,
-    IPC_CALL_ID_GET_GROUP_FRIEND,
+    IPC_CALL_ID_CHECK_ACCESS_TO_GROUP,
+    IPC_CALL_ID_GET_PK_INFO_LIST,
     IPC_CALL_ID_GET_GROUP_INFO,
     IPC_CALL_ID_SEARCH_GROUPS,
     IPC_CALL_ID_GET_JOINED_GROUPS,
@@ -92,11 +82,9 @@
     IPC_CALL_ID_IS_DEV_IN_GROUP,
     IPC_CALL_ID_DESTROY_INFO,
     IPC_CALL_ID_GA_PROC_DATA,
-    IPC_CALL_ID_QUERY_TRUST_DEV_NUM,
-    IPC_CALL_ID_IS_TRUST_DEVICE,
-    IPC_CALL_ID_GET_AUTH_STATE,
     IPC_CALL_ID_AUTH_DEVICE,
-    IPC_CALL_ID_INFORM_DEV_DISCONN
+    IPC_CALL_ID_ADD_MULTI_GROUP_MEMBERS,
+    IPC_CALL_ID_DEL_MULTI_GROUP_MEMBERS,
 };
 
 #ifdef __cplusplus
diff -Naru deviceauth/frameworks/inc/lite/ipc_adapt.h deviceauth_new/frameworks/inc/lite/ipc_adapt.h
--- deviceauth/frameworks/inc/lite/ipc_adapt.h	2025-02-12 16:28:20.627087000 +0800
+++ deviceauth_new/frameworks/inc/lite/ipc_adapt.h	2025-02-12 15:01:27.806543400 +0800
@@ -1,111 +1,111 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef IPC_ADAPT_H
-#define IPC_ADAPT_H
-
-#include <stdbool.h>
-#include <stdint.h>
-
-#include "device_auth.h"
-#include "serializer.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define MAX_REQUEST_PARAMS_NUM 8
-#define CB_TYPE_DEV_AUTH 1
-#define CB_TYPE_TMP_DEV_AUTH 2
-#define CB_TYPE_LISTENER 3
-
-#ifndef IPC_DATA_BUFF_MAX_SZ
-#define IPC_DATA_BUFF_MAX_SZ 2048
-#endif
-#define IPC_STACK_BUFF_SZ 512
-
-typedef struct {
-    int32_t type;
-    int32_t valSz;
-    uint8_t *val;
-    int32_t idx;
-} IpcDataInfo;
-
-enum {
-    CB_ID_ON_TRANS = 1,
-    CB_ID_SESS_KEY_DONE,
-    CB_ID_ON_FINISH,
-    CB_ID_ON_ERROR,
-    CB_ID_ON_REQUEST,
-    CB_ID_ON_GROUP_CREATED,
-    CB_ID_ON_GROUP_DELETED,
-    CB_ID_ON_DEV_BOUND,
-    CB_ID_ON_DEV_UNBOUND,
-    CB_ID_ON_DEV_UNTRUSTED,
-    CB_ID_ON_LAST_GROUP_DELETED,
-    CB_ID_ON_TRUST_DEV_NUM_CHANGED,
-};
-
-typedef int32_t (*IpcServiceCall)(const IpcDataInfo *, int32_t, uintptr_t);
-
-int32_t IpcEncodeCallReplay(uintptr_t replayCache, int32_t type, const uint8_t *result, int32_t resultSz);
-uint32_t SetIpcCallMap(uintptr_t ipcInstance, IpcServiceCall method, int32_t methodId);
-
-void SetCbCtxToDataCtx(uintptr_t callCtx, int32_t cbIdx);
-int32_t CreateCallCtx(uintptr_t *callCtx, uintptr_t *cbCtx);
-void DestroyCallCtx(uintptr_t *callCtx, uintptr_t *cbCtx);
-int32_t DoBinderCall(uintptr_t callCtx, int32_t methodId, bool withSync);
-int32_t SetCallRequestParamInfo(uintptr_t callCtx, int32_t type, const uint8_t *param, int32_t paramSz);
-
-int32_t CreateServiceInstance(uintptr_t *ipcInstance);
-void DestroyServiceInstance(uintptr_t *ipcInstance);
-
-int32_t AddDevAuthServiceToManager(uintptr_t *serviceCtx);
-void DecodeCallReply(uintptr_t callCtx, IpcDataInfo *replyCache, int32_t cacheNum);
-
-int32_t InitIpcCallBackList(void);
-void DeInitIpcCallBackList(void);
-void InitDeviceAuthCbCtx(DeviceAuthCallback *ctx, int32_t type);
-void InitDevAuthListenerCbCtx(DataChangeListener *ctx);
-int32_t AddIpcCallBackByAppId(const char *appId, const uint8_t *cbPtr, int32_t cbSz, int32_t type);
-void DelIpcCallBackByAppId(const char *appId, int32_t type);
-int32_t AddIpcCallBackByReqId(int64_t reqId, const uint8_t *cbPtr, int32_t cbSz, int32_t type);
-void DelIpcCallBackByReqId(int64_t reqId, int32_t type, bool withLock);
-
-int32_t DecodeIpcData(uintptr_t data, int32_t *type, uint8_t **val, int32_t *valSz);
-void ProcCbHook(int32_t callbackId, uintptr_t cbHook,
-    const IpcDataInfo *cbDataCache, int32_t cacheNum, uintptr_t replyCtx);
-
-int32_t GetIpcRequestParamByType(const IpcDataInfo *ipcParams, int32_t paramNum,
-    int32_t type, uint8_t *paramCache, int32_t *cacheLen);
-int32_t AddReqIdByAppId(const char *appId, int64_t reqId);
-void AddIpcCbObjByAppId(const char *appId, int32_t objIdx, int32_t type);
-void AddIpcCbObjByReqId(int64_t reqId, int32_t objIdx, int32_t type);
-
-bool IsCallbackMethod(int32_t methodId);
-bool IsServiceRunning(void);
-void ResetIpcCallBackNodeByNodeId(int32_t nodeIdx);
-IpcIo *InitIpcDataCache(uint32_t buffSz);
-int32_t GetIpcIoDataLength(const IpcIo *io);
-int32_t InitProxyAdapt(void);
-void UnInitProxyAdapt(void);
-void ServiceInit(void);
-void ShowIpcSvcInfo(const SvcIdentity *svc);
-int32_t IpcIoBufferOffset(void);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_ADAPT_H
+#define IPC_ADAPT_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "device_auth.h"
+#include "serializer.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MAX_REQUEST_PARAMS_NUM 8
+#define CB_TYPE_DEV_AUTH 1
+#define CB_TYPE_TMP_DEV_AUTH 2
+#define CB_TYPE_LISTENER 3
+
+#ifndef IPC_DATA_BUFF_MAX_SZ
+#define IPC_DATA_BUFF_MAX_SZ 2048
+#endif
+#define IPC_STACK_BUFF_SZ 512
+
+typedef struct {
+    int32_t type;
+    int32_t valSz;
+    uint8_t *val;
+    int32_t idx;
+} IpcDataInfo;
+
+enum {
+    CB_ID_ON_TRANS = 1,
+    CB_ID_SESS_KEY_DONE,
+    CB_ID_ON_FINISH,
+    CB_ID_ON_ERROR,
+    CB_ID_ON_REQUEST,
+    CB_ID_ON_GROUP_CREATED,
+    CB_ID_ON_GROUP_DELETED,
+    CB_ID_ON_DEV_BOUND,
+    CB_ID_ON_DEV_UNBOUND,
+    CB_ID_ON_DEV_UNTRUSTED,
+    CB_ID_ON_LAST_GROUP_DELETED,
+    CB_ID_ON_TRUST_DEV_NUM_CHANGED,
+};
+
+typedef int32_t (*IpcServiceCall)(const IpcDataInfo *, int32_t, uintptr_t);
+
+int32_t IpcEncodeCallReplay(uintptr_t replayCache, int32_t type, const uint8_t *result, int32_t resultSz);
+uint32_t SetIpcCallMap(uintptr_t ipcInstance, IpcServiceCall method, int32_t methodId);
+
+void SetCbCtxToDataCtx(uintptr_t callCtx, int32_t cbIdx);
+int32_t CreateCallCtx(uintptr_t *callCtx, uintptr_t *cbCtx);
+void DestroyCallCtx(uintptr_t *callCtx, uintptr_t *cbCtx);
+int32_t DoBinderCall(uintptr_t callCtx, int32_t methodId, bool withSync);
+int32_t SetCallRequestParamInfo(uintptr_t callCtx, int32_t type, const uint8_t *param, int32_t paramSz);
+
+int32_t CreateServiceInstance(uintptr_t *ipcInstance);
+void DestroyServiceInstance(uintptr_t *ipcInstance);
+
+int32_t AddDevAuthServiceToManager(uintptr_t *serviceCtx);
+void DecodeCallReply(uintptr_t callCtx, IpcDataInfo *replyCache, int32_t cacheNum);
+
+int32_t InitIpcCallBackList(void);
+void DeInitIpcCallBackList(void);
+void InitDeviceAuthCbCtx(DeviceAuthCallback *ctx, int32_t type);
+void InitDevAuthListenerCbCtx(DataChangeListener *ctx);
+int32_t AddIpcCallBackByAppId(const char *appId, const uint8_t *cbPtr, int32_t cbSz, int32_t type);
+void DelIpcCallBackByAppId(const char *appId, int32_t type);
+int32_t AddIpcCallBackByReqId(int64_t reqId, const uint8_t *cbPtr, int32_t cbSz, int32_t type);
+void DelIpcCallBackByReqId(int64_t reqId, int32_t type, bool withLock);
+
+int32_t DecodeIpcData(uintptr_t data, int32_t *type, uint8_t **val, int32_t *valSz);
+void ProcCbHook(int32_t callbackId, uintptr_t cbHook,
+    const IpcDataInfo *cbDataCache, int32_t cacheNum, uintptr_t replyCtx);
+
+int32_t GetIpcRequestParamByType(const IpcDataInfo *ipcParams, int32_t paramNum,
+    int32_t type, uint8_t *paramCache, int32_t *cacheLen);
+int32_t AddReqIdByAppId(const char *appId, int64_t reqId);
+void AddIpcCbObjByAppId(const char *appId, int32_t objIdx, int32_t type);
+void AddIpcCbObjByReqId(int64_t reqId, int32_t objIdx, int32_t type);
+
+bool IsCallbackMethod(int32_t methodId);
+bool IsServiceRunning(void);
+void ResetIpcCallBackNodeByNodeId(int32_t nodeIdx);
+IpcIo *InitIpcDataCache(uint32_t buffSz);
+int32_t GetIpcIoDataLength(const IpcIo *io);
+int32_t InitProxyAdapt(void);
+void UnInitProxyAdapt(void);
+void ServiceInit(void);
+void ShowIpcSvcInfo(const SvcIdentity *svc);
+int32_t IpcIoBufferOffset(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naru deviceauth/frameworks/inc/lite/ipc_callback_proxy.h deviceauth_new/frameworks/inc/lite/ipc_callback_proxy.h
--- deviceauth/frameworks/inc/lite/ipc_callback_proxy.h	2025-02-12 16:28:20.657341600 +0800
+++ deviceauth_new/frameworks/inc/lite/ipc_callback_proxy.h	2025-02-12 15:01:27.806543400 +0800
@@ -1,32 +1,32 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef IPC_CALLBACK_PROXY_H
-#define IPC_CALLBACK_PROXY_H
-
-#include "ipc_iface.h"
-#include <serializer.h>
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void CbProxySendRequest(SvcIdentity sid, int32_t callbackId, uintptr_t cbHook, IpcIo *data, IpcIo *reply);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_CALLBACK_PROXY_H
+#define IPC_CALLBACK_PROXY_H
+
+#include "ipc_iface.h"
+#include <serializer.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void CbProxySendRequest(SvcIdentity sid, int32_t callbackId, uintptr_t cbHook, IpcIo *data, IpcIo *reply);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naru deviceauth/frameworks/inc/lite/ipc_callback_stub.h deviceauth_new/frameworks/inc/lite/ipc_callback_stub.h
--- deviceauth/frameworks/inc/lite/ipc_callback_stub.h	2025-02-12 16:28:20.698510200 +0800
+++ deviceauth_new/frameworks/inc/lite/ipc_callback_stub.h	2025-02-12 15:01:27.806543400 +0800
@@ -1,36 +1,36 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef IPC_CALLBACK_STUB_H
-#define IPC_CALLBACK_STUB_H
-
-#include <stdbool.h>
-#include <serializer.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    SvcIdentity stubIdentity;
-    bool registed;
-} StubDevAuthCb;
-
-int32_t CbStubOnRemoteRequest(const IpcContext *ctx, void *ipcMsg, IpcIo *data, void *arg);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_CALLBACK_STUB_H
+#define IPC_CALLBACK_STUB_H
+
+#include <stdbool.h>
+#include "ipc_skeleton.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    SvcIdentity stubIdentity;
+    bool registered;
+} StubDevAuthCb;
+
+int32_t CbStubOnRemoteRequest(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naru deviceauth/frameworks/inc/lite/ipc_dev_auth_proxy.h deviceauth_new/frameworks/inc/lite/ipc_dev_auth_proxy.h
--- deviceauth/frameworks/inc/lite/ipc_dev_auth_proxy.h	2025-02-12 16:28:20.732238200 +0800
+++ deviceauth_new/frameworks/inc/lite/ipc_dev_auth_proxy.h	2025-02-12 15:01:27.806543400 +0800
@@ -1,47 +1,47 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef IPC_DEV_AUTH_PROXY_H
-#define IPC_DEV_AUTH_PROXY_H
-
-#include <stdbool.h>
-#include <stdint.h>
-#include "ipc_iface.h"
-#include "iproxy_client.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    IpcIo *reply;
-    IpcIo *data;
-    IpcIo *tmpData;
-    int32_t paramCnt;
-    SvcIdentity cbSvc;
-    int32_t ioBuffOffset;
-    bool withCallback;
-} ProxyDevAuthData;
-
-int32_t EncodeCallRequest(ProxyDevAuthData *dataCtx, int32_t type, const uint8_t *param, int32_t paramSz);
-int32_t FinalCallRequest(ProxyDevAuthData *dataCtx, int32_t methodId);
-int32_t ActCall(const IClientProxy *clientInst, ProxyDevAuthData *dataCtx);
-void SetCallbackStub(ProxyDevAuthData *dataCtx, const SvcIdentity *cbSvc);
-const IClientProxy *GetProxyInstance(const char *serviceName);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_DEV_AUTH_PROXY_H
+#define IPC_DEV_AUTH_PROXY_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "ipc_iface.h"
+#include "iproxy_client.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    IpcIo *reply;
+    IpcIo *data;
+    IpcIo *tmpData;
+    int32_t paramCnt;
+    SvcIdentity cbSvc;
+    int32_t ioBuffOffset;
+    bool withCallback;
+} ProxyDevAuthData;
+
+int32_t EncodeCallRequest(ProxyDevAuthData *dataCtx, int32_t type, const uint8_t *param, int32_t paramSz);
+int32_t FinalCallRequest(ProxyDevAuthData *dataCtx, int32_t methodId);
+int32_t ActCall(const IClientProxy *clientInst, ProxyDevAuthData *dataCtx);
+void SetCallbackStub(ProxyDevAuthData *dataCtx, const SvcIdentity *cbSvc);
+const IClientProxy *GetProxyInstance(const char *serviceName);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naru deviceauth/frameworks/inc/lite/ipc_dev_auth_stub.h deviceauth_new/frameworks/inc/lite/ipc_dev_auth_stub.h
--- deviceauth/frameworks/inc/lite/ipc_dev_auth_stub.h	2025-02-12 16:28:20.761502600 +0800
+++ deviceauth_new/frameworks/inc/lite/ipc_dev_auth_stub.h	2025-02-12 15:01:27.806543400 +0800
@@ -29,8 +29,8 @@
     IpcServiceCall method;
     int32_t methodId;
 } IpcServiceCallMap;
-#define MAX_CALLMAP_SIZE 32
-#define MAX_CBSTUB_SIZE 32
+#define MAX_CALLMAP_SIZE 64
+#define MAX_CBSTUB_SIZE 64
 
 typedef LiteIpcCallService DevAuthService;
 
@@ -41,7 +41,7 @@
 void AddCbDeathRecipient(int32_t cbStubIdx, int32_t cbDataIdx);
 void ResetRemoteObject(int32_t idx);
 void ActCallback(int32_t objIdx, int32_t callbackId, uintptr_t cbHook, IpcIo *dataParcel, IpcIo *reply);
-int32_t OnRemoteRequest(IServerProxy *iProxy, int32_t reqId, void *origin, IpcIo *req, IpcIo *reply);
+int32_t OnRemoteInvoke(IServerProxy *iProxy, int32_t reqId, void *origin, IpcIo *req, IpcIo *reply);
 
 #ifdef __cplusplus
 }
diff -Naru deviceauth/frameworks/inc/lite/ipc_iface.h deviceauth_new/frameworks/inc/lite/ipc_iface.h
--- deviceauth/frameworks/inc/lite/ipc_iface.h	2025-02-12 16:28:20.788781400 +0800
+++ deviceauth_new/frameworks/inc/lite/ipc_iface.h	2025-02-12 15:01:27.806543400 +0800
@@ -1,44 +1,44 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef IPC_IFACE_H
-#define IPC_IFACE_H
-
-#include "iproxy_server.h"
-#include "samgr_lite.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-enum DevAuthOpType {
-    DEV_AUTH_CALL_REQUEST = 1,
-    DEV_AUTH_CALLBACK_REQUEST = 2,
-};
-
-typedef struct {
-    INHERIT_SERVER_IPROXY;
-} LiteIpcProxyApi;
-
-typedef struct {
-    INHERIT_SERVICE;
-    INHERIT_IUNKNOWNENTRY(LiteIpcProxyApi);
-    Identity identity;
-} LiteIpcCallService;
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_IFACE_H
+#define IPC_IFACE_H
+
+#include "iproxy_server.h"
+#include "samgr_lite.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum DevAuthOpType {
+    DEV_AUTH_CALL_REQUEST = 1,
+    DEV_AUTH_CALLBACK_REQUEST = 2,
+};
+
+typedef struct {
+    INHERIT_SERVER_IPROXY;
+} LiteIpcProxyApi;
+
+typedef struct {
+    INHERIT_SERVICE;
+    INHERIT_IUNKNOWNENTRY(LiteIpcProxyApi);
+    Identity identity;
+} LiteIpcCallService;
+
+#ifdef __cplusplus
+}
+#endif
 #endif
\ No newline at end of file
diff -Naru deviceauth/frameworks/inc/lite/ipc_service_init.h deviceauth_new/frameworks/inc/lite/ipc_service_init.h
--- deviceauth/frameworks/inc/lite/ipc_service_init.h	2025-02-12 16:28:20.818542800 +0800
+++ deviceauth_new/frameworks/inc/lite/ipc_service_init.h	2025-02-12 15:01:27.806543400 +0800
@@ -1,28 +1,28 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef IPC_SEREVICE_INIT_H
-#define IPC_SEREVICE_INIT_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-#endif
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IPC_SEREVICE_INIT_H
+#define IPC_SEREVICE_INIT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff -Naru deviceauth/frameworks/inc/standard/ipc_adapt.h deviceauth_new/frameworks/inc/standard/ipc_adapt.h
--- deviceauth/frameworks/inc/standard/ipc_adapt.h	2025-02-12 16:28:20.847310600 +0800
+++ deviceauth_new/frameworks/inc/standard/ipc_adapt.h	2025-02-12 15:01:27.806543400 +0800
@@ -16,7 +16,6 @@
 #ifndef IPC_ADAPT_H
 #define IPC_ADAPT_H
 
-#include <stdbool.h>
 #include <stdint.h>
 #include "device_auth.h"
 
diff -Naru deviceauth/frameworks/inc/standard/ipc_callback_proxy.h deviceauth_new/frameworks/inc/standard/ipc_callback_proxy.h
--- deviceauth/frameworks/inc/standard/ipc_callback_proxy.h	2025-02-12 16:28:20.910799100 +0800
+++ deviceauth_new/frameworks/inc/standard/ipc_callback_proxy.h	2025-02-12 15:01:27.806543400 +0800
@@ -24,7 +24,7 @@
 public:
     explicit ProxyDevAuthCb(const sptr<IRemoteObject> &impl);
     ~ProxyDevAuthCb();
-    virtual void DoCallBack(int32_t callbackId, uintptr_t cbHook,
+    void DoCallBack(int32_t callbackId, uintptr_t cbHook,
         MessageParcel &dataParcel, MessageParcel &reply, MessageOption &option) override;
 private:
     static inline BrokerDelegator<ProxyDevAuthCb> delegator_;
diff -Naru deviceauth/frameworks/inc/standard/ipc_callback_stub.h deviceauth_new/frameworks/inc/standard/ipc_callback_stub.h
--- deviceauth/frameworks/inc/standard/ipc_callback_stub.h	2025-02-12 16:28:20.940063100 +0800
+++ deviceauth_new/frameworks/inc/standard/ipc_callback_stub.h	2025-02-12 15:01:27.806543400 +0800
@@ -24,9 +24,9 @@
 public:
     StubDevAuthCb();
     ~StubDevAuthCb();
-    virtual int32_t OnRemoteRequest(uint32_t code, MessageParcel &data,
+    int32_t OnRemoteRequest(uint32_t code, MessageParcel &data,
         MessageParcel &reply, MessageOption &option) override;
-    virtual void DoCallBack(int32_t callbackId, uintptr_t cbHook,
+    void DoCallBack(int32_t callbackId, uintptr_t cbHook,
         MessageParcel &dataParcel, MessageParcel &reply, MessageOption &option) override;
 };
 }
diff -Naru deviceauth/frameworks/inc/standard/ipc_dev_auth_stub.h deviceauth_new/frameworks/inc/standard/ipc_dev_auth_stub.h
--- deviceauth/frameworks/inc/standard/ipc_dev_auth_stub.h	2025-02-12 16:28:21.039262200 +0800
+++ deviceauth_new/frameworks/inc/standard/ipc_dev_auth_stub.h	2025-02-12 15:01:27.806543400 +0800
@@ -25,19 +25,20 @@
     IpcServiceCall method;
     int32_t methodId;
 } IpcServiceCallMap;
-const int32_t MAX_CALLMAP_SIZE = 32;
-const int32_t MAX_CBSTUB_SIZE = 32;
+const int32_t MAX_CALLMAP_SIZE = 64;
+const int32_t MAX_CBSTUB_SIZE = 64;
 
 class ServiceDevAuth : public IRemoteStub<IMethodsIpcCall> {
 public:
     ServiceDevAuth();
-    ~ServiceDevAuth();
-    virtual int32_t OnRemoteRequest(uint32_t code, MessageParcel &data,
+    ~ServiceDevAuth() override;
+    int32_t Dump(int32_t fd, const std::vector<std::u16string>& args) override;
+    int32_t OnRemoteRequest(uint32_t code, MessageParcel &data,
         MessageParcel &reply, MessageOption &option) override;
     void ResetCallMap(void);
     int32_t SetCallMap(IpcServiceCall method, int32_t methodId);
     static int32_t SetRemoteObject(sptr<IRemoteObject> &object);
-    static void SetCbDeathRecipient(int32_t cbStubIdx, int32_t cbDataIdx);
+    static void AddCbDeathRecipient(int32_t cbStubIdx, int32_t cbDataIdx);
     static void ResetRemoteObject(int32_t idx);
     static void ActCallback(int32_t objIdx, int32_t callbackId, bool sync,
         uintptr_t cbHook, MessageParcel &dataParcel, MessageParcel &reply);
@@ -52,9 +53,9 @@
 class DevAuthDeathRecipient : public IRemoteObject::DeathRecipient {
 public:
     DevAuthDeathRecipient() {}
-    DevAuthDeathRecipient(int32_t cbIdx);
-    ~DevAuthDeathRecipient() {}
-    virtual void OnRemoteDied(const wptr<IRemoteObject>& remoteObject) override;
+    explicit DevAuthDeathRecipient(int32_t cbIdx);
+    ~DevAuthDeathRecipient() override {}
+    void OnRemoteDied(const wptr<IRemoteObject>& remoteObject) override;
 private:
     int32_t callbackIdx;
 };
diff -Naru deviceauth/frameworks/inc/standard/ipc_iface.h deviceauth_new/frameworks/inc/standard/ipc_iface.h
--- deviceauth/frameworks/inc/standard/ipc_iface.h	2025-02-12 16:28:21.080926700 +0800
+++ deviceauth_new/frameworks/inc/standard/ipc_iface.h	2025-02-12 15:01:27.806543400 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Copyright (C) 2021-2022 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -26,7 +26,7 @@
     enum {
         DEV_AUTH_CALL_REQUEST = 1,
     };
-    DECLARE_INTERFACE_DESCRIPTOR(u"MethodsIpcCall");
+    DECLARE_INTERFACE_DESCRIPTOR(u"deviceauth.IMethodsIpcCall");
 };
 
 class ICommIpcCallback : public IRemoteBroker {
@@ -34,7 +34,7 @@
     enum {
         DEV_AUTH_CALLBACK_REQUEST = 1,
     };
-    DECLARE_INTERFACE_DESCRIPTOR(u"CommIpcCallback");
+    DECLARE_INTERFACE_DESCRIPTOR(u"deviceauth.ICommIpcCallback");
     virtual void DoCallBack(int32_t callbackId, uintptr_t cbHook,
         MessageParcel &dataParcel, MessageParcel &reply, MessageOption &option) = 0;
 };
diff -Naru deviceauth/frameworks/src/ipc_sdk.c deviceauth_new/frameworks/src/ipc_sdk.c
--- deviceauth/frameworks/src/ipc_sdk.c	2025-02-12 16:28:21.148382300 +0800
+++ deviceauth_new/frameworks/src/ipc_sdk.c	2025-02-12 15:01:27.822543400 +0800
@@ -1696,40 +1696,40 @@
 
     LOGI("starting ...");
     if (!IS_STRING_VALID(appId) || !IS_STRING_VALID(groupId) || !IS_STRING_VALID(udid)) {
-        return false;
+        return HC_ERR_INVALID_PARAMS;
     }
     if (!IsServiceRunning()) {
         LOGE("service is not activity");
-        return false;
+        return HC_ERROR;
     }
     ret = CreateCallCtx(&callCtx, NULL);
     if (ret != HC_SUCCESS) {
         LOGE("CreateCallCtx failed, ret %d", ret);
-        return false;
+        return HC_ERR_IPC_INIT;
     }
     ret = SetCallRequestParamInfo(callCtx, PARAM_TYPE_APPID, (const uint8_t *)appId, strlen(appId) + 1);
     if (ret != HC_SUCCESS) {
         LOGE("set request param failed, ret %d, param id %d", ret, PARAM_TYPE_APPID);
         DestroyCallCtx(&callCtx, NULL);
-        return false;
+        return HC_ERR_IPC_BUILD_PARAM;
     }
     ret = SetCallRequestParamInfo(callCtx, PARAM_TYPE_GROUPID, (const uint8_t *)groupId, strlen(groupId) + 1);
     if (ret != HC_SUCCESS) {
         LOGE("set request param failed, ret %d, param id %d", ret, PARAM_TYPE_GROUPID);
         DestroyCallCtx(&callCtx, NULL);
-        return false;
+        return HC_ERR_IPC_BUILD_PARAM;
     }
     ret = SetCallRequestParamInfo(callCtx, PARAM_TYPE_UDID, (const uint8_t *)udid, strlen(udid) + 1);
     if (ret != HC_SUCCESS) {
         LOGE("set request param failed, ret %d, param id %d", ret, PARAM_TYPE_UDID);
         DestroyCallCtx(&callCtx, NULL);
-        return false;
+        return HC_ERR_IPC_BUILD_PARAM;
     }
     ret = DoBinderCall(callCtx, IPC_CALL_ID_IS_DEV_IN_GROUP, true);
     if (ret == HC_ERR_IPC_INTERNAL_FAILED) {
         LOGE("ipc call failed");
         DestroyCallCtx(&callCtx, NULL);
-        return false;
+        return HC_ERR_IPC_PROC_FAILED;
     }
     DecodeCallReply(callCtx, &replyCache, REPLAY_CACHE_NUM(replyCache));
     ret = HC_ERR_IPC_UNKNOW_REPLY;
@@ -1909,29 +1909,29 @@
 
     LOGI("starting ...");
     if (udid == NULL) {
-        return false;
+        return HC_ERR_INVALID_PARAMS;
     }
     if (!IsServiceRunning()) {
         LOGE("service is not activity");
-        return false;
+        return HC_ERROR;
     }
     ret = CreateCallCtx(&callCtx, NULL);
     if (ret != HC_SUCCESS) {
         LOGE("CreateCallCtx failed, ret %d", ret);
-        return false;
+        return HC_ERR_IPC_INIT;
     }
     uint32_t udidLen = strlen(udid) + 1;
     ret = SetCallRequestParamInfo(callCtx, PARAM_TYPE_COMM_DATA, (const uint8_t *)udid, udidLen);
     if (ret != HC_SUCCESS) {
         LOGE("set request param failed, ret %d, param id %d", ret, PARAM_TYPE_COMM_DATA);
         DestroyCallCtx(&callCtx, NULL);
-        return false;
+        return HC_ERR_IPC_BUILD_PARAM;
     }
     ret = DoBinderCall(callCtx, IPC_CALL_ID_IS_TRUST_DEVICE, true);
     if (ret == HC_ERR_IPC_INTERNAL_FAILED) {
         LOGE("ipc call failed");
         DestroyCallCtx(&callCtx, NULL);
-        return false;
+        return HC_ERR_IPC_PROC_FAILED;
     }
     DecodeCallReply(callCtx, &replyCache, REPLAY_CACHE_NUM(replyCache));
     ret = HC_ERR_IPC_UNKNOW_REPLY;
diff -Naru deviceauth/frameworks/src/lite/ipc_adapt.c deviceauth_new/frameworks/src/lite/ipc_adapt.c
--- deviceauth/frameworks/src/lite/ipc_adapt.c	2025-02-12 16:28:21.295695600 +0800
+++ deviceauth_new/frameworks/src/lite/ipc_adapt.c	2025-02-12 15:01:27.826543400 +0800
@@ -24,7 +24,7 @@
 #include "ipc_dev_auth_stub.h"
 #include "ipc_sdk.h"
 #include "ipc_service.h"
-#include "liteipc_adapter.h"
+#include "ipc_skeleton.h"
 #include "securec.h"
 
 #ifdef __cplusplus
@@ -57,6 +57,7 @@
 
 static StubDevAuthCb g_sdkCbStub;
 static IClientProxy *g_proxyInstance = NULL;
+static IpcObjectStub g_objectStub;
 
 static void SetIpcCallBackNodeDefault(IpcCallBackNode *node)
 {
@@ -450,7 +451,7 @@
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum,
         PARAM_TYPE_COMM_DATA, (uint8_t *)&data, (int32_t *)(&dataLen));
     bRet = onTransmitHook(requestId, data, dataLen);
-    (bRet == true) ? IpcIoPushInt32(reply, HC_SUCCESS) : IpcIoPushInt32(reply, HC_ERROR);
+    (bRet == true) ? WriteInt32(reply, HC_SUCCESS) : WriteInt32(reply, HC_ERROR);
     return;
 }
 
@@ -468,7 +469,7 @@
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_SESS_KEY,
         (uint8_t *)(&keyData), (int32_t *)(&dataLen));
     onSessKeyHook(requestId, keyData, dataLen);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -487,7 +488,7 @@
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_OPCODE, (uint8_t *)(&opCode), &inOutLen);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_COMM_DATA, (uint8_t *)(&data), NULL);
     onFinishHook(requestId, opCode, data);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -508,7 +509,7 @@
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_ERRCODE, (uint8_t *)(&errCode), &inOutLen);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_ERR_INFO, (uint8_t *)(&errInfo), NULL);
     onErrorHook(requestId, opCode, errCode, errInfo);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -529,11 +530,11 @@
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_REQ_INFO, (uint8_t *)(&reqParams), NULL);
     reqResult = onReqHook(requestId, opCode, reqParams);
     if (reqResult == NULL) {
-        IpcIoPushInt32(reply, HC_ERROR);
+        WriteInt32(reply, HC_ERROR);
         return;
     }
-    IpcIoPushInt32(reply, HC_SUCCESS);
-    IpcIoPushString(reply, (const char *)(reqResult));
+    WriteInt32(reply, HC_SUCCESS);
+    WriteString(reply, (const char *)(reqResult));
     HcFree(reqResult);
     reqResult = NULL;
     return;
@@ -547,7 +548,7 @@
     onGroupCreatedHook = (void (*)(const char *))(cbHook);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_GROUP_INFO, (uint8_t *)(&groupInfo), NULL);
     onGroupCreatedHook(groupInfo);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -559,7 +560,7 @@
     onDelGroupHook = (void (*)(const char *))(cbHook);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_GROUP_INFO, (uint8_t *)(&groupInfo), NULL);
     onDelGroupHook(groupInfo);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -573,7 +574,7 @@
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_UDID, (uint8_t *)(&udid), NULL);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_GROUP_INFO, (uint8_t *)(&groupInfo), NULL);
     onDevBoundHook(udid, groupInfo);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -587,7 +588,7 @@
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_UDID, (uint8_t *)(&udid), NULL);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_GROUP_INFO, (uint8_t *)(&groupInfo), NULL);
     onDevUnBoundHook(udid, groupInfo);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -599,7 +600,7 @@
     onDevUnTrustHook = (void (*)(const char *))(cbHook);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_UDID, (uint8_t *)(&udid), NULL);
     onDevUnTrustHook(udid);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -615,7 +616,7 @@
     inOutLen = sizeof(groupType);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_GROUP_TYPE, (uint8_t *)(&groupType), &inOutLen);
     onDelLastGroupHook(udid, groupType);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -630,7 +631,7 @@
     inOutLen = sizeof(devNum);
     (void)GetIpcRequestParamByType(cbDataCache, cacheNum, PARAM_TYPE_DATA_NUM, (uint8_t *)(&devNum), &inOutLen);
     onTrustDevNumChangedHook(devNum);
-    IpcIoPushInt32(reply, HC_SUCCESS);
+    WriteInt32(reply, HC_SUCCESS);
     return;
 }
 
@@ -669,9 +670,10 @@
         paramTmp = (const uint8_t *)(&zeroVal);
         paramSz = sizeof(zeroVal);
     }
-    IpcIoPushInt32(dataParcel, type);
-    IpcIoPushFlatObj(dataParcel, (const void *)(paramTmp), (uint32_t)paramSz);
-    if (!IpcIoAvailable(dataParcel)) {
+    WriteInt32(dataParcel, type);
+    WriteUint32(dataParcel, (uint32_t)paramSz);
+    bool ret = WriteBuffer(dataParcel, (const void *)(paramTmp), (uint32_t)paramSz);
+    if (!ret) {
         return (uint32_t)(HC_ERROR);
     }
     return (uint32_t)(HC_SUCCESS);
@@ -683,7 +685,7 @@
     uint32_t ret;
     IpcIo *dataParcel = NULL;
     IpcIo reply;
-    uint8_t dataBuf[IPC_STACK_BUFF_SZ] = {0};
+    uint8_t dataBuf[IPC_STACK_BUFF_SZ] = { 0 };
     IpcCallBackNode *node = NULL;
 
     LOGI("starting ... request id: %lld, type %d", requestId, type);
@@ -712,7 +714,9 @@
     UnLockCallbackList();
     HcFree((void *)dataParcel);
     LOGI("process done, request id: %lld", requestId);
-    if (IpcIoAvailable(&reply) && (IpcIoPopInt32(&reply) == HC_SUCCESS)) {
+    int32_t value;
+    ReadInt32(&reply, &value);
+    if (value == HC_SUCCESS) {
         return true;
     }
     return false;
@@ -883,7 +887,7 @@
     uint32_t uRet;
     IpcIo *dataParcel = NULL;
     IpcIo reply;
-    uint8_t dataBuf[IPC_STACK_BUFF_SZ] = {0};
+    uint8_t dataBuf[IPC_STACK_BUFF_SZ] = { 0 };
     const char *dPtr = NULL;
     IpcCallBackNode *node = NULL;
 
@@ -916,11 +920,9 @@
     ActCallback(node->proxyId, CB_ID_ON_REQUEST, (uintptr_t)(node->cbCtx.devAuth.onRequest), dataParcel, &reply);
     UnLockCallbackList();
     HcFree((void *)dataParcel);
-    if (IpcIoAvailable(&reply)) {
-        ret = IpcIoPopInt32(&reply);
-        if (ret == HC_SUCCESS) {
-            dPtr = (const char *)IpcIoPopString(&reply, NULL);
-        }
+    ReadInt32(&reply, &ret);
+    if (ret == HC_SUCCESS) {
+        dPtr = (const char *)ReadString(&reply, NULL);
     }
     LOGI("process done, request id: %lld, %s result", requestId, (dPtr != NULL) ? "valid" : "invalid");
     return (dPtr != NULL) ? strdup(dPtr) : NULL;
@@ -998,7 +1000,6 @@
         if (g_ipcCallBackList.ctx[i].cbType == CB_TYPE_LISTENER) {
             listener = &(g_ipcCallBackList.ctx[i].cbCtx.listener);
             if (listener->onGroupCreated == NULL) {
-                LOGE("onGroupCreated hook is invalid");
                 continue;
             }
             ActCallback(g_ipcCallBackList.ctx[i].proxyId, CB_ID_ON_GROUP_CREATED,
@@ -1046,7 +1047,6 @@
         if (g_ipcCallBackList.ctx[i].cbType == CB_TYPE_LISTENER) {
             listener = &(g_ipcCallBackList.ctx[i].cbCtx.listener);
             if (listener->onGroupDeleted == NULL) {
-                LOGE("onGroupDeleted hook is null");
                 continue;
             }
             ActCallback(g_ipcCallBackList.ctx[i].proxyId, CB_ID_ON_GROUP_DELETED,
@@ -1095,7 +1095,6 @@
         if (g_ipcCallBackList.ctx[i].cbType == CB_TYPE_LISTENER) {
             listener = &(g_ipcCallBackList.ctx[i].cbCtx.listener);
             if (listener->onDeviceBound == NULL) {
-                LOGE("onDeviceBound hook is null");
                 continue;
             }
             ActCallback(g_ipcCallBackList.ctx[i].proxyId, CB_ID_ON_DEV_BOUND,
@@ -1144,7 +1143,6 @@
         if (g_ipcCallBackList.ctx[i].cbType == CB_TYPE_LISTENER) {
             listener = &(g_ipcCallBackList.ctx[i].cbCtx.listener);
             if (listener->onDeviceUnBound == NULL) {
-                LOGE("onDeviceUnBound hook is null");
                 continue;
             }
             ActCallback(g_ipcCallBackList.ctx[i].proxyId, CB_ID_ON_DEV_UNBOUND,
@@ -1192,7 +1190,6 @@
         if (g_ipcCallBackList.ctx[i].cbType == CB_TYPE_LISTENER) {
             listener = &(g_ipcCallBackList.ctx[i].cbCtx.listener);
             if (listener->onDeviceNotTrusted == NULL) {
-                LOGE("onDeviceNotTrusted hook is null");
                 continue;
             }
             ActCallback(g_ipcCallBackList.ctx[i].proxyId, CB_ID_ON_DEV_UNTRUSTED,
@@ -1241,7 +1238,6 @@
         if (g_ipcCallBackList.ctx[i].cbType == CB_TYPE_LISTENER) {
             listener = &(g_ipcCallBackList.ctx[i].cbCtx.listener);
             if (listener->onLastGroupDeleted == NULL) {
-                LOGE("onLastGroupDeleted hook is null");
                 continue;
             }
             ActCallback(g_ipcCallBackList.ctx[i].proxyId, CB_ID_ON_LAST_GROUP_DELETED,
@@ -1285,7 +1281,6 @@
         if (g_ipcCallBackList.ctx[i].cbType == CB_TYPE_LISTENER) {
             listener = &(g_ipcCallBackList.ctx[i].cbCtx.listener);
             if (listener->onTrustedDeviceNumChanged == NULL) {
-                LOGE("onTrustedDeviceNumChanged hook is null");
                 continue;
             }
             ActCallback(g_ipcCallBackList.ctx[i].proxyId, CB_ID_ON_TRUST_DEV_NUM_CHANGED,
@@ -1392,8 +1387,8 @@
     ProxyDevAuthData *dataCache = NULL;
     const SvcIdentity *stubInfo = &g_sdkCbStub.stubIdentity;
     (void)cbIdx;
-    if (!g_sdkCbStub.registed) {
-        LOGW("SDK callback stub un-registed");
+    if (!g_sdkCbStub.registered) {
+        LOGW("SDK callback stub un-registered");
         return;
     }
     ShowIpcSvcInfo(stubInfo);
@@ -1460,14 +1455,17 @@
     unsigned long valZero = 0ul;
 
     replyParcel = (IpcIo *)(replayCache);
-    IpcIoPushInt32(replyParcel, type);
+    WriteInt32(replyParcel, type);
+    bool value;
     if ((result != NULL) && (resultSz > 0)) {
-        IpcIoPushFlatObj(replyParcel, (const void *)result, (uint32_t)resultSz);
+        WriteUint32(replyParcel, (uint32_t)resultSz);
+        value = WriteBuffer(replyParcel, (const void *)result, (uint32_t)resultSz);
     } else {
-        IpcIoPushFlatObj(replyParcel, (const void *)(&valZero), sizeof(valZero));
+        WriteUint32(replyParcel, sizeof(valZero));
+        value = WriteBuffer(replyParcel, (const void *)(&valZero), sizeof(valZero));
     }
-    if (!IpcIoAvailable(replyParcel)) {
-        ret = HC_ERROR;
+    if (!value) {
+        return HC_FALSE;
     }
     LOGI("reply type %d, %s", type, (ret == HC_SUCCESS) ? "success" : "failed");
     return ret;
@@ -1481,11 +1479,9 @@
     if (dataPtr->bufferLeft <= 0) {
         return HC_SUCCESS;
     }
-    *type = IpcIoPopInt32(dataPtr);
-    *val = (uint8_t *)IpcIoPopFlatObj(dataPtr, (uint32_t *)valSz);
-    if (!IpcIoAvailable(dataPtr)) {
-        return HC_ERROR;
-    }
+    ReadInt32(dataPtr, type);
+    ReadUint32(dataPtr, (uint32_t *)valSz);
+    *val = (uint8_t *)ReadBuffer(dataPtr, *valSz);
     return HC_SUCCESS;
 }
 
@@ -1496,7 +1492,7 @@
     uint32_t replyLen;
 
     ProxyDevAuthData *dataCache = (ProxyDevAuthData *)(callCtx);
-    replyLen = IpcIoPopUint32(dataCache->reply);
+    ReadUint32(dataCache->reply, &replyLen);
     LOGI("to decode data length %u", replyLen);
     if (replyLen == 0) {
         return;
@@ -1518,9 +1514,9 @@
     int32_t typeList[] = {
         PARAM_TYPE_APPID, PARAM_TYPE_DEV_AUTH_CB, PARAM_TYPE_LISTERNER, PARAM_TYPE_CREATE_PARAMS,
         PARAM_TYPE_GROUPID, PARAM_TYPE_UDID, PARAM_TYPE_ADD_PARAMS, PARAM_TYPE_DEL_PARAMS,
-        PARAM_TYPE_BIND, PARAM_TYPE_UNBIND, PARAM_TYPE_CREDENTIAL, PARAM_TYPE_MGR_APPID,
-        PARAM_TYPE_FRIEND_APPID, PARAM_TYPE_QUERY_PARAMS, PARAM_TYPE_COMM_DATA, PARAM_TYPE_REQ_CFM,
-        PARAM_TYPE_SESS_KEY, PARAM_TYPE_REQ_INFO, PARAM_TYPE_GROUP_INFO, PARAM_TYPE_AUTH_PARAMS
+        PARAM_TYPE_BIND, PARAM_TYPE_UNBIND, PARAM_TYPE_MGR_APPID, PARAM_TYPE_FRIEND_APPID,
+        PARAM_TYPE_QUERY_PARAMS, PARAM_TYPE_COMM_DATA, PARAM_TYPE_REQ_CFM, PARAM_TYPE_SESS_KEY,
+        PARAM_TYPE_REQ_INFO, PARAM_TYPE_GROUP_INFO, PARAM_TYPE_AUTH_PARAMS, PARAM_TYPE_REQ_JSON
     };
     int32_t i;
     int32_t n = sizeof(typeList) / sizeof(typeList[0]);
@@ -1535,7 +1531,7 @@
 static bool IsTypeForCpyData(int32_t type)
 {
     int32_t typeList[] = {
-        PARAM_TYPE_REQID, PARAM_TYPE_GROUP_TYPE, PARAM_TYPE_OPCODE, PARAM_TYPE_ERRCODE
+        PARAM_TYPE_REQID, PARAM_TYPE_GROUP_TYPE, PARAM_TYPE_OPCODE, PARAM_TYPE_ERRCODE, PARAM_TYPE_OS_ACCOUNT_ID
     };
     int32_t i;
     int32_t n = sizeof(typeList) / sizeof(typeList[0]);
@@ -1621,11 +1617,6 @@
     buf = (uint8_t *)ioPtr + sizeof(IpcIo);
     /* ipcio inited with 4 svc objects */
     IpcIoInit(ioPtr, (void *)buf, buffSz, 4);
-    if (!IpcIoAvailable(ioPtr)) {
-        LOGE("IpcIoInit failed");
-        HcFree((void *)ioPtr);
-        return NULL;
-    }
     return ioPtr;
 }
 
@@ -1634,7 +1625,7 @@
     uintptr_t beginPos;
     uintptr_t endPos;
 
-    if ((io == NULL) || !IpcIoAvailable((IpcIo *)io)) {
+    if (io == NULL) {
         return 0;
     }
     beginPos = (uintptr_t)(io->bufferBase + IpcIoBufferOffset());
@@ -1644,19 +1635,12 @@
 
 void ShowIpcSvcInfo(const SvcIdentity *svc)
 {
-#ifdef __LINUX__
-    LOGI("svc information - handle(%u), token(%u), cookie(%u), ipcContext(%p)",
-        svc->handle, svc->token, svc->cookie, svc->ipcContext);
-#else
     LOGI("svc information - handle(%u), token(%u), cookie(%u)",
         svc->handle, svc->token, svc->cookie);
-#endif
 }
 
 int32_t InitProxyAdapt(void)
 {
-    int32_t ret;
-
     if (g_proxyInstance == NULL) {
         g_proxyInstance = (IClientProxy *)GetProxyInstance(DEV_AUTH_SERVICE_NAME);
         if (g_proxyInstance == NULL) {
@@ -1666,15 +1650,17 @@
         LOGI("get proxy instance success");
     }
 
-    if (!g_sdkCbStub.registed) {
-        ret = RegisterIpcCallback(CbStubOnRemoteRequest, 0, IPC_WAIT_FOREVER, &(g_sdkCbStub.stubIdentity), NULL);
-        if (ret != 0) {
-            LOGE("register ipc cb failed");
-            return HC_ERR_IPC_INIT;
-        }
+    if (!g_sdkCbStub.registered) {
+        g_objectStub.func = CbStubOnRemoteRequest;
+        g_objectStub.args = NULL;
+        g_objectStub.isRemote = false;
+        g_sdkCbStub.stubIdentity.handle = IPC_INVALID_HANDLE;
+        g_sdkCbStub.stubIdentity.token = SERVICE_TYPE_ANONYMOUS;
+        g_sdkCbStub.stubIdentity.cookie = (uintptr_t)&g_objectStub;
+
         ShowIpcSvcInfo(&(g_sdkCbStub.stubIdentity));
         LOGI("register ipc cb success");
-        g_sdkCbStub.registed = true;
+        g_sdkCbStub.registered = true;
     }
     return HC_SUCCESS;
 }
@@ -1682,10 +1668,7 @@
 void UnInitProxyAdapt(void)
 {
     g_proxyInstance = NULL;
-    if (UnregisterIpcCallback(g_sdkCbStub.stubIdentity)) {
-        LOGW("un-register ipc cb failed");
-    }
-    g_sdkCbStub.registed = false;
+    g_sdkCbStub.registered = false;
     return;
 }
 
diff -Naru deviceauth/frameworks/src/lite/ipc_callback_proxy.c deviceauth_new/frameworks/src/lite/ipc_callback_proxy.c
--- deviceauth/frameworks/src/lite/ipc_callback_proxy.c	2025-02-12 16:28:21.343312100 +0800
+++ deviceauth_new/frameworks/src/lite/ipc_callback_proxy.c	2025-02-12 15:01:27.826543400 +0800
@@ -1,96 +1,90 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "ipc_callback_proxy.h"
-#include "hc_log.h"
-#include "hc_types.h"
-#include "ipc_adapt.h"
-#include "liteipc_adapter.h"
-#include "securec.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-static void CbProxyFormReplyData(int32_t reqRetVal, IpcIo *replyDst, const IpcIo *replySrc)
-{
-    errno_t eno;
-
-    if (!IpcIoAvailable((IpcIo *)replySrc)) {
-        LOGE("reply context is not available");
-        *(int32_t *)(replyDst->bufferCur) = -1;
-        replyDst->bufferLeft = sizeof(int32_t);
-        return;
-    }
-    if (reqRetVal != 0) {
-        *(int32_t *)(replyDst->bufferCur) = reqRetVal;
-        replyDst->bufferLeft = sizeof(int32_t);
-        return;
-    }
-
-    LOGI("with reply data, length(%zu), flag(%u)", replySrc->bufferLeft, replySrc->flag);
-    eno = memcpy_s(replyDst->bufferCur, replyDst->bufferLeft, replySrc->bufferCur, replySrc->bufferLeft);
-    if (eno != EOK) {
-        replyDst->flag = 0;
-        LOGE("memory copy reply data failed");
-        return;
-    }
-    replyDst->bufferLeft = replySrc->bufferLeft;
-    LOGI("out reply data, length(%zu)", replyDst->bufferLeft);
-    return;
-}
-
-void CbProxySendRequest(SvcIdentity sid, int32_t callbackId, uintptr_t cbHook, IpcIo *data, IpcIo *reply)
-{
-    int32_t ret;
-    IpcIo *reqData = NULL;
-    int32_t dataSz;
-    uintptr_t outMsg = 0x0;
-    IpcIo replyTmp;
-
-    ShowIpcSvcInfo(&(sid));
-    reqData = (IpcIo *)InitIpcDataCache(IPC_DATA_BUFF_MAX_SZ);
-    if (reqData == NULL) {
-        return;
-    }
-    IpcIoPushInt32(reqData, callbackId);
-    IpcIoPushUintptr(reqData, cbHook);
-    dataSz = GetIpcIoDataLength((const IpcIo *)data);
-    LOGI("to form callback params data length(%d)", dataSz);
-    if (dataSz > 0) {
-        IpcIoPushFlatObj(reqData, data->bufferBase + IpcIoBufferOffset(), dataSz);
-    }
-    if (!IpcIoAvailable(reqData)) {
-        LOGE("form send data failed");
-        HcFree((void *)reqData);
-        return;
-    }
-    int32_t callFlag = ((reply != NULL) ? 0 : 1);
-    callFlag = 0;
-    ret = SendRequest(NULL, sid, DEV_AUTH_CALLBACK_REQUEST, reqData, &replyTmp, callFlag, &outMsg);
-    LOGI("SendRequest(%d) done, return(%d)", callFlag, ret);
-    HcFree((void *)reqData);
-    if (reply == NULL) {
-        FreeBuffer(NULL, (void *)outMsg);
-        return;
-    }
-    CbProxyFormReplyData(ret, reply, &replyTmp);
-    FreeBuffer(NULL, (void *)outMsg);
-    return;
-}
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ipc_callback_proxy.h"
+#include "hc_log.h"
+#include "hc_types.h"
+#include "ipc_adapt.h"
+#include "ipc_skeleton.h"
+#include "securec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static void CbProxyFormReplyData(int32_t reqRetVal, IpcIo *replyDst, const IpcIo *replySrc)
+{
+    errno_t eno;
+
+    if (reqRetVal != 0) {
+        *(int32_t *)(replyDst->bufferCur) = reqRetVal;
+        replyDst->bufferLeft = sizeof(int32_t);
+        return;
+    }
+
+    LOGI("with reply data, length(%zu), flag(%u)", replySrc->bufferLeft, replySrc->flag);
+    eno = memcpy_s(replyDst->bufferCur, replyDst->bufferLeft, replySrc->bufferCur, replySrc->bufferLeft);
+    if (eno != EOK) {
+        replyDst->flag = 0;
+        LOGE("memory copy reply data failed");
+        return;
+    }
+    replyDst->bufferLeft = replySrc->bufferLeft;
+    LOGI("out reply data, length(%zu)", replyDst->bufferLeft);
+    return;
+}
+
+void CbProxySendRequest(SvcIdentity sid, int32_t callbackId, uintptr_t cbHook, IpcIo *data, IpcIo *reply)
+{
+    int32_t ret;
+    IpcIo *reqData = NULL;
+    int32_t dataSz;
+    uintptr_t outMsg = 0x0;
+    IpcIo replyTmp;
+
+    ShowIpcSvcInfo(&(sid));
+    reqData = (IpcIo *)InitIpcDataCache(IPC_DATA_BUFF_MAX_SZ);
+    if (reqData == NULL) {
+        return;
+    }
+    WriteInt32(reqData, callbackId);
+    WritePointer(reqData, cbHook);
+    dataSz = GetIpcIoDataLength((const IpcIo *)data);
+    LOGI("to form callback params data length(%d)", dataSz);
+    if (dataSz > 0) {
+        WriteUint32(reqData, dataSz);
+        bool value = WriteBuffer(reqData, data->bufferBase + IpcIoBufferOffset(), dataSz);
+        if (!value) {
+            return;
+        }
+    }
+    /* callFlag: ipc mode is blocking or non blocking. */
+    MessageOption option;
+    MessageOptionInit(&option);
+    option.flags = ((reply != NULL) ? TF_OP_SYNC : TF_OP_ASYNC);
+    ret = SendRequest(sid, DEV_AUTH_CALLBACK_REQUEST, reqData, &replyTmp, option, &outMsg);
+    LOGI("SendRequest(%d) done, return(%d)", option.flags, ret);
+    HcFree((void *)reqData);
+    if (reply == NULL) {
+        return;
+    }
+    CbProxyFormReplyData(ret, reply, &replyTmp);
+    FreeBuffer((void *)outMsg);
+    return;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -Naru deviceauth/frameworks/src/lite/ipc_callback_stub.c deviceauth_new/frameworks/src/lite/ipc_callback_stub.c
--- deviceauth/frameworks/src/lite/ipc_callback_stub.c	2025-02-12 16:28:21.388448500 +0800
+++ deviceauth_new/frameworks/src/lite/ipc_callback_stub.c	2025-02-12 15:01:27.826543400 +0800
@@ -1,119 +1,82 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "ipc_callback_stub.h"
-#include "common_defs.h"
-#include "device_auth_defines.h"
-#include "hc_log.h"
-#include "ipc_adapt.h"
-#include "ipc_iface.h"
-#include "liteipc_adapter.h"
-#include "securec.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-static void DoCallBack(int32_t callbackId, uintptr_t cbHook, IpcIo *data, IpcIo *reply)
-{
-    int32_t ret;
-    int32_t i;
-    IpcDataInfo cbDataCache[MAX_REQUEST_PARAMS_NUM] = {{0}};
-
-    if (cbHook == 0x0) {
-        LOGE("Invalid call back hook");
-        return;
-    }
-
-    (void)IpcIoPopUint32(data); /* skip flat object length information */
-    for (i = 0; i < MAX_REQUEST_PARAMS_NUM; i++) {
-        ret = DecodeIpcData((uintptr_t)(data), &(cbDataCache[i].type),
-            &(cbDataCache[i].val), &(cbDataCache[i].valSz));
-        if (ret != HC_SUCCESS) {
-            LOGE("decode failed, ret %d", ret);
-            return;
-        }
-    }
-    ProcCbHook(callbackId, cbHook, cbDataCache, MAX_REQUEST_PARAMS_NUM, (uintptr_t)(reply));
-    return;
-}
-
-static int32_t CbStubOnRemoteReply(void *ipcMsg, IpcIo *reply)
-{
-    uint32_t flag = 0;
-    int32_t ret = 0;
-    IpcIo replyErr;
-    uint8_t replyBuff[16] = {0}; /* length of reply buffer - 16 */
-
-    /* flag: ipc mode is blocking or non blocking. */
-    GetFlag(ipcMsg, &flag);
-    if (flag != LITEIPC_FLAG_DEFAULT) {
-        /* Ipc mode is non blocking. */
-        LOGI("callback - async call(%u)", flag);
-        /* If the system is based on liteipc, the ipcMsg memory needs to be cleaned manually. */
-        FreeBuffer(NULL, ipcMsg);
-        return 0;
-    }
-    /* Ipc mode is blocking. */
-    if (!IpcIoAvailable(reply)) {
-        IpcIoInit(&replyErr, replyBuff, sizeof(replyBuff), 0);
-        IpcIoPushInt32(&replyErr, HC_ERR_IPC_INTERNAL_FAILED);
-        LOGI("callback - SendReply error code(%d)", HC_ERR_IPC_INTERNAL_FAILED);
-        ret = SendReply(NULL, ipcMsg, &replyErr);
-    } else {
-        LOGI("callback - SendReply done");
-        ret = SendReply(NULL, ipcMsg, reply);
-    }
-    return ret;
-}
-
-int32_t CbStubOnRemoteRequest(const IpcContext *ctx, void *ipcMsg, IpcIo *data, void *arg)
-{
-    uint32_t code = 0;
-    int32_t callbackId;
-    uintptr_t cbHook = 0x0;
-    IpcIo reply;
-    uint8_t replyBuff[1024] = {0}; /* length of reply buffer - 1024 */
-    int32_t ret = 0;
-    (void)ctx;
-    (void)arg;
-
-    LOGI("enter invoking callback...");
-    if ((ipcMsg == NULL) || (data == NULL)) {
-        LOGE("invalid param");
-        return -1;
-    }
-
-    GetCode(ipcMsg, &code);
-    LOGI("receive ipc transact code(%u)", code);
-    IpcIoInit(&reply, replyBuff, sizeof(replyBuff), 0);
-    switch (code) {
-        case DEV_AUTH_CALLBACK_REQUEST:
-            callbackId = IpcIoPopInt32(data);
-            cbHook = IpcIoPopUintptr(data);
-            DoCallBack(callbackId, cbHook, data, &reply);
-            break;
-        default:
-            LOGE("Invoke callback cmd code(%u) error", code);
-            break;
-    }
-    ret = CbStubOnRemoteReply(ipcMsg, &reply);
-    LOGI("Invoke callback done, result(%d)", ret);
-    return ret;
-}
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ipc_callback_stub.h"
+#include "common_defs.h"
+#include "device_auth_defines.h"
+#include "hc_log.h"
+#include "ipc_adapt.h"
+#include "ipc_iface.h"
+#include "ipc_skeleton.h"
+#include "securec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static void DoCallBack(int32_t callbackId, uintptr_t cbHook, IpcIo *data, IpcIo *reply)
+{
+    int32_t ret;
+    int32_t i;
+    IpcDataInfo cbDataCache[MAX_REQUEST_PARAMS_NUM] = { { 0 } };
+
+    if (cbHook == 0x0) {
+        LOGE("Invalid call back hook");
+        return;
+    }
+
+    uint32_t len = 0;
+    ReadUint32(data, &len); /* skip flat object length information */
+    for (i = 0; i < MAX_REQUEST_PARAMS_NUM; i++) {
+        ret = DecodeIpcData((uintptr_t)(data), &(cbDataCache[i].type),
+            &(cbDataCache[i].val), &(cbDataCache[i].valSz));
+        if (ret != HC_SUCCESS) {
+            LOGE("decode failed, ret %d", ret);
+            return;
+        }
+    }
+    ProcCbHook(callbackId, cbHook, cbDataCache, MAX_REQUEST_PARAMS_NUM, (uintptr_t)(reply));
+    return;
+}
+
+int32_t CbStubOnRemoteRequest(uint32_t code, IpcIo *data, IpcIo *reply, MessageOption option)
+{
+    int32_t callbackId;
+    uintptr_t cbHook = 0x0;
+
+    LOGI("enter invoking callback...");
+    if (data == NULL) {
+        LOGE("invalid param");
+        return -1;
+    }
+
+    LOGI("receive ipc transact code(%u)", code);
+    switch (code) {
+        case DEV_AUTH_CALLBACK_REQUEST:
+            ReadInt32(data, &callbackId);
+            cbHook = ReadPointer(data);
+            DoCallBack(callbackId, cbHook, data, reply);
+            break;
+        default:
+            LOGE("Invoke callback cmd code(%u) error", code);
+            break;
+    }
+    LOGI("Invoke callback done, result(%d)", HC_SUCCESS);
+    return HC_SUCCESS;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -Naru deviceauth/frameworks/src/lite/ipc_dev_auth_proxy.c deviceauth_new/frameworks/src/lite/ipc_dev_auth_proxy.c
--- deviceauth/frameworks/src/lite/ipc_dev_auth_proxy.c	2025-02-12 16:28:21.433584300 +0800
+++ deviceauth_new/frameworks/src/lite/ipc_dev_auth_proxy.c	2025-02-12 15:01:27.826543400 +0800
@@ -18,7 +18,7 @@
 #include "common_defs.h"
 #include "device_auth_defines.h"
 #include "hc_log.h"
-#include "liteipc_adapter.h"
+#include "ipc_skeleton.h"
 #include "ipc_adapt.h"
 #include "ipc_sdk.h"
 #include "securec.h"
@@ -51,11 +51,11 @@
     IpcIo *ioPtr = NULL;
     LOGI("type %d, paramSz %d", type, paramSz);
     ioPtr = dataCtx->tmpData;
-    IpcIoPushInt32(ioPtr, type);
-    IpcIoPushFlatObj(ioPtr, param, paramSz);
-    if (!IpcIoAvailable(ioPtr)) {
-        LOGE("request data serialized failed");
-        return HC_ERROR;
+    WriteInt32(ioPtr, type);
+    WriteUint32(ioPtr, paramSz);
+    bool ret = WriteBuffer(ioPtr, param, paramSz);
+    if (!ret) {
+        return HC_FALSE;
     }
     dataCtx->paramCnt++;
     return HC_SUCCESS;
@@ -75,12 +75,16 @@
     LOGI("method id %d, param num %d, data length %d, flag %u, io offset %d",
         methodId, dataCtx->paramCnt, dataLen, ioPtr->flag, dataCtx->ioBuffOffset);
     /* request data length = number of params + params information */
-    IpcIoPushInt32(ioPtr, methodId);
-    IpcIoPushInt32(ioPtr, dataLen + sizeof(int32_t));
-    IpcIoPushInt32(ioPtr, dataCtx->paramCnt);
-    IpcIoPushFlatObj(ioPtr, (const uint8_t *)(dataCtx->tmpData->bufferBase + dataCtx->ioBuffOffset), dataLen);
+    WriteInt32(ioPtr, methodId);
+    WriteInt32(ioPtr, dataLen + sizeof(int32_t));
+    WriteInt32(ioPtr, dataCtx->paramCnt);
+    WriteUint32(ioPtr, dataLen);
+    bool ret = WriteBuffer(ioPtr, (const uint8_t *)(dataCtx->tmpData->bufferBase + dataCtx->ioBuffOffset), dataLen);
+    if (!ret) {
+        return HC_FALSE;
+    }
     if (dataCtx->withCallback) {
-        SvcIdentity badSvc = {0};
+        SvcIdentity badSvc = { 0 };
         ShowIpcSvcInfo(&(dataCtx->cbSvc));
         if ((sizeof(dataCtx->cbSvc) != sizeof(badSvc)) ||
             !memcmp(&(dataCtx->cbSvc), &badSvc, sizeof(badSvc))) {
@@ -88,15 +92,13 @@
             dataCtx->withCallback = false;
             return HC_ERROR;
         }
-        IpcIoPushInt32(ioPtr, PARAM_TYPE_CB_OBJECT);
-        IpcIoPushSvc(ioPtr, &(dataCtx->cbSvc));
+        WriteInt32(ioPtr, PARAM_TYPE_CB_OBJECT);
+        if (!WriteRemoteObject(ioPtr, &(dataCtx->cbSvc))) {
+            return HC_FALSE;
+        }
         LOGI("ipc call with callback, data flag %u", ioPtr->flag);
     }
     dataCtx->withCallback = false;
-    if (!IpcIoAvailable(ioPtr)) {
-        LOGE("request data serialized failed");
-        return HC_ERROR;
-    }
     return HC_SUCCESS;
 }
 
@@ -110,10 +112,6 @@
         LOGE("invalid params");
         return -1;
     }
-    if (!IpcIoAvailable(reply)) {
-        LOGE("invalid reply data");
-        return -1;
-    }
     dstReply = (IpcIo *)owner;
     eno = memcpy_s(dstReply->bufferCur, dstReply->bufferLeft, reply->bufferCur, reply->bufferLeft);
     if (eno != EOK) {
@@ -140,10 +138,8 @@
         dataCtx->data, (IOwner)(dataCtx->reply), CliInvokeRetCallback);
     LOGI("invoke call done, ipc result(%d)", ipcRet);
     ret = HC_ERROR;
-    if (IpcIoAvailable(dataCtx->reply)) {
-        ret = IpcIoPopInt32(dataCtx->reply);
-        LOGI("service call result(%d)", ret);
-    }
+    ReadInt32(dataCtx->reply, &ret);
+    LOGI("service call result(%d)", ret);
     return ((ipcRet == 0) && (ret == HC_SUCCESS)) ? HC_SUCCESS : HC_ERR_IPC_INTERNAL_FAILED;
 }
 
diff -Naru deviceauth/frameworks/src/lite/ipc_dev_auth_stub.c deviceauth_new/frameworks/src/lite/ipc_dev_auth_stub.c
--- deviceauth/frameworks/src/lite/ipc_dev_auth_stub.c	2025-02-12 16:28:21.470783200 +0800
+++ deviceauth_new/frameworks/src/lite/ipc_dev_auth_stub.c	2025-02-12 15:01:27.826543400 +0800
@@ -20,7 +20,7 @@
 #include "hc_log.h"
 #include "hc_mutex.h"
 #include "hc_types.h"
-#include "liteipc_adapter.h"
+#include "ipc_skeleton.h"
 #include "ipc_adapt.h"
 #include "ipc_callback_proxy.h"
 #include "ipc_sdk.h"
@@ -47,30 +47,7 @@
 #define BINDER_TYPE_ACQUIRE_AND_FREE 2
 #define BINDER_TYPE_RELEASE 3
 
-#define IPC_IO_BUFF_SZ 256
-
-static int32_t BinderLiteProcess(SvcIdentity **svc, int32_t procType)
-{
-    int32_t ret = 0;
-#ifdef __LINUX__
-    switch (procType) {
-        case BINDER_TYPE_ACQUIRE:
-            ret = BinderAcquire((*svc)->ipcContext, (*svc)->handle);
-            break;
-        case BINDER_TYPE_ACQUIRE_AND_FREE:
-            ret = BinderAcquire((*svc)->ipcContext, (*svc)->handle);
-            HcFree((void *)(*svc));
-            *svc = NULL;
-            break;
-        case BINDER_TYPE_RELEASE:
-            (void)BinderRelease((*svc)->ipcContext, (*svc)->handle);
-            break;
-        default:
-            LOGW("internal error: unknow processing type");
-    }
-#endif
-    return (ret == 0) ? HC_SUCCESS : HC_ERROR;
-}
+#define IPC_IO_BUFF_SZ 1024
 
 void ResetCallMap(void)
 {
@@ -104,19 +81,20 @@
     int32_t i;
     int32_t ret;
 
-    dataLen = IpcIoPopInt32(data);
+    ReadInt32(data, &dataLen);
     if (dataLen <= 0) {
         return HC_ERR_IPC_BAD_MESSAGE_LENGTH;
     }
 
-    *inParamNum = IpcIoPopInt32(data);
+    ReadInt32(data, inParamNum);
     if ((*inParamNum < 0) || (*inParamNum > cacheNum)) {
         LOGE("param number invalid, inParamNum(%d)", *inParamNum);
         return HC_ERR_IPC_BAD_PARAM_NUM;
     }
     LOGI("request data length(%d), param number: %d", dataLen - sizeof(int32_t), *inParamNum);
 
-    (void)IpcIoPopUint32(data); /* skip flat object length information */
+    uint32_t len = 0;
+    ReadUint32(data, &len); /* skip flat object length information */
     for (i = 0; i < *inParamNum; i++) {
         ret = DecodeIpcData((uintptr_t)data, &(paramsCache[i].type), &(paramsCache[i].val), &(paramsCache[i].valSz));
         if (ret != HC_SUCCESS) {
@@ -130,33 +108,31 @@
 
 static int32_t GetMethodId(IpcIo *data, int32_t *methodId)
 {
-    *methodId = IpcIoPopInt32(data);
+    ReadInt32(data, methodId);
     LOGI("GetMethodId, id code %d", *methodId);
     return HC_SUCCESS;
 }
 
 static void WithObject(int32_t methodId, IpcIo *data, IpcDataInfo *ipcData, int32_t *cnt)
 {
-    if (IsCallbackMethod(methodId)) {
-        ipcData->type = IpcIoPopInt32(data);
-        ipcData->valSz = 0;
-        SvcIdentity *tmp = IpcIoPopSvc(data);
-        if (!tmp || (ipcData->type != PARAM_TYPE_CB_OBJECT)) {
-            LOGE("should with remote object, but failed, param type %d", ipcData->type);
-            return;
-        }
-        ShowIpcSvcInfo(tmp);
-        ipcData->idx = SetRemoteObject(tmp);
-        if (ipcData->idx >= 0) {
-            if (BinderLiteProcess(&tmp, BINDER_TYPE_ACQUIRE_AND_FREE) == HC_SUCCESS) {
-                ipcData->val = (uint8_t *)(&(ipcData->idx));
-                LOGI("object trans success, set id %d", ipcData->idx);
-                (*cnt)++;
-            }
-        }
-        tmp = NULL;
+    if (!IsCallbackMethod(methodId)) {
+        return;
+    }
+    ReadInt32(data, &(ipcData->type));
+    ipcData->valSz = 0;
+    SvcIdentity tmp;
+    bool ret = ReadRemoteObject(data, &tmp);
+    if (!ret || (ipcData->type != PARAM_TYPE_CB_OBJECT)) {
+        LOGE("should with remote object, but failed, param type %d", ipcData->type);
+        return;
+    }
+    ShowIpcSvcInfo(&tmp);
+    ipcData->idx = SetRemoteObject(&tmp);
+    if (ipcData->idx >= 0) {
+        ipcData->val = (uint8_t *)(&(ipcData->idx));
+        LOGI("object trans success, set id %d", ipcData->idx);
+        (*cnt)++;
     }
-    return;
 }
 
 void InitCbStubTable()
@@ -183,7 +159,7 @@
     int32_t ret;
     int32_t methodId = -1;
     int32_t reqParamNum = 0;
-    IpcDataInfo reqParams[MAX_REQUEST_PARAMS_NUM] = {{0}};
+    IpcDataInfo reqParams[MAX_REQUEST_PARAMS_NUM] = { { 0 } };
     IpcServiceCall serviceCall = NULL;
 
     (void)origin;
@@ -214,13 +190,13 @@
     {DevAuthRequestCall, DEV_AUTH_CALL_REQUEST},
 };
 
-int32_t OnRemoteRequest(IServerProxy *iProxy, int32_t reqId, void *origin, IpcIo *req, IpcIo *reply)
+int32_t OnRemoteInvoke(IServerProxy *iProxy, int32_t reqId, void *origin, IpcIo *req, IpcIo *reply)
 {
     int32_t i;
     int32_t n;
     int32_t (*callCtx)(void *origin, IpcIo *req, IpcIo *reply) = NULL;
     IpcIo replyTmp;
-    uint8_t dataBuff[IPC_IO_BUFF_SZ] = {0};
+    uint8_t dataBuff[IPC_IO_BUFF_SZ] = { 0 };
     int32_t ret = HC_ERR_IPC_UNKNOW_OPCODE;
 
     (void)origin;
@@ -238,11 +214,15 @@
     if (callCtx) {
         ret = callCtx(origin, req, &replyTmp);
     }
-    IpcIoPushInt32(reply, ret);
+    WriteInt32(reply, ret);
     if (reply != NULL) {
         n = GetIpcIoDataLength(&replyTmp);
         if (n > 0) {
-            IpcIoPushFlatObj(reply, (const void *)(replyTmp.bufferBase + IpcIoBufferOffset()), n);
+            WriteUint32(reply, n);
+            if (!WriteBuffer(reply, (const void *)(replyTmp.bufferBase + IpcIoBufferOffset()), n)) {
+                LOGI("WriteBuffer faild");
+                return HC_ERROR;
+            }
             LOGI("form service result done, result length(%d)", n);
         }
     }
@@ -253,7 +233,6 @@
 int32_t SetCallMap(IpcServiceCall method, int32_t methodId)
 {
     int32_t len;
-    errno_t eno;
     IpcServiceCallMap *callMapTmp = NULL;
 
     if ((1 + g_callMapElemNum) > g_maxCallMapSz) {
@@ -271,7 +250,7 @@
         }
         (void)memset_s(g_callMapTable, len, 0, len);
         if (callMapTmp != NULL) {
-            eno = memcpy_s(g_callMapTable, len, callMapTmp, (sizeof(IpcServiceCallMap) * g_callMapElemNum));
+            errno_t eno = memcpy_s(g_callMapTable, len, callMapTmp, (sizeof(IpcServiceCallMap) * g_callMapElemNum));
             if (eno != EOK) {
                 HcFree((void *)g_callMapTable);
                 g_callMapTable = callMapTmp;
@@ -313,34 +292,33 @@
     return idx;
 }
 
-static int32_t ClientDeathCallback(const IpcContext *context, void *ipcMsg, IpcIo *data, void *arg)
+static void ClientDeathCallback(void *arg)
 {
     int32_t callbackIdx = (int32_t)arg;
 
     LOGI("remote is not actively, to reset local resource");
     ResetIpcCallBackNodeByNodeId(callbackIdx);
-    return 0;
 }
 
-void AddCbDeathRecipient(int32_t objIdx, int32_t cbDataIdx)
+void AddCbDeathRecipient(int32_t cbStubIdx, int32_t cbDataIdx)
 {
     int32_t ret;
     uint32_t cbId = 0;
-    if ((objIdx < 0) || (objIdx >= MAX_CBSTUB_SIZE)) {
+    if ((cbStubIdx < 0) || (cbStubIdx >= MAX_CBSTUB_SIZE)) {
         return;
     }
 
     LockCbStubTable();
-    if (!g_cbStub[objIdx].inUse) {
+    if (!g_cbStub[cbStubIdx].inUse) {
         UnLockCbStubTable();
         return;
     }
-    ret = RegisterDeathCallback(NULL, g_cbStub[objIdx].cbStub, ClientDeathCallback, (void *)cbDataIdx, &cbId);
+    ret = AddDeathRecipient(g_cbStub[cbStubIdx].cbStub, ClientDeathCallback, (void *)cbDataIdx, &cbId);
     if (ret == 0) {
-        g_cbStub[objIdx].cbDieId = cbId;
+        g_cbStub[cbStubIdx].cbDieId = cbId;
     }
     UnLockCbStubTable();
-    LOGI("done, ret %d, callback stub idx %d", ret, objIdx);
+    LOGI("done, ret %d, callback stub idx %d", ret, cbStubIdx);
     return;
 }
 
@@ -353,9 +331,7 @@
             UnLockCbStubTable();
             return;
         }
-        UnregisterDeathCallback(g_cbStub[idx].cbStub, g_cbStub[idx].cbDieId);
-        SvcIdentity *tmpStub = &g_cbStub[idx].cbStub;
-        (void)BinderLiteProcess(&tmpStub, BINDER_TYPE_RELEASE);
+        RemoveDeathRecipient(g_cbStub[idx].cbStub, g_cbStub[idx].cbDieId);
         (void)memset_s(&(g_cbStub[idx].cbStub), sizeof(g_cbStub[idx].cbStub), 0, sizeof(g_cbStub[idx].cbStub));
         g_cbStub[idx].inUse = false;
         UnLockCbStubTable();
diff -Naru deviceauth/frameworks/src/lite/ipc_service_init.c deviceauth_new/frameworks/src/lite/ipc_service_init.c
--- deviceauth/frameworks/src/lite/ipc_service_init.c	2025-02-12 16:28:21.512448600 +0800
+++ deviceauth_new/frameworks/src/lite/ipc_service_init.c	2025-02-12 15:01:27.826543400 +0800
@@ -1,30 +1,30 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ipc_service_init.h"
 
-#include "ipc_service_init.h"
-
-#include "device_auth_defines.h"
+#include "device_auth_defines.h"
 #include "hc_log.h"
-#include "ipc_dev_auth_stub.h"
-#include "liteipc_adapter.h"
-#include "ohos_init.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
+#include "ipc_dev_auth_stub.h"
+#include "ipc_skeleton.h"
+#include "ohos_init.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 static const char *GetName(Service *service)
 {
     (void)service;
@@ -59,20 +59,20 @@
     (void)service;
     TaskConfig config = { LEVEL_HIGH, PRI_BELOW_NORMAL, stackSz, queSize, SHARED_TASK };
     return config;
-}
-
+}
+
 void ServiceInit(void)
 {
-    static DevAuthService service = {
+    static DevAuthService service = {
         .GetName = GetName,
         .Initialize = Initialize,
         .MessageHandle = MessageHandle,
         .GetTaskConfig = GetTaskConfig,
         SERVER_IPROXY_IMPL_BEGIN,
-        .Invoke = OnRemoteRequest,
+        .Invoke = OnRemoteInvoke,
         IPROXY_END,
-    };
-
+    };
+
 #ifdef __LINUX__
     sleep(1); /* delay 1 second on boot */
 #endif
@@ -86,10 +86,10 @@
     }
     LOGI("%s, init success", DEV_AUTH_SERVICE_NAME);
     return;
-}
-SYS_SERVICE_INIT(ServiceInit);
-
-#ifdef __cplusplus
-}
-#endif
-
+}
+SYS_SERVICE_INIT(ServiceInit);
+
+#ifdef __cplusplus
+}
+#endif
+
diff -Naru deviceauth/frameworks/src/standard/ipc_adapt.cpp deviceauth_new/frameworks/src/standard/ipc_adapt.cpp
--- deviceauth/frameworks/src/standard/ipc_adapt.cpp	2025-02-12 16:28:21.613631100 +0800
+++ deviceauth_new/frameworks/src/standard/ipc_adapt.cpp	2025-02-12 15:01:27.826543400 +0800
@@ -1348,7 +1348,6 @@
     ret = sysMgr->AddSystemAbility(DEVICE_AUTH_SERVICE_ID, sPtr);
     if (ret != ERR_OK) {
         LOGE("add service failed");
-        delete sPtr;
         return HC_ERROR;
     }
     *serviceCtx = reinterpret_cast<uintptr_t>(sPtr);
diff -Naru deviceauth/hals/BUILD.gn deviceauth_new/hals/BUILD.gn
--- deviceauth/hals/BUILD.gn	2025-02-12 16:28:21.823936600 +0800
+++ deviceauth_new/hals/BUILD.gn	2025-02-12 15:01:27.826543400 +0800
@@ -65,7 +65,6 @@
         "//base/security/huks/interfaces/innerkits/huks_standard/main/include",
         "//base/hiviewdfx/hilog_lite/interfaces/native/innerkits/hilog",
         "//third_party/bounds_checking_function/include",
-        "//base/startup/syspara_lite/interfaces/kits/",
       ]
 
       sources = hal_common_files
@@ -88,7 +87,6 @@
       deps = [
         "//base/hiviewdfx/hilog_lite/frameworks/featured:hilog_shared",
         "//base/security/huks/interfaces/innerkits/huks_lite:huks_3.0_sdk",
-        "//base/startup/syspara_lite/frameworks/parameter/src:sysparam",
         "//build/lite/config/component/cJSON:cjson_shared",
         "//build/lite/config/component/openssl:openssl_shared",
         "//third_party/bounds_checking_function:libsec_shared",
diff -Naru deviceauth/hals/deviceauth_hals.gni deviceauth_new/hals/deviceauth_hals.gni
--- deviceauth/hals/deviceauth_hals.gni	2025-02-12 16:28:21.853697200 +0800
+++ deviceauth_new/hals/deviceauth_hals.gni	2025-02-12 15:01:27.826543400 +0800
@@ -9,7 +9,7 @@
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
-# limitations under the License.
+# limitations under the License.
 
 import("//base/security/deviceauth/deviceauth_env.gni")
 
diff -Naru deviceauth/hals/inc/common/common_util.h deviceauth_new/hals/inc/common/common_util.h
--- deviceauth/hals/inc/common/common_util.h	2025-02-12 16:28:21.964801600 +0800
+++ deviceauth_new/hals/inc/common/common_util.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,64 +1,64 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef COMMON_UTIL_H
-#define COMMON_UTIL_H
-
-#include <stdint.h>
-#include "hc_error.h"
-
-#define BYTE_TO_HEX_OPER_LENGTH 2
-#define DEC 10
-
-typedef struct {
-    uint8_t *val;
-    uint32_t length;
-} Uint8Buff;
-
-/*
- * Convert hex string to byte.
- * @param hexStr: hex string
- * @param byte: the converted result, need malloc by caller
- * @param byteLen: the length of byte
- * @result success(0), otherwise, failure.
- */
-int32_t HexStringToByte(const char *hexStr, uint8_t *byte, uint32_t byteLen);
-
-/*
- * Convert byte to hex string.
- * @param byte: byte to be converted
- * @param byteLen: the length of byte
- * @param hexStr: the converted result, need malloc by caller, and need malloc for '\0'
- * @param hexLen: strlen(hexStr) + 1, for '\0'
- * @result success(0), otherwise, failure.
- */
-int32_t ByteToHexString(const uint8_t *byte, uint32_t byteLen, char *hexStr, uint32_t hexLen);
-
-
-/*
- * Convert string to int64_t.
- * @param cp: string to be converted
- * @return the converted result.
- */
-int64_t StringToInt64(const char *cp);
-
-/*
- * Convert string to anonymous string.
- * @param originalStr: string to be converted
- * @param anonymousStr: the converted result
- */
-void ConvertToAnnoymousStr(const char *originalStr, char **anonymousStr);
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef COMMON_UTIL_H
+#define COMMON_UTIL_H
+
+#include <stdint.h>
+#include "hc_error.h"
+
+#define BYTE_TO_HEX_OPER_LENGTH 2
+#define DEC 10
+
+typedef struct {
+    uint8_t *val;
+    uint32_t length;
+} Uint8Buff;
+
+/*
+ * Convert hex string to byte.
+ * @param hexStr: hex string
+ * @param byte: the converted result, need malloc by caller
+ * @param byteLen: the length of byte
+ * @result success(0), otherwise, failure.
+ */
+int32_t HexStringToByte(const char *hexStr, uint8_t *byte, uint32_t byteLen);
+
+/*
+ * Convert byte to hex string.
+ * @param byte: byte to be converted
+ * @param byteLen: the length of byte
+ * @param hexStr: the converted result, need malloc by caller, and need malloc for '\0'
+ * @param hexLen: strlen(hexStr) + 1, for '\0'
+ * @result success(0), otherwise, failure.
+ */
+int32_t ByteToHexString(const uint8_t *byte, uint32_t byteLen, char *hexStr, uint32_t hexLen);
+
+
+/*
+ * Convert string to int64_t.
+ * @param cp: string to be converted
+ * @return the converted result.
+ */
+int64_t StringToInt64(const char *cp);
+
+/*
+ * Convert string to anonymous string.
+ * @param originalStr: string to be converted
+ * @param anonymousStr: the converted result
+ */
+void ConvertToAnnoymousStr(const char *originalStr, char **anonymousStr);
+
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/common/hc_error.h deviceauth_new/hals/inc/common/hc_error.h
--- deviceauth/hals/inc/common/hc_error.h	2025-02-12 16:28:22.006465600 +0800
+++ deviceauth_new/hals/inc/common/hc_error.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,45 +1,45 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_ERROR_H
-#define HC_ERROR_H
-
-enum {
-    HAL_SUCCESS = 0,
-    HAL_FAILED = -1,
-    HAL_ERR_INVALID_PARAM = -2,
-    HAL_ERR_INVALID_LEN = -3,
-    HAL_ERR_BAD_ALLOC = -4,
-    HAL_ERR_NULL_PTR = -5,
-    HAL_ERR_MEMORY_COPY = -6,
-
-    HAL_ERR_FILE_NOT_EXIST = -7,
-    HAL_ERR_FILE = -8,
-
-    HAL_ERR_JSON_FAILED = -9,
-    HAL_ERR_JSON_GET = -10,
-    HAL_ERR_JSON_ADD = -11,
-    HAL_ERR_JSON_REPLACE = -12,
-    HAL_ERR_JSON_DUPLICATE = -13,
-
-    HAL_ERR_INIT_PARAM_SET_FAILED = -14,
-    HAL_ERR_ADD_PARAM_FAILED = -15,
-    HAL_ERR_GET_PARAM_FAILED = -16,
-    HAL_ERR_BUILD_PARAM_SET_FAILED = -17,
-    HAL_ERR_FRESH_PARAM_SET_FAILED = -18,
-    HAL_ERR_INIT_FAILED = -19,
-};
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_ERROR_H
+#define HC_ERROR_H
+
+enum {
+    HAL_SUCCESS = 0,
+    HAL_FAILED = -1,
+    HAL_ERR_INVALID_PARAM = -2,
+    HAL_ERR_INVALID_LEN = -3,
+    HAL_ERR_BAD_ALLOC = -4,
+    HAL_ERR_NULL_PTR = -5,
+    HAL_ERR_MEMORY_COPY = -6,
+
+    HAL_ERR_FILE_NOT_EXIST = -7,
+    HAL_ERR_FILE = -8,
+
+    HAL_ERR_JSON_FAILED = -9,
+    HAL_ERR_JSON_GET = -10,
+    HAL_ERR_JSON_ADD = -11,
+    HAL_ERR_JSON_REPLACE = -12,
+    HAL_ERR_JSON_DUPLICATE = -13,
+
+    HAL_ERR_INIT_PARAM_SET_FAILED = -14,
+    HAL_ERR_ADD_PARAM_FAILED = -15,
+    HAL_ERR_GET_PARAM_FAILED = -16,
+    HAL_ERR_BUILD_PARAM_SET_FAILED = -17,
+    HAL_ERR_FRESH_PARAM_SET_FAILED = -18,
+    HAL_ERR_INIT_FAILED = -19,
+};
+
+#endif
diff -Naru deviceauth/hals/inc/common/hc_parcel.h deviceauth_new/hals/inc/common/hc_parcel.h
--- deviceauth/hals/inc/common/hc_parcel.h	2025-02-12 16:28:22.052594200 +0800
+++ deviceauth_new/hals/inc/common/hc_parcel.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,88 +1,88 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_PARCEL_H
-#define HC_PARCEL_H
-
-#include "hc_types.h"
-
-#define PARCEL_DEFAULT_LENGTH 0
-#define PARCEL_DEFAULT_ALLOC_UNIT 0
-
-typedef struct {
-    char *data;
-    unsigned int beginPos;
-    unsigned int endPos;
-    unsigned int length;
-    unsigned int allocUnit;
-} HcParcel;
-
-HcParcel CreateParcel(uint32_t size, uint32_t allocUnit);
-void DeleteParcel(HcParcel *parcel);
-void ClearParcel(HcParcel *parcel);
-void ResetParcel(HcParcel *parcel, uint32_t size, uint32_t allocUnit);
-HcBool ParcelReadWithoutPopData(HcParcel *parcel, void *dst, uint32_t dataSize);
-HcBool ParcelRead(HcParcel *parcel, void *dst, uint32_t dataSize);
-HcBool ParcelWrite(HcParcel *parcel, const void *src, uint32_t dataSize);
-HcBool ParcelReadRevert(HcParcel *parcel, void *dst, uint32_t dataSize);
-HcBool ParcelWriteRevert(HcParcel *parcel, const void *src, uint32_t dataSize);
-uint32_t GetParcelDataSize(const HcParcel *parcel);
-const char *GetParcelData(const HcParcel *parcel);
-const char* GetParcelLastChar(const HcParcel *parcel);
-
-HcBool ParcelReadInt32(HcParcel *parcel, int *dst);
-HcBool ParcelReadUint32(HcParcel *parcel, uint32_t *dst);
-HcBool ParcelReadInt16(HcParcel *parcel, short *dst);
-HcBool ParcelReadUint16(HcParcel *parcel, uint16_t *dst);
-HcBool ParcelReadInt8(HcParcel *parcel, char *dst);
-HcBool ParcelReadUint8(HcParcel *parcel, uint8_t *dst);
-HcBool ParcelReadUint64(HcParcel *parcel, uint64_t *dst);
-HcBool ParcelReadInt64(HcParcel *parcel, int64_t *dst);
-HcBool ParcelWriteInt32(HcParcel *parcel, int src);
-HcBool ParcelWriteUint32(HcParcel *parcel, uint32_t src);
-HcBool ParcelWriteInt16(HcParcel *parcel, short src);
-HcBool ParcelWriteUint16(HcParcel *parcel, uint16_t src);
-HcBool ParcelWriteInt8(HcParcel *parcel, char src);
-HcBool ParcelWriteUint8(HcParcel *parcel, uint8_t src);
-HcBool ParcelWriteUint64(HcParcel *parcel, uint64_t src);
-HcBool ParcelWriteInt64(HcParcel *parcel, int64_t src);
-HcBool ParcelWriteString(HcParcel *parcel, const char *str);
-HcBool ParcelReadString(HcParcel *parcel, char **str);
-HcBool ParcelReadParcel(HcParcel *src, HcParcel *dst, uint32_t size, HcBool copy);
-HcBool ParcelCopy(HcParcel *src, HcParcel *dst);
-
-HcBool ParcelReadInt32Revert(HcParcel *parcel, int32_t *dst);
-HcBool ParcelReadUint32Revert(HcParcel *parcel, uint32_t *dst);
-HcBool ParcelReadInt16Revert(HcParcel *parcel, short *dst);
-HcBool ParcelReadUint16Revert(HcParcel *parcel, uint16_t *dst);
-HcBool ParcelReadInt8Revert(HcParcel *parcel, char *dst);
-HcBool ParcelReadUint8Revert(HcParcel *parcel, uint8_t *dst);
-HcBool ParcelReadUint64Revert(HcParcel *parcel, uint64_t *dst);
-HcBool ParcelReadInt64Revert(HcParcel *parcel, int64_t *dst);
-HcBool ParcelWriteInt32Revert(HcParcel *parcel, int src);
-HcBool ParcelWriteUint32Revert(HcParcel *parcel, uint32_t src);
-HcBool ParcelWriteInt16Revert(HcParcel *parcel, short src);
-HcBool ParcelWriteUint16Revert(HcParcel *parcel, uint16_t src);
-HcBool ParcelWriteInt8Revert(HcParcel *parcel, char src);
-HcBool ParcelWriteUint8Revert(HcParcel *parcel, uint8_t src);
-HcBool ParcelWriteUint64Revert(HcParcel *parcel, uint64_t src);
-HcBool ParcelWriteInt64Revert(HcParcel *parcel, int64_t src);
-
-void DataRevert(void *data, uint32_t length);
-HcBool ParcelPopBack(HcParcel *parcel, uint32_t size);
-HcBool ParcelPopFront(HcParcel *parcel, uint32_t size);
-HcBool ParcelEraseBlock(HcParcel *parcel, uint32_t start, uint32_t data_size, void *dst);
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_PARCEL_H
+#define HC_PARCEL_H
+
+#include "hc_types.h"
+
+#define PARCEL_DEFAULT_LENGTH 0
+#define PARCEL_DEFAULT_ALLOC_UNIT 0
+
+typedef struct {
+    char *data;
+    unsigned int beginPos;
+    unsigned int endPos;
+    unsigned int length;
+    unsigned int allocUnit;
+} HcParcel;
+
+HcParcel CreateParcel(uint32_t size, uint32_t allocUnit);
+void DeleteParcel(HcParcel *parcel);
+void ClearParcel(HcParcel *parcel);
+void ResetParcel(HcParcel *parcel, uint32_t size, uint32_t allocUnit);
+HcBool ParcelReadWithoutPopData(HcParcel *parcel, void *dst, uint32_t dataSize);
+HcBool ParcelRead(HcParcel *parcel, void *dst, uint32_t dataSize);
+HcBool ParcelWrite(HcParcel *parcel, const void *src, uint32_t dataSize);
+HcBool ParcelReadRevert(HcParcel *parcel, void *dst, uint32_t dataSize);
+HcBool ParcelWriteRevert(HcParcel *parcel, const void *src, uint32_t dataSize);
+uint32_t GetParcelDataSize(const HcParcel *parcel);
+const char *GetParcelData(const HcParcel *parcel);
+const char* GetParcelLastChar(const HcParcel *parcel);
+
+HcBool ParcelReadInt32(HcParcel *parcel, int *dst);
+HcBool ParcelReadUint32(HcParcel *parcel, uint32_t *dst);
+HcBool ParcelReadInt16(HcParcel *parcel, short *dst);
+HcBool ParcelReadUint16(HcParcel *parcel, uint16_t *dst);
+HcBool ParcelReadInt8(HcParcel *parcel, char *dst);
+HcBool ParcelReadUint8(HcParcel *parcel, uint8_t *dst);
+HcBool ParcelReadUint64(HcParcel *parcel, uint64_t *dst);
+HcBool ParcelReadInt64(HcParcel *parcel, int64_t *dst);
+HcBool ParcelWriteInt32(HcParcel *parcel, int src);
+HcBool ParcelWriteUint32(HcParcel *parcel, uint32_t src);
+HcBool ParcelWriteInt16(HcParcel *parcel, short src);
+HcBool ParcelWriteUint16(HcParcel *parcel, uint16_t src);
+HcBool ParcelWriteInt8(HcParcel *parcel, char src);
+HcBool ParcelWriteUint8(HcParcel *parcel, uint8_t src);
+HcBool ParcelWriteUint64(HcParcel *parcel, uint64_t src);
+HcBool ParcelWriteInt64(HcParcel *parcel, int64_t src);
+HcBool ParcelWriteString(HcParcel *parcel, const char *str);
+HcBool ParcelReadString(HcParcel *parcel, char **str);
+HcBool ParcelReadParcel(HcParcel *src, HcParcel *dst, uint32_t size, HcBool copy);
+HcBool ParcelCopy(HcParcel *src, HcParcel *dst);
+
+HcBool ParcelReadInt32Revert(HcParcel *parcel, int32_t *dst);
+HcBool ParcelReadUint32Revert(HcParcel *parcel, uint32_t *dst);
+HcBool ParcelReadInt16Revert(HcParcel *parcel, short *dst);
+HcBool ParcelReadUint16Revert(HcParcel *parcel, uint16_t *dst);
+HcBool ParcelReadInt8Revert(HcParcel *parcel, char *dst);
+HcBool ParcelReadUint8Revert(HcParcel *parcel, uint8_t *dst);
+HcBool ParcelReadUint64Revert(HcParcel *parcel, uint64_t *dst);
+HcBool ParcelReadInt64Revert(HcParcel *parcel, int64_t *dst);
+HcBool ParcelWriteInt32Revert(HcParcel *parcel, int src);
+HcBool ParcelWriteUint32Revert(HcParcel *parcel, uint32_t src);
+HcBool ParcelWriteInt16Revert(HcParcel *parcel, short src);
+HcBool ParcelWriteUint16Revert(HcParcel *parcel, uint16_t src);
+HcBool ParcelWriteInt8Revert(HcParcel *parcel, char src);
+HcBool ParcelWriteUint8Revert(HcParcel *parcel, uint8_t src);
+HcBool ParcelWriteUint64Revert(HcParcel *parcel, uint64_t src);
+HcBool ParcelWriteInt64Revert(HcParcel *parcel, int64_t src);
+
+void DataRevert(void *data, uint32_t length);
+HcBool ParcelPopBack(HcParcel *parcel, uint32_t size);
+HcBool ParcelPopFront(HcParcel *parcel, uint32_t size);
+HcBool ParcelEraseBlock(HcParcel *parcel, uint32_t start, uint32_t data_size, void *dst);
+
+#endif
diff -Naru deviceauth/hals/inc/common/hc_string.h deviceauth_new/hals/inc/common/hc_string.h
--- deviceauth/hals/inc/common/hc_string.h	2025-02-12 16:28:22.084338100 +0800
+++ deviceauth_new/hals/inc/common/hc_string.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,100 +1,100 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_STRING_H
-#define HC_STRING_H
-
-#include "hc_parcel.h"
-
-typedef struct HcString {
-    HcParcel parcel; // parcel data, used to storage the string data
-} HcString;
-
-/*
- * Append a HcString
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: append string.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringAppend(HcString *self, HcString str);
-
-/*
- * Append string pointer
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: string pointer.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringAppendPointer(HcString *self, const char *str);
-
-/*
- * Append a char
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: char.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringAppendChar(HcString *self, char c);
-
-/*
- * Assign a value to the HcString
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: assign value of ta_sting.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringSet(HcString *self, HcString str);
-
-/*
- * Assign a value to the HcString
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: assign value of string pointer.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringSetPointer(HcString *self, const char *str);
-
-/*
- * Get the string pointer data
- * @param self: self pointer.
- * @return the pointer data of the string
- */
-const char* StringGet(const HcString *self);
-
-/*
- * Get the length of the string
- * @param self: self pointer.
- * @return the length of the string
- */
-uint32_t StringLength(const HcString *self);
-
-/*
- * Create a string.
- * Notice: You should delete string when you don't need the string anymore.
- * @return the created string.
- */
-HcString CreateString(void);
-
-/*
- * Delete a string. In fact it will not destroy the string,
- * but only free the allocated memory of the string and reset the member's value
- * of the string. You can continue to use the string if you want.
- * Notice: You should delete the string when you don't need it any more to avoid memory leak.
- * @param str: The string you want to delete.
- */
-void DeleteString(HcString *str);
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_STRING_H
+#define HC_STRING_H
+
+#include "hc_parcel.h"
+
+typedef struct HcString {
+    HcParcel parcel; // parcel data, used to storage the string data
+} HcString;
+
+/*
+ * Append a HcString
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: append string.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringAppend(HcString *self, HcString str);
+
+/*
+ * Append string pointer
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: string pointer.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringAppendPointer(HcString *self, const char *str);
+
+/*
+ * Append a char
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: char.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringAppendChar(HcString *self, char c);
+
+/*
+ * Assign a value to the HcString
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: assign value of ta_sting.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringSet(HcString *self, HcString str);
+
+/*
+ * Assign a value to the HcString
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: assign value of string pointer.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringSetPointer(HcString *self, const char *str);
+
+/*
+ * Get the string pointer data
+ * @param self: self pointer.
+ * @return the pointer data of the string
+ */
+const char* StringGet(const HcString *self);
+
+/*
+ * Get the length of the string
+ * @param self: self pointer.
+ * @return the length of the string
+ */
+uint32_t StringLength(const HcString *self);
+
+/*
+ * Create a string.
+ * Notice: You should delete string when you don't need the string anymore.
+ * @return the created string.
+ */
+HcString CreateString(void);
+
+/*
+ * Delete a string. In fact it will not destroy the string,
+ * but only free the allocated memory of the string and reset the member's value
+ * of the string. You can continue to use the string if you want.
+ * Notice: You should delete the string when you don't need it any more to avoid memory leak.
+ * @param str: The string you want to delete.
+ */
+void DeleteString(HcString *str);
+
+#endif
diff -Naru deviceauth/hals/inc/common/hc_task_thread.h deviceauth_new/hals/inc/common/hc_task_thread.h
--- deviceauth/hals/inc/common/hc_task_thread.h	2025-02-12 16:28:22.121536800 +0800
+++ deviceauth_new/hals/inc/common/hc_task_thread.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,46 +1,46 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_TASK_THREAD_H
-#define HC_TASK_THREAD_H
-
-#include "hc_thread.h"
-#include "hc_vector.h"
-
-typedef struct HcTaskBaseT {
-    void (*doAction) (struct HcTaskBaseT*);
-    void (*destroy) (struct HcTaskBaseT*);
-} HcTaskBase;
-
-typedef struct {
-    HcTaskBase* task;
-} HcTaskWrap;
-
-DECLARE_HC_VECTOR(TaskVec, HcTaskWrap)
-
-typedef struct HcTaskThreadT {
-    HcThread thread;
-    TaskVec tasks;
-    int32_t (*startThread)(struct HcTaskThreadT* thread);
-    void (*pushTask) (struct HcTaskThreadT* thread, HcTaskBase* task);
-    void (*clear) (struct HcTaskThreadT* thread);
-    void (*stopAndClear) (struct HcTaskThreadT* thread);
-    HcMutex queueLock;
-    HcBool quit;
-} HcTaskThread;
-
-int32_t InitHcTaskThread(HcTaskThread* thread, size_t stackSize, const char* threadName);
-void DestroyHcTaskThread(HcTaskThread* thread);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_TASK_THREAD_H
+#define HC_TASK_THREAD_H
+
+#include "hc_thread.h"
+#include "hc_vector.h"
+
+typedef struct HcTaskBaseT {
+    void (*doAction) (struct HcTaskBaseT*);
+    void (*destroy) (struct HcTaskBaseT*);
+} HcTaskBase;
+
+typedef struct {
+    HcTaskBase* task;
+} HcTaskWrap;
+
+DECLARE_HC_VECTOR(TaskVec, HcTaskWrap)
+
+typedef struct HcTaskThreadT {
+    HcThread thread;
+    TaskVec tasks;
+    int32_t (*startThread)(struct HcTaskThreadT* thread);
+    void (*pushTask) (struct HcTaskThreadT* thread, HcTaskBase* task);
+    void (*clear) (struct HcTaskThreadT* thread);
+    void (*stopAndClear) (struct HcTaskThreadT* thread);
+    HcMutex queueLock;
+    HcBool quit;
+} HcTaskThread;
+
+int32_t InitHcTaskThread(HcTaskThread* thread, size_t stackSize, const char* threadName);
+void DestroyHcTaskThread(HcTaskThread* thread);
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/common/hc_tlv_parser.h deviceauth_new/hals/inc/common/hc_tlv_parser.h
--- deviceauth/hals/inc/common/hc_tlv_parser.h	2025-02-12 16:28:22.159729200 +0800
+++ deviceauth_new/hals/inc/common/hc_tlv_parser.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,313 +1,313 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_TLV_PARSER_H
-#define HC_TLV_PARSER_H
-
-#include <hc_parcel.h>
-#include <hc_vector.h>
-#include <hc_string.h>
-
-#define USE_DEFAULT_TAG 0xFFFF
-#define TLV_FAIL (-1)
-#define NO_REVERT 0
-#define NEED_REVERT 1
-#define MAX_TOTOL_LEN (100 * 1024 * 1024)
-
-typedef struct TlvBaseT {
-    unsigned short tag;
-    unsigned short length;
-    unsigned short checkTag;
-    unsigned short hasValue;
-    int32_t (*parse)(struct TlvBaseT *, HcParcel *, HcBool);
-    int32_t (*getlen)(struct TlvBaseT *);
-    int32_t (*encode)(struct TlvBaseT *, HcParcel *);
-    void (*deinit)(struct TlvBaseT *);
-} TlvBase;
-
-#define DECLARE_TLV_STRUCT(x) \
-    TlvBase base; \
-    unsigned int offsetCount; \
-    unsigned int offset[x];
-
-unsigned short GetTag(unsigned short checkTag, unsigned short defaultTag);
-
-#define BEGIN_TLV_STRUCT_DEFINE(TlvS, CheckTag) \
-void Init##TlvS(TlvS *tlv, unsigned short checkTag) \
-{ \
-    typedef TlvS TlvStructType; \
-    unsigned int index = 0; \
-    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base)); \
-    tlv->base.checkTag = GetTag(checkTag, CheckTag);
-
-#define TLV_MEMBER_OPTION(TlvMember, TlvMemberName, CheckTag) \
-    Init##TlvMember(&tlv->TlvMemberName, CheckTag); \
-    tlv->TlvMemberName.base.option = 1; \
-    tlv->offset[index++] = offsetof(TlvStructType, TlvMemberName);
-
-#define TLV_MEMBER(TlvMember, TlvMemberName, CheckTag) \
-    Init##TlvMember(&tlv->TlvMemberName, CheckTag); \
-    tlv->offset[index++] = offsetof(TlvStructType, TlvMemberName);
-
-#define END_TLV_STRUCT_DEFINE(void) \
-    tlv->offsetCount = index; \
-    tlv->base.parse = ParseTlvStruct; \
-    tlv->base.getlen = GetLenTlvStruct; \
-    tlv->base.encode = EncodeTlvStruct; \
-    tlv->base.deinit = DeinitTlvStruct; \
-}
-
-#define DECLARE_TLV_FIX_LENGTH_TYPE(TlvName, TypeName) \
-typedef struct \
-{ \
-    TlvBase base; \
-    TypeName data; \
-} TlvName;
-
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt32, int)
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt16, short)
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt8, char)
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint32, uint32_t)
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint16, uint16_t)
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint8, uint8_t)
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint64, uint64_t)
-DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt64, uint64_t)
-
-#define DEFINE_TLV_FIX_LENGTH_TYPE(TlvName, Revert) \
-int32_t ParseTlv##TlvName(TlvBase *tlv, HcParcel *parcel, HcBool strict) \
-{ \
-    (void)strict; \
-    TlvName *realTlv = (TlvName *)(tlv); \
-    HcBool readRet = HC_FALSE; \
-    if (tlv->length != sizeof(realTlv->data)) \
-    { \
-        return TLV_FAIL; \
-    } \
-\
-    if (Revert) \
-    { \
-        readRet = ParcelReadRevert(parcel, &realTlv->data, sizeof(realTlv->data)); \
-    } else { \
-        readRet = ParcelRead(parcel, &realTlv->data, sizeof(realTlv->data)); \
-    } \
-    if (readRet) \
-    { \
-        return tlv->length; \
-    } else { \
-        return TLV_FAIL; \
-    } \
-} \
-\
-int32_t GetLenTlv##TlvName(TlvBase *tlv) \
-{ \
-    TlvName *realTlv = (TlvName *)(tlv); \
-    return (int32_t)sizeof(realTlv->data); \
-} \
-\
-int32_t EncodeTlv##TlvName(TlvBase *tlv, HcParcel *parcel) \
-{ \
-    HcBool writeRet = HC_FALSE; \
-    TlvName *realTlv = (TlvName *)(tlv); \
-    if (Revert) \
-    { \
-        writeRet = ParcelWriteRevert(parcel, &realTlv->data, sizeof(realTlv->data)); \
-    } else { \
-        writeRet = ParcelWrite(parcel, &realTlv->data, sizeof(realTlv->data)); \
-    } \
-    if (writeRet) \
-    { \
-        return sizeof(realTlv->data); \
-    } else { \
-        return TLV_FAIL; \
-    } \
-} \
-\
-DECLARE_TLV_PARSE_FUNC(TlvName, ParseTlv##TlvName, GetLenTlv##TlvName, EncodeTlv##TlvName);
-
-void DeinitTlvFixMember(TlvBase *tlv);
-
-#define DECLARE_TLV_PARSE_FUNC(TlvName, TlvParseFunc, TlvGetLenFunc, TlvEncodeFunc) \
-void Init##TlvName(TlvName *tlv, unsigned short checkTag) \
-{ \
-    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base)); \
-    tlv->base.parse = TlvParseFunc; \
-    tlv->base.getlen = TlvGetLenFunc; \
-    tlv->base.encode = TlvEncodeFunc; \
-    tlv->base.deinit = DeinitTlvFixMember; \
-    tlv->base.checkTag = checkTag; \
-}
-
-#define TLV_INIT(TlvName, TlvData) Init##TlvName(TlvData, USE_DEFAULT_TAG);
-
-#define TLV_DEINIT(TlvData) TlvData.base.deinit((TlvBase *)(&TlvData));
-typedef struct {
-    TlvBase base;
-    unsigned int offsetCount;
-    unsigned int offset[0];
-} TlvOffsetExample;
-
-HcBool ParseTlvHead(TlvBase *tlv, HcParcel *parcel);
-int32_t ParseTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool strict);
-int32_t GetlenTlvNode(TlvBase *tlv);
-void DeinitTlvNode(TlvBase *tlv);
-
-int32_t ParseTlvStruct(TlvBase *tlv, HcParcel *parcel, HcBool strict);
-int32_t EncodeTlvStruct(TlvBase *tlv, HcParcel *parcel);
-int32_t GetLenTlvStruct(TlvBase *tlv);
-void DeinitTlvStruct(TlvBase *tlv);
-int32_t EncodeTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool isRoot);
-HcBool DecodeTlvMessage(TlvBase *msg, HcParcel *parcel, HcBool strict);
-HcBool EncodeTlvMessage(TlvBase *msg, HcParcel *parcel);
-
-typedef struct {
-    TlvBase base;
-    HcParcel data;
-} TlvBuffer;
-
-void InitTlvBuffer(TlvBuffer *tlv, unsigned short checkTag);
-int32_t ParseTlvBuffer(TlvBase *tlv, HcParcel *parcel, HcBool strict);
-int32_t GetlenTlvBuffer(TlvBase *tlv);
-int32_t EncodeTlvBuffer(TlvBase *tlv, HcParcel *parcel);
-void DeinitTlvBuffer(TlvBase *tlv);
-
-typedef struct {
-    TlvBase base;
-    HcString data;
-} TlvString;
-
-void InitTlvString(TlvString *tlv, unsigned short checkTag);
-int32_t ParseTlvString(TlvBase *tlv, HcParcel *parcel, HcBool strict);
-int32_t GetlenTlvString(TlvBase *tlv);
-int32_t EncodeTlvString(TlvBase *tlv, HcParcel *parcel);
-void DeinitTlvString(TlvBase *tlv);
-
-#define DECLEAR_INIT_FUNC(TlvStruct) \
-void Init##TlvStruct(TlvStruct *tlv, unsigned short checkTag);
-
-DECLEAR_INIT_FUNC(TlvUint64)
-DECLEAR_INIT_FUNC(TlvUint32)
-DECLEAR_INIT_FUNC(TlvUint16)
-DECLEAR_INIT_FUNC(TlvUint8)
-DECLEAR_INIT_FUNC(TlvInt64)
-DECLEAR_INIT_FUNC(TlvInt32)
-DECLEAR_INIT_FUNC(TlvInt16)
-DECLEAR_INIT_FUNC(TlvInt8)
-
-#define DECLARE_TLV_VECTOR(TlvVecName, TlvVecElement) \
-DECLARE_HC_VECTOR(Vec##TlvVecName, TlvVecElement) \
-typedef struct { \
-    TlvBase base; \
-    Vec##TlvVecName data; \
-} TlvVecName; \
-void DeinitTlv##TlvVecName(TlvBase *tlv); \
-void Init##TlvVecName(TlvVecName *tlv, unsigned short checkTag);
-
-#define IMPLEMENT_TLV_VECTOR(TlvVecName, TlvElementName, VecAllocCount) \
-IMPLEMENT_HC_VECTOR(Vec##TlvVecName, TlvElementName, VecAllocCount) \
-int32_t ParseTlv##TlvVecName(TlvBase *tlv, HcParcel *parcel, HcBool strict) \
-{ \
-    TlvVecName *realTlv = (TlvVecName *)(tlv); \
-    uint32_t count = 0; \
-    if (!ParcelReadUint32(parcel, &count)) { \
-        return TLV_FAIL; \
-    } \
-    int32_t totalLen = sizeof(count); \
-    uint32_t index = 0; \
-    for (index = 0; index < count; ++index) { \
-        TlvElementName tlvElement; \
-        TlvElementName *curElement = realTlv->data.pushBack(&realTlv->data, &tlvElement); \
-        if (curElement == NULL) { \
-            return TLV_FAIL; \
-        } \
-        TLV_INIT(TlvElementName, curElement); \
-\
-        int32_t elementLen = ParseTlvNode((TlvBase *)curElement, parcel, strict); \
-        if (elementLen < 0) { \
-            return TLV_FAIL; \
-        } \
-        totalLen += elementLen; \
-        if (totalLen >= MAX_TOTOL_LEN) { \
-            return TLV_FAIL; \
-        } \
-    } \
-\
-    return totalLen; \
-} \
-\
-int32_t EncodeTlv##TlvVecName(TlvBase *tlv, HcParcel *parcel) \
-{ \
-    TlvVecName *realTlv = (TlvVecName *)(tlv); \
-    uint32_t index = 0; \
-    TlvElementName *element = NULL; \
-    uint32_t totalLen = 4; \
-    uint32_t count = realTlv->data.size(&realTlv->data); \
-    if (!ParcelWriteUint32(parcel, count)) { \
-        return TLV_FAIL; \
-    } \
-\
-    FOR_EACH_HC_VECTOR(realTlv->data, index, element) { \
-        if (element != NULL) { \
-            uint32_t len = EncodeTlvNode((TlvBase *)element, parcel, HC_FALSE); \
-            totalLen += len; \
-            if (totalLen >= MAX_TOTOL_LEN) { \
-                return TLV_FAIL; \
-            } \
-        } \
-    } \
-    return totalLen; \
-} \
-int32_t GetLenTlv##TlvVecName(TlvBase *tlv) \
-{ \
-    TlvVecName *realTlv = (TlvVecName *)(tlv); \
-    uint32_t index = 0; \
-    TlvElementName *element = NULL; \
-    uint32_t totalLen = sizeof(uint32_t); \
-    FOR_EACH_HC_VECTOR(realTlv->data, index, element) { \
-        if (element != NULL) { \
-            totalLen += GetlenTlvNode((TlvBase *)element); \
-            if (totalLen >= MAX_TOTOL_LEN) { \
-                return TLV_FAIL; \
-            } \
-        } else { \
-            return TLV_FAIL; \
-        } \
-    } \
-    return totalLen; \
-} \
-\
-void DeinitTlv##TlvVecName(TlvBase *tlv) \
-{ \
-    TlvVecName *realTlv = (TlvVecName *)(tlv); \
-    uint32_t index = 0; \
-    TlvElementName *element = NULL; \
-    FOR_EACH_HC_VECTOR(realTlv->data, index, element) { \
-        if (element != NULL) { \
-            TLV_DEINIT((*element)); \
-        } \
-    } \
-    DESTROY_HC_VECTOR(Vec##TlvVecName, &((TlvVecName *)tlv)->data); \
-} \
-\
-void Init##TlvVecName(TlvVecName *tlv, unsigned short checkTag) \
-{ \
-    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base)); \
-    tlv->base.parse = ParseTlv##TlvVecName; \
-    tlv->base.encode = EncodeTlv##TlvVecName; \
-    tlv->base.getlen = GetLenTlv##TlvVecName; \
-    tlv->base.deinit = DeinitTlv##TlvVecName; \
-    tlv->base.checkTag = checkTag; \
-    tlv->data = CREATE_HC_VECTOR(Vec##TlvVecName); \
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_TLV_PARSER_H
+#define HC_TLV_PARSER_H
+
+#include <hc_parcel.h>
+#include <hc_vector.h>
+#include <hc_string.h>
+
+#define USE_DEFAULT_TAG 0xFFFF
+#define TLV_FAIL (-1)
+#define NO_REVERT 0
+#define NEED_REVERT 1
+#define MAX_TOTOL_LEN (100 * 1024 * 1024)
+
+typedef struct TlvBaseT {
+    unsigned short tag;
+    unsigned short length;
+    unsigned short checkTag;
+    unsigned short hasValue;
+    int32_t (*parse)(struct TlvBaseT *, HcParcel *, HcBool);
+    int32_t (*getlen)(struct TlvBaseT *);
+    int32_t (*encode)(struct TlvBaseT *, HcParcel *);
+    void (*deinit)(struct TlvBaseT *);
+} TlvBase;
+
+#define DECLARE_TLV_STRUCT(x) \
+    TlvBase base; \
+    unsigned int offsetCount; \
+    unsigned int offset[x];
+
+unsigned short GetTag(unsigned short checkTag, unsigned short defaultTag);
+
+#define BEGIN_TLV_STRUCT_DEFINE(TlvS, CheckTag) \
+void Init##TlvS(TlvS *tlv, unsigned short checkTag) \
+{ \
+    typedef TlvS TlvStructType; \
+    unsigned int index = 0; \
+    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base)); \
+    tlv->base.checkTag = GetTag(checkTag, CheckTag);
+
+#define TLV_MEMBER_OPTION(TlvMember, TlvMemberName, CheckTag) \
+    Init##TlvMember(&tlv->TlvMemberName, CheckTag); \
+    tlv->TlvMemberName.base.option = 1; \
+    tlv->offset[index++] = offsetof(TlvStructType, TlvMemberName);
+
+#define TLV_MEMBER(TlvMember, TlvMemberName, CheckTag) \
+    Init##TlvMember(&tlv->TlvMemberName, CheckTag); \
+    tlv->offset[index++] = offsetof(TlvStructType, TlvMemberName);
+
+#define END_TLV_STRUCT_DEFINE(void) \
+    tlv->offsetCount = index; \
+    tlv->base.parse = ParseTlvStruct; \
+    tlv->base.getlen = GetLenTlvStruct; \
+    tlv->base.encode = EncodeTlvStruct; \
+    tlv->base.deinit = DeinitTlvStruct; \
+}
+
+#define DECLARE_TLV_FIX_LENGTH_TYPE(TlvName, TypeName) \
+typedef struct \
+{ \
+    TlvBase base; \
+    TypeName data; \
+} TlvName;
+
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt32, int)
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt16, short)
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt8, char)
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint32, uint32_t)
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint16, uint16_t)
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint8, uint8_t)
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvUint64, uint64_t)
+DECLARE_TLV_FIX_LENGTH_TYPE(TlvInt64, uint64_t)
+
+#define DEFINE_TLV_FIX_LENGTH_TYPE(TlvName, Revert) \
+int32_t ParseTlv##TlvName(TlvBase *tlv, HcParcel *parcel, HcBool strict) \
+{ \
+    (void)strict; \
+    TlvName *realTlv = (TlvName *)(tlv); \
+    HcBool readRet = HC_FALSE; \
+    if (tlv->length != sizeof(realTlv->data)) \
+    { \
+        return TLV_FAIL; \
+    } \
+\
+    if (Revert) \
+    { \
+        readRet = ParcelReadRevert(parcel, &realTlv->data, sizeof(realTlv->data)); \
+    } else { \
+        readRet = ParcelRead(parcel, &realTlv->data, sizeof(realTlv->data)); \
+    } \
+    if (readRet) \
+    { \
+        return tlv->length; \
+    } else { \
+        return TLV_FAIL; \
+    } \
+} \
+\
+int32_t GetLenTlv##TlvName(TlvBase *tlv) \
+{ \
+    TlvName *realTlv = (TlvName *)(tlv); \
+    return (int32_t)sizeof(realTlv->data); \
+} \
+\
+int32_t EncodeTlv##TlvName(TlvBase *tlv, HcParcel *parcel) \
+{ \
+    HcBool writeRet = HC_FALSE; \
+    TlvName *realTlv = (TlvName *)(tlv); \
+    if (Revert) \
+    { \
+        writeRet = ParcelWriteRevert(parcel, &realTlv->data, sizeof(realTlv->data)); \
+    } else { \
+        writeRet = ParcelWrite(parcel, &realTlv->data, sizeof(realTlv->data)); \
+    } \
+    if (writeRet) \
+    { \
+        return sizeof(realTlv->data); \
+    } else { \
+        return TLV_FAIL; \
+    } \
+} \
+\
+DECLARE_TLV_PARSE_FUNC(TlvName, ParseTlv##TlvName, GetLenTlv##TlvName, EncodeTlv##TlvName);
+
+void DeinitTlvFixMember(TlvBase *tlv);
+
+#define DECLARE_TLV_PARSE_FUNC(TlvName, TlvParseFunc, TlvGetLenFunc, TlvEncodeFunc) \
+void Init##TlvName(TlvName *tlv, unsigned short checkTag) \
+{ \
+    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base)); \
+    tlv->base.parse = TlvParseFunc; \
+    tlv->base.getlen = TlvGetLenFunc; \
+    tlv->base.encode = TlvEncodeFunc; \
+    tlv->base.deinit = DeinitTlvFixMember; \
+    tlv->base.checkTag = checkTag; \
+}
+
+#define TLV_INIT(TlvName, TlvData) Init##TlvName(TlvData, USE_DEFAULT_TAG);
+
+#define TLV_DEINIT(TlvData) TlvData.base.deinit((TlvBase *)(&TlvData));
+typedef struct {
+    TlvBase base;
+    unsigned int offsetCount;
+    unsigned int offset[0];
+} TlvOffsetExample;
+
+HcBool ParseTlvHead(TlvBase *tlv, HcParcel *parcel);
+int32_t ParseTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool strict);
+int32_t GetlenTlvNode(TlvBase *tlv);
+void DeinitTlvNode(TlvBase *tlv);
+
+int32_t ParseTlvStruct(TlvBase *tlv, HcParcel *parcel, HcBool strict);
+int32_t EncodeTlvStruct(TlvBase *tlv, HcParcel *parcel);
+int32_t GetLenTlvStruct(TlvBase *tlv);
+void DeinitTlvStruct(TlvBase *tlv);
+int32_t EncodeTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool isRoot);
+HcBool DecodeTlvMessage(TlvBase *msg, HcParcel *parcel, HcBool strict);
+HcBool EncodeTlvMessage(TlvBase *msg, HcParcel *parcel);
+
+typedef struct {
+    TlvBase base;
+    HcParcel data;
+} TlvBuffer;
+
+void InitTlvBuffer(TlvBuffer *tlv, unsigned short checkTag);
+int32_t ParseTlvBuffer(TlvBase *tlv, HcParcel *parcel, HcBool strict);
+int32_t GetlenTlvBuffer(TlvBase *tlv);
+int32_t EncodeTlvBuffer(TlvBase *tlv, HcParcel *parcel);
+void DeinitTlvBuffer(TlvBase *tlv);
+
+typedef struct {
+    TlvBase base;
+    HcString data;
+} TlvString;
+
+void InitTlvString(TlvString *tlv, unsigned short checkTag);
+int32_t ParseTlvString(TlvBase *tlv, HcParcel *parcel, HcBool strict);
+int32_t GetlenTlvString(TlvBase *tlv);
+int32_t EncodeTlvString(TlvBase *tlv, HcParcel *parcel);
+void DeinitTlvString(TlvBase *tlv);
+
+#define DECLEAR_INIT_FUNC(TlvStruct) \
+void Init##TlvStruct(TlvStruct *tlv, unsigned short checkTag);
+
+DECLEAR_INIT_FUNC(TlvUint64)
+DECLEAR_INIT_FUNC(TlvUint32)
+DECLEAR_INIT_FUNC(TlvUint16)
+DECLEAR_INIT_FUNC(TlvUint8)
+DECLEAR_INIT_FUNC(TlvInt64)
+DECLEAR_INIT_FUNC(TlvInt32)
+DECLEAR_INIT_FUNC(TlvInt16)
+DECLEAR_INIT_FUNC(TlvInt8)
+
+#define DECLARE_TLV_VECTOR(TlvVecName, TlvVecElement) \
+DECLARE_HC_VECTOR(Vec##TlvVecName, TlvVecElement) \
+typedef struct { \
+    TlvBase base; \
+    Vec##TlvVecName data; \
+} TlvVecName; \
+void DeinitTlv##TlvVecName(TlvBase *tlv); \
+void Init##TlvVecName(TlvVecName *tlv, unsigned short checkTag);
+
+#define IMPLEMENT_TLV_VECTOR(TlvVecName, TlvElementName, VecAllocCount) \
+IMPLEMENT_HC_VECTOR(Vec##TlvVecName, TlvElementName, VecAllocCount) \
+int32_t ParseTlv##TlvVecName(TlvBase *tlv, HcParcel *parcel, HcBool strict) \
+{ \
+    TlvVecName *realTlv = (TlvVecName *)(tlv); \
+    uint32_t count = 0; \
+    if (!ParcelReadUint32(parcel, &count)) { \
+        return TLV_FAIL; \
+    } \
+    int32_t totalLen = sizeof(count); \
+    uint32_t index = 0; \
+    for (index = 0; index < count; ++index) { \
+        TlvElementName tlvElement; \
+        TlvElementName *curElement = realTlv->data.pushBack(&realTlv->data, &tlvElement); \
+        if (curElement == NULL) { \
+            return TLV_FAIL; \
+        } \
+        TLV_INIT(TlvElementName, curElement); \
+\
+        int32_t elementLen = ParseTlvNode((TlvBase *)curElement, parcel, strict); \
+        if (elementLen < 0) { \
+            return TLV_FAIL; \
+        } \
+        totalLen += elementLen; \
+        if (totalLen >= MAX_TOTOL_LEN) { \
+            return TLV_FAIL; \
+        } \
+    } \
+\
+    return totalLen; \
+} \
+\
+int32_t EncodeTlv##TlvVecName(TlvBase *tlv, HcParcel *parcel) \
+{ \
+    TlvVecName *realTlv = (TlvVecName *)(tlv); \
+    uint32_t index = 0; \
+    TlvElementName *element = NULL; \
+    uint32_t totalLen = 4; \
+    uint32_t count = realTlv->data.size(&realTlv->data); \
+    if (!ParcelWriteUint32(parcel, count)) { \
+        return TLV_FAIL; \
+    } \
+\
+    FOR_EACH_HC_VECTOR(realTlv->data, index, element) { \
+        if (element != NULL) { \
+            uint32_t len = EncodeTlvNode((TlvBase *)element, parcel, HC_FALSE); \
+            totalLen += len; \
+            if (totalLen >= MAX_TOTOL_LEN) { \
+                return TLV_FAIL; \
+            } \
+        } \
+    } \
+    return totalLen; \
+} \
+int32_t GetLenTlv##TlvVecName(TlvBase *tlv) \
+{ \
+    TlvVecName *realTlv = (TlvVecName *)(tlv); \
+    uint32_t index = 0; \
+    TlvElementName *element = NULL; \
+    uint32_t totalLen = sizeof(uint32_t); \
+    FOR_EACH_HC_VECTOR(realTlv->data, index, element) { \
+        if (element != NULL) { \
+            totalLen += GetlenTlvNode((TlvBase *)element); \
+            if (totalLen >= MAX_TOTOL_LEN) { \
+                return TLV_FAIL; \
+            } \
+        } else { \
+            return TLV_FAIL; \
+        } \
+    } \
+    return totalLen; \
+} \
+\
+void DeinitTlv##TlvVecName(TlvBase *tlv) \
+{ \
+    TlvVecName *realTlv = (TlvVecName *)(tlv); \
+    uint32_t index = 0; \
+    TlvElementName *element = NULL; \
+    FOR_EACH_HC_VECTOR(realTlv->data, index, element) { \
+        if (element != NULL) { \
+            TLV_DEINIT((*element)); \
+        } \
+    } \
+    DESTROY_HC_VECTOR(Vec##TlvVecName, &((TlvVecName *)tlv)->data); \
+} \
+\
+void Init##TlvVecName(TlvVecName *tlv, unsigned short checkTag) \
+{ \
+    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base)); \
+    tlv->base.parse = ParseTlv##TlvVecName; \
+    tlv->base.encode = EncodeTlv##TlvVecName; \
+    tlv->base.getlen = GetLenTlv##TlvVecName; \
+    tlv->base.deinit = DeinitTlv##TlvVecName; \
+    tlv->base.checkTag = checkTag; \
+    tlv->data = CREATE_HC_VECTOR(Vec##TlvVecName); \
+}
+#endif
diff -Naru deviceauth/hals/inc/common/hc_vector.h deviceauth_new/hals/inc/common/hc_vector.h
--- deviceauth/hals/inc/common/hc_vector.h	2025-02-12 16:28:22.199906500 +0800
+++ deviceauth_new/hals/inc/common/hc_vector.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,172 +1,172 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_VECTOR_H
-#define HC_VECTOR_H
-
-#include "hc_parcel.h"
-#include "securec.h"
-
-/*
- * Use DECLARE_HC_VECTOR to declare the vector in the head/src file.
- * @para ClassName: the name of the vector-class/vector-struct
- * @para Element: the type of the vector element
- * @for example:
- * DECLARE_HC_VECTOR(IntVec, int)
- */
-#define DECLARE_HC_VECTOR(ClassName, Element) \
-typedef struct V##ClassName{ \
-    Element* (*pushBack)(struct V##ClassName*, const Element*); \
-    Element* (*pushBackT)(struct V##ClassName*, Element); \
-    HcBool (*popFront)(struct V##ClassName*, Element*); \
-    HcBool (*eraseElement)(struct V##ClassName*, Element*, uint32_t index); \
-    uint32_t (*size)(const struct V##ClassName*); \
-    Element (*get)(const struct V##ClassName*, uint32_t index); \
-    Element* (*getp)(const struct V##ClassName*, uint32_t index); \
-    void (*clear)(struct V##ClassName*); \
-    HcParcel parcel; \
-} ClassName;
-
-/*
- * Use IMPLEMENT_HC_VECTOR to implement the vector in the source file.
- * @para ClassName: the name of the vector-class/vector-struct
- * @para Element: the type of the vector element
- * @para allocCount: the minimum alloc count
- * @for example:
- * IMPLEMENT_HC_VECTOR(IntVec, int)
- */
-#define IMPLEMENT_HC_VECTOR(ClassName, Element, allocCount) \
-Element* VPushBack##ClassName(ClassName* obj, const Element *e) { \
-    if (obj == NULL || e == NULL) { \
-        return NULL; \
-    } \
-      \
-    if (ParcelWrite(&obj->parcel, e, sizeof(Element))) { \
-        int size = obj->size(obj); \
-        return obj->getp(obj, size-1); \
-    } else { \
-        return NULL; \
-    } \
-} \
-Element* VPushBackT##ClassName(ClassName* obj, Element e) { \
-    if (obj == NULL) { \
-        return NULL; \
-    } \
-      \
-    if (ParcelWrite(&obj->parcel, &e, sizeof(Element))) { \
-        int size = obj->size(obj); \
-        return obj->getp(obj, size-1); \
-    } else { \
-        return NULL; \
-    } \
-} \
-HcBool VPopFront##ClassName(ClassName* obj, Element* e) { \
-        if (NULL == obj || NULL == e) { \
-            return HC_FALSE; \
-        } \
-        if (obj->size(obj) > 0) { \
-            return ParcelRead(&obj->parcel, e, sizeof(Element)); \
-        } else { \
-            return HC_FALSE; \
-        } \
-} \
-HcBool VErase##ClassName(ClassName* obj, Element* e, uint32_t index) { \
-        if (NULL == obj || NULL == e || index + 1 > obj->size(obj)) { \
-            return HC_FALSE; \
-        } \
-        if (obj->size(obj) > 0) { \
-            return ParcelEraseBlock(&obj->parcel, index*sizeof(Element), sizeof(Element), e); \
-        } else { \
-            return HC_FALSE; \
-        } \
-} \
-uint32_t VSize##ClassName(const ClassName* obj) \
-{ \
-    if (NULL == obj) { \
-        return 0; \
-    } \
-    return GetParcelDataSize(&obj->parcel) / sizeof(Element); \
-} \
-Element VGet##ClassName(const ClassName* obj, uint32_t index) \
-{ \
-    Element e; \
-    (void)memset_s(&e, sizeof(e), 0, sizeof(e)); \
-    if (NULL != obj) { \
-        if (index < obj->size(obj)) { \
-            if (GetParcelData(&obj->parcel)) { \
-                return *((Element*)(GetParcelData(&obj->parcel)) + index); \
-            } else { \
-                return e; \
-            } \
-        } \
-    } \
-    (void)memset_s(&e, sizeof(e), 0, sizeof(e)); \
-    return e; \
-} \
-Element* VGetPointer##ClassName(const ClassName* obj, uint32_t index) \
-{ \
-    if (NULL != obj) { \
-        if (index < obj->size(obj)) { \
-            if (GetParcelData(&obj->parcel)) { \
-                return ((Element*)(GetParcelData(&obj->parcel)) + index); \
-            } else { \
-                return NULL; \
-            } \
-        } \
-    } \
-    return NULL; \
-} \
-void VClear##ClassName(ClassName* obj) \
-{ \
-    if (NULL != obj) { \
-        ClearParcel(&obj->parcel); \
-    } \
-} \
-ClassName Create##ClassName(void) \
-{ \
-    ClassName obj; \
-    obj.pushBack = VPushBack##ClassName; \
-    obj.pushBackT = VPushBackT##ClassName; \
-    obj.popFront = VPopFront##ClassName; \
-    obj.clear = VClear##ClassName; \
-    obj.eraseElement = VErase##ClassName; \
-    obj.size = VSize##ClassName; \
-    obj.get = VGet##ClassName; \
-    obj.getp = VGetPointer##ClassName; \
-    obj.parcel = CreateParcel(0, sizeof(Element) * allocCount); \
-    return obj; \
-} \
-void Destroy##ClassName(ClassName* obj) \
-{ \
-    if (NULL != obj) { \
-        DeleteParcel(&obj->parcel); \
-    } \
-}
-
-/* Use these two macros to create and destroy vector */
-#define CREATE_HC_VECTOR(classname) Create##classname();
-#define DESTROY_HC_VECTOR(classname, obj) Destroy##classname(obj);
-
-#define FOR_EACH_HC_VECTOR(vec, index, iter) for (index = 0; index < (vec).size(&(vec)) && \
-    (iter = (vec).getp(&(vec), index)); ++index)
-
-#define HC_VECTOR_PUSHBACK(obj, element) (obj)->pushBack((obj), (element))
-#define HC_VECTOR_POPFRONT(obj, element) (obj)->popFront((obj), (element))
-#define HC_VECTOR_POPELEMENT(obj, element, index) (obj)->eraseElement((obj), (element), (index))
-#define HC_VECTOR_SIZE(obj) (obj)->size(obj)
-#define HC_VECTOR_GET(obj, index) (obj)->get((obj), (index))
-#define HC_VECTOR_GETP(_obj, _index) (_obj)->getp((_obj), (_index))
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_VECTOR_H
+#define HC_VECTOR_H
+
+#include "hc_parcel.h"
+#include "securec.h"
+
+/*
+ * Use DECLARE_HC_VECTOR to declare the vector in the head/src file.
+ * @para ClassName: the name of the vector-class/vector-struct
+ * @para Element: the type of the vector element
+ * @for example:
+ * DECLARE_HC_VECTOR(IntVec, int)
+ */
+#define DECLARE_HC_VECTOR(ClassName, Element) \
+typedef struct V##ClassName{ \
+    Element* (*pushBack)(struct V##ClassName*, const Element*); \
+    Element* (*pushBackT)(struct V##ClassName*, Element); \
+    HcBool (*popFront)(struct V##ClassName*, Element*); \
+    HcBool (*eraseElement)(struct V##ClassName*, Element*, uint32_t index); \
+    uint32_t (*size)(const struct V##ClassName*); \
+    Element (*get)(const struct V##ClassName*, uint32_t index); \
+    Element* (*getp)(const struct V##ClassName*, uint32_t index); \
+    void (*clear)(struct V##ClassName*); \
+    HcParcel parcel; \
+} ClassName;
+
+/*
+ * Use IMPLEMENT_HC_VECTOR to implement the vector in the source file.
+ * @para ClassName: the name of the vector-class/vector-struct
+ * @para Element: the type of the vector element
+ * @para allocCount: the minimum alloc count
+ * @for example:
+ * IMPLEMENT_HC_VECTOR(IntVec, int)
+ */
+#define IMPLEMENT_HC_VECTOR(ClassName, Element, allocCount) \
+Element* VPushBack##ClassName(ClassName* obj, const Element *e) { \
+    if (obj == NULL || e == NULL) { \
+        return NULL; \
+    } \
+      \
+    if (ParcelWrite(&obj->parcel, e, sizeof(Element))) { \
+        int size = obj->size(obj); \
+        return obj->getp(obj, size-1); \
+    } else { \
+        return NULL; \
+    } \
+} \
+Element* VPushBackT##ClassName(ClassName* obj, Element e) { \
+    if (obj == NULL) { \
+        return NULL; \
+    } \
+      \
+    if (ParcelWrite(&obj->parcel, &e, sizeof(Element))) { \
+        int size = obj->size(obj); \
+        return obj->getp(obj, size-1); \
+    } else { \
+        return NULL; \
+    } \
+} \
+HcBool VPopFront##ClassName(ClassName* obj, Element* e) { \
+        if (NULL == obj || NULL == e) { \
+            return HC_FALSE; \
+        } \
+        if (obj->size(obj) > 0) { \
+            return ParcelRead(&obj->parcel, e, sizeof(Element)); \
+        } else { \
+            return HC_FALSE; \
+        } \
+} \
+HcBool VErase##ClassName(ClassName* obj, Element* e, uint32_t index) { \
+        if (NULL == obj || NULL == e || index + 1 > obj->size(obj)) { \
+            return HC_FALSE; \
+        } \
+        if (obj->size(obj) > 0) { \
+            return ParcelEraseBlock(&obj->parcel, index*sizeof(Element), sizeof(Element), e); \
+        } else { \
+            return HC_FALSE; \
+        } \
+} \
+uint32_t VSize##ClassName(const ClassName* obj) \
+{ \
+    if (NULL == obj) { \
+        return 0; \
+    } \
+    return GetParcelDataSize(&obj->parcel) / sizeof(Element); \
+} \
+Element VGet##ClassName(const ClassName* obj, uint32_t index) \
+{ \
+    Element e; \
+    (void)memset_s(&e, sizeof(e), 0, sizeof(e)); \
+    if (NULL != obj) { \
+        if (index < obj->size(obj)) { \
+            if (GetParcelData(&obj->parcel)) { \
+                return *((Element*)(GetParcelData(&obj->parcel)) + index); \
+            } else { \
+                return e; \
+            } \
+        } \
+    } \
+    (void)memset_s(&e, sizeof(e), 0, sizeof(e)); \
+    return e; \
+} \
+Element* VGetPointer##ClassName(const ClassName* obj, uint32_t index) \
+{ \
+    if (NULL != obj) { \
+        if (index < obj->size(obj)) { \
+            if (GetParcelData(&obj->parcel)) { \
+                return ((Element*)(GetParcelData(&obj->parcel)) + index); \
+            } else { \
+                return NULL; \
+            } \
+        } \
+    } \
+    return NULL; \
+} \
+void VClear##ClassName(ClassName* obj) \
+{ \
+    if (NULL != obj) { \
+        ClearParcel(&obj->parcel); \
+    } \
+} \
+ClassName Create##ClassName(void) \
+{ \
+    ClassName obj; \
+    obj.pushBack = VPushBack##ClassName; \
+    obj.pushBackT = VPushBackT##ClassName; \
+    obj.popFront = VPopFront##ClassName; \
+    obj.clear = VClear##ClassName; \
+    obj.eraseElement = VErase##ClassName; \
+    obj.size = VSize##ClassName; \
+    obj.get = VGet##ClassName; \
+    obj.getp = VGetPointer##ClassName; \
+    obj.parcel = CreateParcel(0, sizeof(Element) * allocCount); \
+    return obj; \
+} \
+void Destroy##ClassName(ClassName* obj) \
+{ \
+    if (NULL != obj) { \
+        DeleteParcel(&obj->parcel); \
+    } \
+}
+
+/* Use these two macros to create and destroy vector */
+#define CREATE_HC_VECTOR(classname) Create##classname();
+#define DESTROY_HC_VECTOR(classname, obj) Destroy##classname(obj);
+
+#define FOR_EACH_HC_VECTOR(vec, index, iter) for (index = 0; index < (vec).size(&(vec)) && \
+    (iter = (vec).getp(&(vec), index)); ++index)
+
+#define HC_VECTOR_PUSHBACK(obj, element) (obj)->pushBack((obj), (element))
+#define HC_VECTOR_POPFRONT(obj, element) (obj)->popFront((obj), (element))
+#define HC_VECTOR_POPELEMENT(obj, element, index) (obj)->eraseElement((obj), (element), (index))
+#define HC_VECTOR_SIZE(obj) (obj)->size(obj)
+#define HC_VECTOR_GET(obj, index) (obj)->get((obj), (index))
+#define HC_VECTOR_GETP(_obj, _index) (_obj)->getp((_obj), (_index))
+
+#endif
diff -Naru deviceauth/hals/inc/common/json_utils.h deviceauth_new/hals/inc/common/json_utils.h
--- deviceauth/hals/inc/common/json_utils.h	2025-02-12 16:28:22.280753600 +0800
+++ deviceauth_new/hals/inc/common/json_utils.h	2025-02-12 15:01:27.826543400 +0800
@@ -1,107 +1,107 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef JSON_UTILS_H
-#define JSON_UTILS_H
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "cJSON.h"
-#include "hc_error.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef cJSON CJson;
-
-/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
-CJson *CreateJsonFromString(const char *jsonStr);
-/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
-CJson *CreateJson(void);
-/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
-CJson *CreateJsonArray(void);
-/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
-CJson *DuplicateJson(const CJson *jsonObj);
-void FreeJson(CJson *jsonObj);
-
-void DeleteItemFromJson(CJson *jsonObj, const char *key);
-void DeleteAllItemExceptOne(CJson *jsonObj, const char *key);
-void DeleteAllItem(CJson *jsonObj);
-CJson *DetachItemFromJson(CJson *jsonObj, const char *key);
-
-/* Need to call FreeJsonString to free the returned pointer when it's no longer in use. */
-char *PackJsonToString(const CJson *jsonObj);
-void FreeJsonString(char *jsonStr);
-
-int GetItemNum(const CJson *jsonObj);
-/*
- * Can't release the returned pointer, otherwise, an exception may occur.
- * It refers to the parent object(param--jsonObj)'s memory.
- * It will be recycled along with jsonObj when jsonObj is released.
- */
-const char *GetItemKey(const CJson *item);
-
-/*
- * Can't release the returned pointer, otherwise, an exception may occur.
- * It refers to the parent object(param--jsonObj)'s memory.
- * It will be recycled along with jsonObj when jsonObj is released.
- */
-CJson *GetObjFromJson(const CJson *jsonObj, const char *key);
-
-/*
- * Can't release the returned pointer, otherwise, an exception may occur.
- * It refers to the parent object(param--jsonObj)'s memory.
- * It will be recycled along with jsonObj when jsonObj is released.
- */
-CJson *GetItemFromArray(const CJson *jsonArr, int index);
-
-/*
- * Can't release the returned pointer, otherwise, an exception may occur.
- * It refers to the parent object(param--jsonObj)'s memory.
- * It will be recycled along with jsonObj when jsonObj is released.
- */
-const char *GetStringFromJson(const CJson *jsonObj, const char *key);
-
-/*
- * The byte in jsonObj must be in the form of hex string.
- * This function will convert the hex string to byte, and then put it in param--byte in the form of byte.
- */
-int32_t GetByteFromJson(const CJson *jsonObj, const char *key, uint8_t *byte, uint32_t len);
-int32_t GetIntFromJson(const CJson *jsonObj, const char *key, int *value);
-int32_t GetInt64FromJson(const CJson *jsonObj, const char *key, int64_t *value);
-int32_t GetBoolFromJson(const CJson *jsonObj, const char *key, bool *value);
-char *GetStringValue(const CJson *item);
-
-int32_t AddObjToJson(CJson *jsonObj, const char *key, const CJson *childObj);
-int32_t AddObjToArray(CJson *jsonArr, CJson *item);
-int32_t AddStringToJson(CJson *jsonObj, const char *key, const char *value);
-int32_t AddStringToArray(CJson *jsonArr, const char *string);
-/* The function will convert the byte to hex string, and then add it to object. */
-int32_t AddByteToJson(CJson *jsonObj, const char *key, const uint8_t *byte, uint32_t len);
-int32_t AddBoolToJson(CJson *jsonObj, const char *key, bool value);
-int32_t AddIntToJson(CJson *jsonObj, const char *key, int value);
-int32_t AddInt64StringToJson(CJson *jsonObj, const char *key, int64_t value);
-int32_t AddStringArrayToJson(CJson *jsonObj, const char *key, const char * const *stringArray, uint32_t arrayLen);
-void ClearSensitiveStringInJson(CJson *jsonObj, const char *key);
-void ClearAndFreeJsonString(char *jsonStr);
-int32_t GetUnsignedIntFromJson(const CJson *jsonObj, const char *key, uint32_t *value);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JSON_UTILS_H
+#define JSON_UTILS_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "cJSON.h"
+#include "hc_error.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef cJSON CJson;
+
+/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
+CJson *CreateJsonFromString(const char *jsonStr);
+/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
+CJson *CreateJson(void);
+/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
+CJson *CreateJsonArray(void);
+/* Need to call FreeJson to free the returned pointer when it's no longer in use. */
+CJson *DuplicateJson(const CJson *jsonObj);
+void FreeJson(CJson *jsonObj);
+
+void DeleteItemFromJson(CJson *jsonObj, const char *key);
+void DeleteAllItemExceptOne(CJson *jsonObj, const char *key);
+void DeleteAllItem(CJson *jsonObj);
+CJson *DetachItemFromJson(CJson *jsonObj, const char *key);
+
+/* Need to call FreeJsonString to free the returned pointer when it's no longer in use. */
+char *PackJsonToString(const CJson *jsonObj);
+void FreeJsonString(char *jsonStr);
+
+int GetItemNum(const CJson *jsonObj);
+/*
+ * Can't release the returned pointer, otherwise, an exception may occur.
+ * It refers to the parent object(param--jsonObj)'s memory.
+ * It will be recycled along with jsonObj when jsonObj is released.
+ */
+const char *GetItemKey(const CJson *item);
+
+/*
+ * Can't release the returned pointer, otherwise, an exception may occur.
+ * It refers to the parent object(param--jsonObj)'s memory.
+ * It will be recycled along with jsonObj when jsonObj is released.
+ */
+CJson *GetObjFromJson(const CJson *jsonObj, const char *key);
+
+/*
+ * Can't release the returned pointer, otherwise, an exception may occur.
+ * It refers to the parent object(param--jsonObj)'s memory.
+ * It will be recycled along with jsonObj when jsonObj is released.
+ */
+CJson *GetItemFromArray(const CJson *jsonArr, int index);
+
+/*
+ * Can't release the returned pointer, otherwise, an exception may occur.
+ * It refers to the parent object(param--jsonObj)'s memory.
+ * It will be recycled along with jsonObj when jsonObj is released.
+ */
+const char *GetStringFromJson(const CJson *jsonObj, const char *key);
+
+/*
+ * The byte in jsonObj must be in the form of hex string.
+ * This function will convert the hex string to byte, and then put it in param--byte in the form of byte.
+ */
+int32_t GetByteFromJson(const CJson *jsonObj, const char *key, uint8_t *byte, uint32_t len);
+int32_t GetIntFromJson(const CJson *jsonObj, const char *key, int *value);
+int32_t GetInt64FromJson(const CJson *jsonObj, const char *key, int64_t *value);
+int32_t GetBoolFromJson(const CJson *jsonObj, const char *key, bool *value);
+char *GetStringValue(const CJson *item);
+
+int32_t AddObjToJson(CJson *jsonObj, const char *key, const CJson *childObj);
+int32_t AddObjToArray(CJson *jsonArr, CJson *item);
+int32_t AddStringToJson(CJson *jsonObj, const char *key, const char *value);
+int32_t AddStringToArray(CJson *jsonArr, const char *string);
+/* The function will convert the byte to hex string, and then add it to object. */
+int32_t AddByteToJson(CJson *jsonObj, const char *key, const uint8_t *byte, uint32_t len);
+int32_t AddBoolToJson(CJson *jsonObj, const char *key, bool value);
+int32_t AddIntToJson(CJson *jsonObj, const char *key, int value);
+int32_t AddInt64StringToJson(CJson *jsonObj, const char *key, int64_t value);
+int32_t AddStringArrayToJson(CJson *jsonObj, const char *key, const char * const *stringArray, uint32_t arrayLen);
+void ClearSensitiveStringInJson(CJson *jsonObj, const char *key);
+void ClearAndFreeJsonString(char *jsonStr);
+int32_t GetUnsignedIntFromJson(const CJson *jsonObj, const char *key, uint32_t *value);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naru deviceauth/hals/inc/dev_info/3861/hc_dev_info.h deviceauth_new/hals/inc/dev_info/3861/hc_dev_info.h
--- deviceauth/hals/inc/dev_info/3861/hc_dev_info.h	2025-02-12 16:28:22.367553600 +0800
+++ deviceauth_new/hals/inc/dev_info/3861/hc_dev_info.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,43 +1,43 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_DEV_INFO_H
-#define HC_DEV_INFO_H
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define INPUT_UDID_LEN 65
-#define MAX_INPUT_UDID_LEN 200
-#define MAX_SESSION_COUNT 20
-
-/*
- * Get the unique device ID of the device(UDID).
- * udid: It is used to store the UDID finally obtained.
- * udidLen: The size of array to store UDID. Its value is the real udid size + 1 (including '\0').
- *          In liteos and linux, the udidLen must be 65.
- * Return 0 if the UDID is successfully obtained, other returns an error code.
- */
-int32_t HcGetUdid(uint8_t *udid, int32_t udidLen);
-
-const char *GetStoragePath(void);
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_DEV_INFO_H
+#define HC_DEV_INFO_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define INPUT_UDID_LEN 65
+#define MAX_INPUT_UDID_LEN 200
+#define MAX_SESSION_COUNT 20
+
+/*
+ * Get the unique device ID of the device(UDID).
+ * udid: It is used to store the UDID finally obtained.
+ * udidLen: The size of array to store UDID. Its value is the real udid size + 1 (including '\0').
+ *          In liteos and linux, the udidLen must be 65.
+ * Return 0 if the UDID is successfully obtained, other returns an error code.
+ */
+int32_t HcGetUdid(uint8_t *udid, int32_t udidLen);
+
+const char *GetStoragePath(void);
+
+#ifdef __cplusplus
+}
+#endif
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/dev_info/watch/hc_dev_info.h deviceauth_new/hals/inc/dev_info/watch/hc_dev_info.h
--- deviceauth/hals/inc/dev_info/watch/hc_dev_info.h	2025-02-12 16:28:22.404257700 +0800
+++ deviceauth_new/hals/inc/dev_info/watch/hc_dev_info.h	2025-02-12 15:01:27.830543400 +0800
@@ -20,7 +20,7 @@
 
 #define INPUT_UDID_LEN 65
 #define MAX_INPUT_UDID_LEN 200
-#define MAX_SESSION_COUNT 10
+#define MAX_SESSION_COUNT 20
 
 /*
  * Get the unique device ID of the device(UDID).
diff -Naru deviceauth/hals/inc/linux/hc_condition.h deviceauth_new/hals/inc/linux/hc_condition.h
--- deviceauth/hals/inc/linux/hc_condition.h	2025-02-12 16:28:22.484610200 +0800
+++ deviceauth_new/hals/inc/linux/hc_condition.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,45 +1,45 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_CONDITION_H
-#define HC_CONDITION_H
-
-#include "hc_mutex.h"
-#include "hc_types.h"
-#include "pthread.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct HcConditionT {
-    HcBool notified;
-    HcBool innerMutex;
-    HcBool waited;
-    HcMutex* mutex;
-    int (*wait)(struct HcConditionT*);
-    void (*notify)(struct HcConditionT*);
-    int (*waitWithoutLock)(struct HcConditionT*);
-    void (*notifyWithoutLock)(struct HcConditionT*);
-    pthread_cond_t cond;
-} HcCondition;
-
-int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex);
-void DestroyHcCond(HcCondition* hcCond);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_CONDITION_H
+#define HC_CONDITION_H
+
+#include "hc_mutex.h"
+#include "hc_types.h"
+#include "pthread.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct HcConditionT {
+    HcBool notified;
+    HcBool innerMutex;
+    HcBool waited;
+    HcMutex* mutex;
+    int (*wait)(struct HcConditionT*);
+    void (*notify)(struct HcConditionT*);
+    int (*waitWithoutLock)(struct HcConditionT*);
+    void (*notifyWithoutLock)(struct HcConditionT*);
+    pthread_cond_t cond;
+} HcCondition;
+
+int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex);
+void DestroyHcCond(HcCondition* hcCond);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naru deviceauth/hals/inc/linux/hc_init_protection.h deviceauth_new/hals/inc/linux/hc_init_protection.h
--- deviceauth/hals/inc/linux/hc_init_protection.h	2025-02-12 16:28:22.567442200 +0800
+++ deviceauth_new/hals/inc/linux/hc_init_protection.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,33 +1,33 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_INIT_PROTECTION_H
-#define HC_INIT_PROTECTION_H
-
-#include <stdio.h>
-
-typedef enum InitStatusEnum {
-    CONTINUE_INIT = 0,
-    FINISH_INIT,
-    CONTINUE_DESTROY,
-    FINISH_DESTROY,
-} InitStatus;
-
-int CheckInit(void);
-int CheckDestroy(void);
-void SetInitStatus(void);
-void SetDeInitStatus(void);
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_INIT_PROTECTION_H
+#define HC_INIT_PROTECTION_H
+
+#include <stdio.h>
+
+typedef enum InitStatusEnum {
+    CONTINUE_INIT = 0,
+    FINISH_INIT,
+    CONTINUE_DESTROY,
+    FINISH_DESTROY,
+} InitStatus;
+
+int CheckInit(void);
+int CheckDestroy(void);
+void SetInitStatus(void);
+void SetDeInitStatus(void);
+
 #endif 
\ No newline at end of file
diff -Naru deviceauth/hals/inc/linux/hc_log.h deviceauth_new/hals/inc/linux/hc_log.h
--- deviceauth/hals/inc/linux/hc_log.h	2025-02-12 16:28:22.622002600 +0800
+++ deviceauth_new/hals/inc/linux/hc_log.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,62 +1,62 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_LOG_H
-#define HC_LOG_H
-
-#include <inttypes.h>
-
-typedef enum {
-    DEV_AUTH_LOG_LEVEL_DEBUG = 0,
-    DEV_AUTH_LOG_LEVEL_INFO,
-    DEV_AUTH_LOG_LEVEL_WARN,
-    DEV_AUTH_LOG_LEVEL_ERROR
-} DevAuthLogLevel;
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void DevAuthLogPrint(DevAuthLogLevel level, const char *funName, const char *fmt, ...);
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef HILOG_ENABLE
-
-#include "hilog/log.h"
-
-#define LOGD(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_DEBUG, __FUNCTION__, fmt, ##__VA_ARGS__))
-#define LOGI(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_INFO, __FUNCTION__, fmt, ##__VA_ARGS__))
-#define LOGW(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_WARN, __FUNCTION__, fmt, ##__VA_ARGS__))
-#define LOGE(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_ERROR, __FUNCTION__, fmt, ##__VA_ARGS__))
-
-#define DEV_AUTH_LOG_DEBUG(buf) HiLogPrint(LOG_CORE, LOG_DEBUG, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
-#define DEV_AUTH_LOG_INFO(buf) HiLogPrint(LOG_CORE, LOG_INFO, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
-#define DEV_AUTH_LOG_WARN(buf) HiLogPrint(LOG_CORE, LOG_WARN, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
-#define DEV_AUTH_LOG_ERROR(buf) HiLogPrint(LOG_CORE, LOG_ERROR, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
-
-#else
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#define LOGD(fmt, ...) printf("[D][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
-#define LOGI(fmt, ...) printf("[I][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
-#define LOGW(fmt, ...) printf("[W][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
-#define LOGE(fmt, ...) printf("[E][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_LOG_H
+#define HC_LOG_H
+
+#include <inttypes.h>
+
+typedef enum {
+    DEV_AUTH_LOG_LEVEL_DEBUG = 0,
+    DEV_AUTH_LOG_LEVEL_INFO,
+    DEV_AUTH_LOG_LEVEL_WARN,
+    DEV_AUTH_LOG_LEVEL_ERROR
+} DevAuthLogLevel;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void DevAuthLogPrint(DevAuthLogLevel level, const char *funName, const char *fmt, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef HILOG_ENABLE
+
+#include "hilog/log.h"
+
+#define LOGD(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_DEBUG, __FUNCTION__, fmt, ##__VA_ARGS__))
+#define LOGI(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_INFO, __FUNCTION__, fmt, ##__VA_ARGS__))
+#define LOGW(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_WARN, __FUNCTION__, fmt, ##__VA_ARGS__))
+#define LOGE(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_ERROR, __FUNCTION__, fmt, ##__VA_ARGS__))
+
+#define DEV_AUTH_LOG_DEBUG(buf) HiLogPrint(LOG_CORE, LOG_DEBUG, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
+#define DEV_AUTH_LOG_INFO(buf) HiLogPrint(LOG_CORE, LOG_INFO, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
+#define DEV_AUTH_LOG_WARN(buf) HiLogPrint(LOG_CORE, LOG_WARN, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
+#define DEV_AUTH_LOG_ERROR(buf) HiLogPrint(LOG_CORE, LOG_ERROR, LOG_DOMAIN, "[DEVAUTH]", "%{public}s", buf)
+
+#else
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define LOGD(fmt, ...) printf("[D][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
+#define LOGI(fmt, ...) printf("[I][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
+#define LOGW(fmt, ...) printf("[W][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
+#define LOGE(fmt, ...) printf("[E][DEVAUTH]%s: " fmt "\n", __FUNCTION__, ##__VA_ARGS__)
+#endif
+#endif
diff -Naru deviceauth/hals/inc/linux/hc_mutex.h deviceauth_new/hals/inc/linux/hc_mutex.h
--- deviceauth/hals/inc/linux/hc_mutex.h	2025-02-12 16:28:22.650274000 +0800
+++ deviceauth_new/hals/inc/linux/hc_mutex.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,38 +1,38 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_MUTEX_H
-#define HC_MUTEX_H
-
-#include "pthread.h"
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct HcMutexT {
-    int (*lock)(struct HcMutexT* mutex);
-    void (*unlock)(struct HcMutexT* mutex);
-    pthread_mutex_t mutex;
-} HcMutex;
-
-int32_t InitHcMutex(HcMutex* mutex);
-void DestroyHcMutex(HcMutex* mutex);
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_MUTEX_H
+#define HC_MUTEX_H
+
+#include "pthread.h"
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct HcMutexT {
+    int (*lock)(struct HcMutexT* mutex);
+    void (*unlock)(struct HcMutexT* mutex);
+    pthread_mutex_t mutex;
+} HcMutex;
+
+int32_t InitHcMutex(HcMutex* mutex);
+void DestroyHcMutex(HcMutex* mutex);
+
+#ifdef __cplusplus
+}
+#endif
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/linux/hc_thread.h deviceauth_new/hals/inc/linux/hc_thread.h
--- deviceauth/hals/inc/linux/hc_thread.h	2025-02-12 16:28:22.682018200 +0800
+++ deviceauth_new/hals/inc/linux/hc_thread.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,51 +1,51 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_THREAD_H
-#define HC_THREAD_H
-
-#include "pthread.h"
-#include "hc_types.h"
-#include "hc_string.h"
-#include "hc_condition.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef int (*ThreadFunc)(void*);
-
-typedef struct HcThreadT {
-    ThreadFunc threadFunc;
-    int (*start)(struct HcThreadT* thread);
-    void(*join)(struct HcThreadT* thread);
-    void (*wait)(struct HcThreadT* thread);
-    void (*notify)(struct HcThreadT* thread);
-    pthread_t thread;
-    size_t stackSize;
-    HcBool running;
-    HcString name;
-    HcCondition threadWaitObj;
-    HcMutex threadLock;
-    HcCondition bizWaitObj;
-} HcThread;
-
-int32_t InitThread(HcThread* thread, ThreadFunc func, size_t stackSize, const char* threadName);
-void DestroyThread(HcThread* thread);
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_THREAD_H
+#define HC_THREAD_H
+
+#include "pthread.h"
+#include "hc_types.h"
+#include "hc_string.h"
+#include "hc_condition.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int (*ThreadFunc)(void*);
+
+typedef struct HcThreadT {
+    ThreadFunc threadFunc;
+    int (*start)(struct HcThreadT* thread);
+    void(*join)(struct HcThreadT* thread);
+    void (*wait)(struct HcThreadT* thread);
+    void (*notify)(struct HcThreadT* thread);
+    pthread_t thread;
+    size_t stackSize;
+    HcBool running;
+    HcString name;
+    HcCondition threadWaitObj;
+    HcMutex threadLock;
+    HcCondition bizWaitObj;
+} HcThread;
+
+int32_t InitThread(HcThread* thread, ThreadFunc func, size_t stackSize, const char* threadName);
+void DestroyThread(HcThread* thread);
+
+#ifdef __cplusplus
+}
+#endif
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/linux/hc_time.h deviceauth_new/hals/inc/linux/hc_time.h
--- deviceauth/hals/inc/linux/hc_time.h	2025-02-12 16:28:22.709299400 +0800
+++ deviceauth_new/hals/inc/linux/hc_time.h	2025-02-12 15:01:27.830543400 +0800
@@ -23,7 +23,7 @@
 #endif
 
 /* Calculate in seconds */
-#define TIME_OUT_VALUE 300
+#define TIME_OUT_VALUE 600
 
 /* Return in seconds */
 int64_t HcGetCurTime(void);
diff -Naru deviceauth/hals/inc/linux/hc_types.h deviceauth_new/hals/inc/linux/hc_types.h
--- deviceauth/hals/inc/linux/hc_types.h	2025-02-12 16:28:22.734595900 +0800
+++ deviceauth_new/hals/inc/linux/hc_types.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,46 +1,46 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_TYPES_H
-#define HC_TYPES_H
-
-#include <stdlib.h>
-#include <stdint.h>
-#include <string.h>
-#include <stdbool.h>
-#include "securec.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef uint32_t HcBool;
-#define HC_TRUE 1
-#define HC_FALSE 0
-
-#ifndef NULL
-#define NULL 0
-#endif
-
-void* HcMalloc(uint32_t size, char val);
-void HcFree(void* addr);
-void ReportMalloc(void);
-uint32_t HcStrlen(const char *str);
-
-#ifdef __cplusplus
-}
-#endif
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_TYPES_H
+#define HC_TYPES_H
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdbool.h>
+#include "securec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef uint32_t HcBool;
+#define HC_TRUE 1
+#define HC_FALSE 0
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+void* HcMalloc(uint32_t size, char val);
+void HcFree(void* addr);
+void ReportMalloc(void);
+uint32_t HcStrlen(const char *str);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/linux/mbedtls_hash_to_point.h deviceauth_new/hals/inc/linux/mbedtls_hash_to_point.h
--- deviceauth/hals/inc/linux/mbedtls_hash_to_point.h	2025-02-12 16:28:22.775763900 +0800
+++ deviceauth_new/hals/inc/linux/mbedtls_hash_to_point.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,35 +1,35 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef MBEDTLS_HASH_TO_POINT_H
-#define MBEDTLS_HASH_TO_POINT_H
-
-#include <stdint.h>
-
-#include "common_defs.h"
-
-#define HASH2POINT_PARA_PREPRO 0xc0
-#define BYTE_LENGTH_CURVE_25519 32
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int32_t MbedtlsHashToPoint(const Uint8Buff *hash, Uint8Buff *outEcPoint);
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MBEDTLS_HASH_TO_POINT_H
+#define MBEDTLS_HASH_TO_POINT_H
+
+#include <stdint.h>
+
+#include "common_defs.h"
+
+#define HASH2POINT_PARA_PREPRO 0xc0
+#define BYTE_LENGTH_CURVE_25519 32
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int32_t MbedtlsHashToPoint(const Uint8Buff *hash, Uint8Buff *outEcPoint);
+
+#ifdef __cplusplus
+}
+#endif
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/liteos/hc_condition.h deviceauth_new/hals/inc/liteos/hc_condition.h
--- deviceauth/hals/inc/liteos/hc_condition.h	2025-02-12 16:28:22.800067900 +0800
+++ deviceauth_new/hals/inc/liteos/hc_condition.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,34 +1,34 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_CONDITION_H
-#define HC_CONDITION_H
-
-#include "hc_mutex.h"
-#include "hc_types.h"
-#include <semaphore.h>
-
-typedef struct HcConditionT {
-    int (*wait)(struct HcConditionT*);
-    void (*notify)(struct HcConditionT*);
-    int (*waitWithoutLock)(struct HcConditionT*);
-    void (*notifyWithoutLock)(struct HcConditionT*);
-    sem_t sem;
-} HcCondition;
-
-int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex);
-void DestroyHcCond(HcCondition* hcCond);
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_CONDITION_H
+#define HC_CONDITION_H
+
+#include "hc_mutex.h"
+#include "hc_types.h"
+#include <semaphore.h>
+
+typedef struct HcConditionT {
+    int (*wait)(struct HcConditionT*);
+    void (*notify)(struct HcConditionT*);
+    int (*waitWithoutLock)(struct HcConditionT*);
+    void (*notifyWithoutLock)(struct HcConditionT*);
+    sem_t sem;
+} HcCondition;
+
+int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex);
+void DestroyHcCond(HcCondition* hcCond);
+
+#endif
diff -Naru deviceauth/hals/inc/liteos/hc_file.h deviceauth_new/hals/inc/liteos/hc_file.h
--- deviceauth/hals/inc/liteos/hc_file.h	2025-02-12 16:28:22.825860100 +0800
+++ deviceauth_new/hals/inc/liteos/hc_file.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,44 +1,44 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_FILE_H
-#define HC_FILE_H
-
-typedef struct {
-    union {
-        void *pfd;
-        int fd;
-    } fileHandle;
-    const char *filePath;
-} FileHandle;
-
-typedef enum FileIdEnumT {
-    FILE_ID_GROUP = 0,
-    FILE_ID_LAST,
-} FileIdEnum;
-
-#define MODE_FILE_READ 0
-#define MODE_FILE_WRITE 1
-
-/* 0 indicates success, -1 indicates fail */
-int HcFileOpen(int fileId, int mode, FileHandle *file);
-int HcFileSize(FileHandle file);
-int HcFileRead(FileHandle file, void *dst, int dstSize);
-int HcFileWrite(FileHandle file, const void *src, int srcSize);
-void HcFileClose(FileHandle file);
-void HcFileRemove(int fileId);
-void SetFilePath(FileIdEnum fileId, const char *path);
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_FILE_H
+#define HC_FILE_H
+
+typedef struct {
+    union {
+        void *pfd;
+        int fd;
+    } fileHandle;
+    const char *filePath;
+} FileHandle;
+
+typedef enum FileIdEnumT {
+    FILE_ID_GROUP = 0,
+    FILE_ID_LAST,
+} FileIdEnum;
+
+#define MODE_FILE_READ 0
+#define MODE_FILE_WRITE 1
+
+/* 0 indicates success, -1 indicates fail */
+int HcFileOpen(int fileId, int mode, FileHandle *file);
+int HcFileSize(FileHandle file);
+int HcFileRead(FileHandle file, void *dst, int dstSize);
+int HcFileWrite(FileHandle file, const void *src, int srcSize);
+void HcFileClose(FileHandle file);
+void HcFileRemove(int fileId);
+void SetFilePath(FileIdEnum fileId, const char *path);
+
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/liteos/hc_init_protection.h deviceauth_new/hals/inc/liteos/hc_init_protection.h
--- deviceauth/hals/inc/liteos/hc_init_protection.h	2025-02-12 16:28:22.862563100 +0800
+++ deviceauth_new/hals/inc/liteos/hc_init_protection.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,33 +1,33 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_INIT_PROTECTION_H
-#define HC_INIT_PROTECTION_H
-
-#include <stdio.h>
-
-typedef enum InitStatusEnum {
-    CONTINUE_INIT = 0,
-    FINISH_INIT,
-    CONTINUE_DESTROY,
-    FINISH_DESTROY,
-} InitStatus;
-
-int CheckInit(void);
-int CheckDestroy(void);
-void SetInitStatus(void);
-void SetDeInitStatus(void);
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_INIT_PROTECTION_H
+#define HC_INIT_PROTECTION_H
+
+#include <stdio.h>
+
+typedef enum InitStatusEnum {
+    CONTINUE_INIT = 0,
+    FINISH_INIT,
+    CONTINUE_DESTROY,
+    FINISH_DESTROY,
+} InitStatus;
+
+int CheckInit(void);
+int CheckDestroy(void);
+void SetInitStatus(void);
+void SetDeInitStatus(void);
+
 #endif 
\ No newline at end of file
diff -Naru deviceauth/hals/inc/liteos/hc_log.h deviceauth_new/hals/inc/liteos/hc_log.h
--- deviceauth/hals/inc/liteos/hc_log.h	2025-02-12 16:28:22.890836400 +0800
+++ deviceauth_new/hals/inc/liteos/hc_log.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,50 +1,50 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_LOG_H
-#define HC_LOG_H
-
-#include <inttypes.h>
-
-typedef enum {
-    DEV_AUTH_LOG_LEVEL_DEBUG = 0,
-    DEV_AUTH_LOG_LEVEL_INFO,
-    DEV_AUTH_LOG_LEVEL_WARN,
-    DEV_AUTH_LOG_LEVEL_ERROR
-} DevAuthLogLevel;
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void DevAuthLogPrint(DevAuthLogLevel level, const char *funName, const char *fmt, ...);
-
-#ifdef __cplusplus
-}
-#endif
-
-#include "log.h"
-
-#define LOGD(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_DEBUG, __FUNCTION__, fmt, ##__VA_ARGS__))
-#define LOGI(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_INFO, __FUNCTION__, fmt, ##__VA_ARGS__))
-#define LOGW(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_WARN, __FUNCTION__, fmt, ##__VA_ARGS__))
-#define LOGE(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_ERROR, __FUNCTION__, fmt, ##__VA_ARGS__))
-
-#define DEV_AUTH_LOG_DEBUG(buf) HILOG_DEBUG(HILOG_MODULE_SCY, "%{public}s", buf)
-#define DEV_AUTH_LOG_INFO(buf) HILOG_INFO(HILOG_MODULE_SCY, "%{public}s", buf)
-#define DEV_AUTH_LOG_WARN(buf) HILOG_WARN(HILOG_MODULE_SCY, "%{public}s", buf)
-#define DEV_AUTH_LOG_ERROR(buf) HILOG_ERROR(HILOG_MODULE_SCY, "%{public}s", buf)
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_LOG_H
+#define HC_LOG_H
+
+#include <inttypes.h>
+
+typedef enum {
+    DEV_AUTH_LOG_LEVEL_DEBUG = 0,
+    DEV_AUTH_LOG_LEVEL_INFO,
+    DEV_AUTH_LOG_LEVEL_WARN,
+    DEV_AUTH_LOG_LEVEL_ERROR
+} DevAuthLogLevel;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void DevAuthLogPrint(DevAuthLogLevel level, const char *funName, const char *fmt, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#include "log.h"
+
+#define LOGD(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_DEBUG, __FUNCTION__, fmt, ##__VA_ARGS__))
+#define LOGI(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_INFO, __FUNCTION__, fmt, ##__VA_ARGS__))
+#define LOGW(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_WARN, __FUNCTION__, fmt, ##__VA_ARGS__))
+#define LOGE(fmt, ...) (DevAuthLogPrint(DEV_AUTH_LOG_LEVEL_ERROR, __FUNCTION__, fmt, ##__VA_ARGS__))
+
+#define DEV_AUTH_LOG_DEBUG(buf) HILOG_DEBUG(HILOG_MODULE_SCY, "%{public}s", buf)
+#define DEV_AUTH_LOG_INFO(buf) HILOG_INFO(HILOG_MODULE_SCY, "%{public}s", buf)
+#define DEV_AUTH_LOG_WARN(buf) HILOG_WARN(HILOG_MODULE_SCY, "%{public}s", buf)
+#define DEV_AUTH_LOG_ERROR(buf) HILOG_ERROR(HILOG_MODULE_SCY, "%{public}s", buf)
+
+#endif
diff -Naru deviceauth/hals/inc/liteos/hc_mutex.h deviceauth_new/hals/inc/liteos/hc_mutex.h
--- deviceauth/hals/inc/liteos/hc_mutex.h	2025-02-12 16:28:22.922083300 +0800
+++ deviceauth_new/hals/inc/liteos/hc_mutex.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,31 +1,31 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_MUTEX_H
-#define HC_MUTEX_H
-
-#include "pthread.h"
-#include <stdint.h>
-
-typedef struct HcMutexT {
-    int (*lock)(struct HcMutexT* mutex);
-    void (*unlock)(struct HcMutexT* mutex);
-    pthread_mutex_t mutex;
-} HcMutex;
-
-int32_t InitHcMutex(HcMutex* mutex);
-void DestroyHcMutex(HcMutex* mutex);
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_MUTEX_H
+#define HC_MUTEX_H
+
+#include "pthread.h"
+#include <stdint.h>
+
+typedef struct HcMutexT {
+    int (*lock)(struct HcMutexT* mutex);
+    void (*unlock)(struct HcMutexT* mutex);
+    pthread_mutex_t mutex;
+} HcMutex;
+
+int32_t InitHcMutex(HcMutex* mutex);
+void DestroyHcMutex(HcMutex* mutex);
+
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/liteos/hc_thread.h deviceauth_new/hals/inc/liteos/hc_thread.h
--- deviceauth/hals/inc/liteos/hc_thread.h	2025-02-12 16:28:22.962755900 +0800
+++ deviceauth_new/hals/inc/liteos/hc_thread.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,44 +1,44 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_THREAD_H
-#define HC_THREAD_H
-
-#include "pthread.h"
-#include "hc_types.h"
-#include "hc_string.h"
-#include "hc_condition.h"
-
-typedef int (*ThreadFunc)(void*);
-
-typedef struct HcThreadT {
-    ThreadFunc threadFunc;
-    int (*start)(struct HcThreadT* thread);
-    void(*join)(struct HcThreadT* thread);
-    void (*wait)(struct HcThreadT* thread);
-    void (*notify)(struct HcThreadT* thread);
-    pthread_t thread;
-    size_t stackSize;
-    HcBool running;
-    HcString name;
-    HcCondition threadWaitObj;
-    HcMutex threadLock;
-    HcCondition bizWaitObj;
-} HcThread;
-
-int32_t InitThread(HcThread* thread, ThreadFunc func, size_t stackSize, const char* threadName);
-void DestroyThread(HcThread* thread);
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_THREAD_H
+#define HC_THREAD_H
+
+#include "pthread.h"
+#include "hc_types.h"
+#include "hc_string.h"
+#include "hc_condition.h"
+
+typedef int (*ThreadFunc)(void*);
+
+typedef struct HcThreadT {
+    ThreadFunc threadFunc;
+    int (*start)(struct HcThreadT* thread);
+    void(*join)(struct HcThreadT* thread);
+    void (*wait)(struct HcThreadT* thread);
+    void (*notify)(struct HcThreadT* thread);
+    pthread_t thread;
+    size_t stackSize;
+    HcBool running;
+    HcString name;
+    HcCondition threadWaitObj;
+    HcMutex threadLock;
+    HcCondition bizWaitObj;
+} HcThread;
+
+int32_t InitThread(HcThread* thread, ThreadFunc func, size_t stackSize, const char* threadName);
+void DestroyThread(HcThread* thread);
+
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/liteos/hc_time.h deviceauth_new/hals/inc/liteos/hc_time.h
--- deviceauth/hals/inc/liteos/hc_time.h	2025-02-12 16:28:22.991523000 +0800
+++ deviceauth_new/hals/inc/liteos/hc_time.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,30 +1,30 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_TIME_H
-#define HC_TIME_H
-
-#include <stdint.h>
-
- /* Calculate in seconds */
-#define TIME_OUT_VALUE 600
-
-/* Return in seconds */
-int64_t HcGetCurTime(void);
-
-/* Return the interval seconds from startTime to current Time */
-int64_t HcGetIntervalTime(int64_t startTime);
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_TIME_H
+#define HC_TIME_H
+
+#include <stdint.h>
+
+ /* Calculate in seconds */
+#define TIME_OUT_VALUE 600
+
+/* Return in seconds */
+int64_t HcGetCurTime(void);
+
+/* Return the interval seconds from startTime to current Time */
+int64_t HcGetIntervalTime(int64_t startTime);
+
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/inc/liteos/hc_types.h deviceauth_new/hals/inc/liteos/hc_types.h
--- deviceauth/hals/inc/liteos/hc_types.h	2025-02-12 16:28:23.022772500 +0800
+++ deviceauth_new/hals/inc/liteos/hc_types.h	2025-02-12 15:01:27.830543400 +0800
@@ -1,37 +1,37 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HC_TYPES_H
-#define HC_TYPES_H
-
-#include <string.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <securec.h>
-
-typedef uint32_t HcBool;
-#define HC_TRUE 1
-#define HC_FALSE 0
-
-#ifndef NULL
-#define NULL 0
-#endif
-
-void *HcMalloc(uint32_t size, char val);
-void HcFree(void *addr);
-uint32_t HcStrlen(const char *str);
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HC_TYPES_H
+#define HC_TYPES_H
+
+#include <string.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <securec.h>
+
+typedef uint32_t HcBool;
+#define HC_TRUE 1
+#define HC_FALSE 0
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+void *HcMalloc(uint32_t size, char val);
+void HcFree(void *addr);
+uint32_t HcStrlen(const char *str);
+
+#endif
diff -Naru deviceauth/hals/src/common/common_util.c deviceauth_new/hals/src/common/common_util.c
--- deviceauth/hals/src/common/common_util.c	2025-02-12 16:28:23.082291400 +0800
+++ deviceauth_new/hals/src/common/common_util.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,125 +1,125 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "common_util.h"
-#include <stdlib.h>
-#include <string.h>
-#include "hc_error.h"
-#include "hc_log.h"
-#include "hc_types.h"
-
-#define OUT_OF_HEX 16
-#define NUMBER_9_IN_DECIMAL 9
-
-static char HexToChar(uint8_t hex)
-{
-    return (hex > NUMBER_9_IN_DECIMAL) ? (hex + 0x37) : (hex + 0x30); /* Convert to the corresponding character */
-}
-
-int32_t ByteToHexString(const uint8_t *byte, uint32_t byteLen, char *hexStr, uint32_t hexLen)
-{
-    if (byte == NULL || hexStr == NULL) {
-        LOGE("Param is null ptr.");
-        return HAL_ERR_NULL_PTR;
-    }
-    /* The terminator('\0') needs 1 bit */
-    if (hexLen < byteLen * BYTE_TO_HEX_OPER_LENGTH + 1) {
-        LOGE("Invalid length");
-        return HAL_ERR_INVALID_LEN;
-    }
-
-    for (uint32_t i = 0; i < byteLen; i++) {
-        hexStr[i * BYTE_TO_HEX_OPER_LENGTH] = HexToChar((byte[i] & 0xF0) >> 4); /* 4: shift right for filling */
-        hexStr[i * BYTE_TO_HEX_OPER_LENGTH + 1] = HexToChar(byte[i] & 0x0F); /* get low four bits */
-    }
-    hexStr[byteLen * BYTE_TO_HEX_OPER_LENGTH] = '\0';
-
-    return HAL_SUCCESS;
-}
-
-static uint8_t CharToHex(char c)
-{
-    if ((c >= 'A') && (c <= 'F')) {
-        return (c - 'A' + DEC);
-    } else if ((c >= 'a') && (c <= 'f')) {
-        return (c - 'a' + DEC);
-    } else if ((c >= '0') && (c <= '9')) {
-        return (c - '0');
-    } else {
-        return OUT_OF_HEX;
-    }
-}
-
-int32_t HexStringToByte(const char *hexStr, uint8_t *byte, uint32_t byteLen)
-{
-    if (byte == NULL || hexStr == NULL) {
-        LOGE("Param is null ptr.");
-        return HAL_ERR_NULL_PTR;
-    }
-    uint32_t realHexLen = strlen(hexStr);
-    /* even number or not */
-    if (realHexLen % BYTE_TO_HEX_OPER_LENGTH != 0 || byteLen < realHexLen / BYTE_TO_HEX_OPER_LENGTH) {
-        return HAL_ERR_INVALID_LEN;
-    }
-
-    for (uint32_t i = 0; i < realHexLen / BYTE_TO_HEX_OPER_LENGTH; i++) {
-        uint8_t high = CharToHex(hexStr[i * BYTE_TO_HEX_OPER_LENGTH]);
-        uint8_t low = CharToHex(hexStr[i * BYTE_TO_HEX_OPER_LENGTH + 1]);
-        if (high == OUT_OF_HEX || low == OUT_OF_HEX) {
-            return HAL_ERR_INVALID_PARAM;
-        }
-        byte[i] = high << 4; /* 4: Set the high nibble */
-        byte[i] |= low; /* Set the low nibble */
-    }
-    return HAL_SUCCESS;
-}
-
-int64_t StringToInt64(const char *cp)
-{
-    if (cp == NULL) {
-        return 0;
-    }
-    return strtoll(cp, NULL, DEC);
-}
-
-void ConvertToAnnoymousStr(const char *originalStr, char **anonymousStr)
-{
-    if ((originalStr == NULL) || (anonymousStr == NULL)) {
-        return;
-    }
-    uint32_t desensitizationLen = 4;
-    uint32_t len = HcStrlen(originalStr);
-    if (len <= desensitizationLen) {
-        LOGD("The input string length is too short!");
-        return;
-    }
-    *anonymousStr = (char *)HcMalloc(len + 1, 0);
-    if ((*anonymousStr) == NULL) {
-        LOGD("Failed to allocate anonymousStr memory!");
-        return;
-    }
-    if (memset_s(*anonymousStr, len + 1, '*', len) != EOK) {
-        LOGD("Failed to memset string!");
-        HcFree(*anonymousStr);
-        *anonymousStr = NULL;
-        return;
-    }
-    if (memcpy_s(*anonymousStr, len + 1, originalStr, len - desensitizationLen) != EOK) {
-        LOGD("Failed to copy string!");
-        HcFree(*anonymousStr);
-        *anonymousStr = NULL;
-        return;
-    }
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "common_util.h"
+#include <stdlib.h>
+#include <string.h>
+#include "hc_error.h"
+#include "hc_log.h"
+#include "hc_types.h"
+
+#define OUT_OF_HEX 16
+#define NUMBER_9_IN_DECIMAL 9
+
+static char HexToChar(uint8_t hex)
+{
+    return (hex > NUMBER_9_IN_DECIMAL) ? (hex + 0x37) : (hex + 0x30); /* Convert to the corresponding character */
+}
+
+int32_t ByteToHexString(const uint8_t *byte, uint32_t byteLen, char *hexStr, uint32_t hexLen)
+{
+    if (byte == NULL || hexStr == NULL) {
+        LOGE("Param is null ptr.");
+        return HAL_ERR_NULL_PTR;
+    }
+    /* The terminator('\0') needs 1 bit */
+    if (hexLen < byteLen * BYTE_TO_HEX_OPER_LENGTH + 1) {
+        LOGE("Invalid length");
+        return HAL_ERR_INVALID_LEN;
+    }
+
+    for (uint32_t i = 0; i < byteLen; i++) {
+        hexStr[i * BYTE_TO_HEX_OPER_LENGTH] = HexToChar((byte[i] & 0xF0) >> 4); /* 4: shift right for filling */
+        hexStr[i * BYTE_TO_HEX_OPER_LENGTH + 1] = HexToChar(byte[i] & 0x0F); /* get low four bits */
+    }
+    hexStr[byteLen * BYTE_TO_HEX_OPER_LENGTH] = '\0';
+
+    return HAL_SUCCESS;
+}
+
+static uint8_t CharToHex(char c)
+{
+    if ((c >= 'A') && (c <= 'F')) {
+        return (c - 'A' + DEC);
+    } else if ((c >= 'a') && (c <= 'f')) {
+        return (c - 'a' + DEC);
+    } else if ((c >= '0') && (c <= '9')) {
+        return (c - '0');
+    } else {
+        return OUT_OF_HEX;
+    }
+}
+
+int32_t HexStringToByte(const char *hexStr, uint8_t *byte, uint32_t byteLen)
+{
+    if (byte == NULL || hexStr == NULL) {
+        LOGE("Param is null ptr.");
+        return HAL_ERR_NULL_PTR;
+    }
+    uint32_t realHexLen = strlen(hexStr);
+    /* even number or not */
+    if (realHexLen % BYTE_TO_HEX_OPER_LENGTH != 0 || byteLen < realHexLen / BYTE_TO_HEX_OPER_LENGTH) {
+        return HAL_ERR_INVALID_LEN;
+    }
+
+    for (uint32_t i = 0; i < realHexLen / BYTE_TO_HEX_OPER_LENGTH; i++) {
+        uint8_t high = CharToHex(hexStr[i * BYTE_TO_HEX_OPER_LENGTH]);
+        uint8_t low = CharToHex(hexStr[i * BYTE_TO_HEX_OPER_LENGTH + 1]);
+        if (high == OUT_OF_HEX || low == OUT_OF_HEX) {
+            return HAL_ERR_INVALID_PARAM;
+        }
+        byte[i] = high << 4; /* 4: Set the high nibble */
+        byte[i] |= low; /* Set the low nibble */
+    }
+    return HAL_SUCCESS;
+}
+
+int64_t StringToInt64(const char *cp)
+{
+    if (cp == NULL) {
+        return 0;
+    }
+    return strtoll(cp, NULL, DEC);
+}
+
+void ConvertToAnnoymousStr(const char *originalStr, char **anonymousStr)
+{
+    if ((originalStr == NULL) || (anonymousStr == NULL)) {
+        return;
+    }
+    int desensitizationLen = 4;
+    uint32_t len = HcStrlen(originalStr);
+    if (len <= desensitizationLen) {
+        LOGD("The input string length is too short!");
+        return;
+    }
+    *anonymousStr = (char *)HcMalloc(len + 1, 0);
+    if ((*anonymousStr) == NULL) {
+        LOGD("Failed to allocate anonymousStr memory!");
+        return;
+    }
+    if (memset_s(*anonymousStr, len + 1, '*', len) != EOK) {
+        LOGD("Failed to memset string!");
+        HcFree(*anonymousStr);
+        *anonymousStr = NULL;
+        return;
+    }
+    if (memcpy_s(*anonymousStr, len + 1, originalStr, len - desensitizationLen) != EOK) {
+        LOGD("Failed to copy string!");
+        HcFree(*anonymousStr);
+        *anonymousStr = NULL;
+        return;
+    }
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/common/hc_parcel.c deviceauth_new/hals/src/common/hc_parcel.c
--- deviceauth/hals/src/common/hc_parcel.c	2025-02-12 16:28:23.159172100 +0800
+++ deviceauth_new/hals/src/common/hc_parcel.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,557 +1,557 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_parcel.h"
-#include "hc_log.h"
-#include "securec.h"
-
-const int PARCEL_DEFAULT_INCREASE_STEP = 16;
-const uint32_t PARCEL_UINT_MAX = 0xffffffffU;
-
-HcParcel CreateParcel(uint32_t size, uint32_t allocUnit)
-{
-    HcParcel parcel;
-    (void)memset_s(&parcel, sizeof(parcel), 0, sizeof(parcel));
-    parcel.allocUnit = allocUnit;
-    if (parcel.allocUnit == 0) {
-        parcel.allocUnit = PARCEL_DEFAULT_INCREASE_STEP;
-    }
-    if (size > 0) {
-        parcel.data = (char*)HcMalloc(size, 0);
-        if (parcel.data != NULL) {
-            parcel.length = size;
-        }
-    }
-    return parcel;
-}
-
-void DeleteParcel(HcParcel *parcel)
-{
-    if (parcel == NULL) {
-        return;
-    }
-
-    if (parcel->data != NULL) {
-        HcFree(parcel->data);
-        parcel->data = 0;
-    }
-    parcel->length = 0;
-    parcel->beginPos = 0;
-    parcel->endPos = 0;
-}
-
-void ClearParcel(HcParcel *parcel)
-{
-    if (parcel != NULL) {
-        parcel->beginPos = 0;
-        parcel->endPos = 0;
-    }
-}
-
-void ResetParcel(HcParcel *parcel, uint32_t size, uint32_t allocUnit)
-{
-    if (parcel != NULL) {
-        DeleteParcel(parcel);
-        HcParcel newParcel = CreateParcel(size, allocUnit);
-        (void)memcpy_s(parcel, sizeof(HcParcel), &newParcel, sizeof(HcParcel));
-    }
-}
-
-uint32_t GetParcelDataSize(const HcParcel *parcel)
-{
-    if (parcel == NULL) {
-        return 0;
-    }
-    if (parcel->endPos >= parcel->beginPos) {
-        return parcel->endPos - parcel->beginPos;
-    }
-    return 0;
-}
-
-const char *GetParcelData(const HcParcel *parcel)
-{
-    if (parcel == NULL) {
-        return NULL;
-    }
-    return parcel->data + parcel->beginPos;
-}
-
-const char* GetParcelLastChar(const HcParcel *parcel)
-{
-    if (parcel == NULL || GetParcelDataSize(parcel) == 0) {
-        return NULL;
-    }
-    return parcel->data + parcel->endPos - 1;
-}
-
-HcBool ParcelReadWithoutPopData(HcParcel *parcel, void *dst, uint32_t dataSize)
-{
-#ifdef IS_BIG_ENDIAN
-    HcBool ret = ParcelReadRevert(parcel, dst, dataSize);
-#else
-    HcBool ret = ParcelRead(parcel, dst, dataSize);
-#endif
-    if (ret == HC_TRUE) {
-        parcel->beginPos -= dataSize;
-    }
-    return ret;
-}
-
-HcBool ParcelRead(HcParcel *parcel, void *dst, uint32_t dataSize)
-{
-    errno_t rc;
-    if (parcel == NULL || dst == NULL || dataSize == 0) {
-        LOGE("%s: Bad Parameters!", __func__);
-        return HC_FALSE;
-    }
-    if (parcel->beginPos > PARCEL_UINT_MAX - dataSize) {
-        LOGE("%s: Bad Parameters!", __func__);
-        return HC_FALSE;
-    }
-    if (parcel->beginPos + dataSize > parcel->endPos) {
-        LOGI("%s: parcel size < dataSize you want to read: parcel size %d while dataSize %u!",
-            __func__, GetParcelDataSize(parcel), dataSize);
-        return HC_FALSE;
-    }
-    rc = memmove_s(dst, dataSize, parcel->data + parcel->beginPos, dataSize);
-    if (rc != EOK) {
-        LOGE("%s: get data failed:%d.\n", __func__, rc);
-        return HC_FALSE;
-    }
-    parcel->beginPos += dataSize;
-    return HC_TRUE;
-}
-
-HcBool ParcelEraseBlock(HcParcel *parcel, uint32_t start, uint32_t dataSize, void *dst)
-{
-    errno_t rc;
-    if (parcel == NULL || dst == NULL || dataSize == 0) {
-        LOGE("%s: Bad Parameters!", __func__);
-        return HC_FALSE;
-    }
-    if (start > PARCEL_UINT_MAX - dataSize) {
-        return HC_FALSE;
-    }
-    uint32_t parcelSizeOrg = GetParcelDataSize(parcel);
-    if (parcelSizeOrg < start + dataSize) {
-        return HC_FALSE;
-    }
-    char *beginCopy = parcel->data + parcel->beginPos + start;
-    uint32_t copySize = parcelSizeOrg - start - dataSize;
-
-    rc = memmove_s(dst, dataSize, beginCopy, dataSize);
-    if (rc != EOK) {
-        LOGE("%s: get data failed:%d.\n", __func__, rc);
-        return HC_FALSE;
-    }
-    if (copySize != 0) {
-        rc = memmove_s(beginCopy, copySize, beginCopy + dataSize, copySize);
-        if (rc != EOK) {
-            LOGE("%s: copy data failed:%d.\n", __func__, rc);
-            return HC_FALSE;
-        }
-    }
-    parcel->endPos -= dataSize;
-    return HC_TRUE;
-}
-
-
-HcBool ParcelReadRevert(HcParcel *parcel, void *dst, uint32_t dataSize)
-{
-    if (ParcelRead(parcel, dst, dataSize)) {
-        DataRevert(dst, dataSize);
-        return HC_TRUE;
-    } else {
-        return HC_FALSE;
-    }
-}
-
-HcBool ParcelWriteRevert(HcParcel *parcel, const void *src, uint32_t dataSize)
-{
-    errno_t rc;
-    void *srcCopy = HcMalloc(dataSize, 0);
-    if (srcCopy == NULL) {
-        return HC_FALSE;
-    }
-    rc = memmove_s(srcCopy, dataSize, src, dataSize);
-    if (rc != EOK) {
-        HcFree(srcCopy);
-        return HC_FALSE;
-    }
-    DataRevert(srcCopy, dataSize);
-    HcBool ret = ParcelWrite(parcel, srcCopy,  dataSize);
-    HcFree(srcCopy);
-    return ret;
-}
-
-HcBool ParcelReadInt32(HcParcel *parcel, int *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(int));
-}
-
-HcBool ParcelReadUint32(HcParcel *parcel, uint32_t *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(uint32_t));
-}
-
-HcBool ParcelReadInt16(HcParcel *parcel, short *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(short));
-}
-
-HcBool ParcelReadUint16(HcParcel *parcel, uint16_t *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(uint16_t));
-}
-
-HcBool ParcelReadInt8(HcParcel *parcel, char *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(char));
-}
-
-HcBool ParcelReadUint8(HcParcel *parcel, uint8_t *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(uint8_t));
-}
-
-HcBool ParcelReadUint64(HcParcel *parcel, uint64_t *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(uint64_t));
-}
-
-HcBool ParcelReadInt64(HcParcel *parcel, int64_t *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(int64_t));
-}
-
-static HcBool ParcelRealloc(HcParcel *parcel, uint32_t size)
-{
-    if (parcel->length >= size) {
-        LOGE("%s: ParcelRealloc failed, length is too big", __func__);
-        return HC_FALSE;
-    }
-    char *newData = (char*)HcMalloc(size, 0);
-    if (newData == NULL) {
-        LOGE("%s: ParcelRealloc failed, out of memory", __func__);
-        return HC_FALSE;
-    }
-    if (memcpy_s(newData, size, parcel->data, parcel->length) != EOK) {
-        HcFree(newData);
-        return HC_FALSE;
-    }
-    HcFree(parcel->data);
-    parcel->data = newData;
-    parcel->length = size;
-    return HC_TRUE;
-}
-
-static HcBool ParcelIncrease(HcParcel *parcel, uint32_t size)
-{
-    if (parcel == NULL || size == 0) {
-        LOGE("%s: ParcelIncrease, invalid parameter", __func__);
-        return HC_FALSE;
-    }
-    if (parcel->data == NULL) {
-        if (parcel->length != 0) {
-            LOGE("%s: ParcelIncrease faile, invalid length", __func__);
-            return HC_FALSE;
-        }
-        (*parcel) = CreateParcel(size, parcel->allocUnit);
-        if (parcel->data == NULL) {
-            LOGE("%s: ParcelIncrease failed, create parcel failed", __func__);
-            return HC_FALSE;
-        } else {
-            return HC_TRUE;
-        }
-    } else {
-        return ParcelRealloc(parcel, size);
-    }
-}
-
-static void ParcelRecycle(HcParcel *parcel)
-{
-    if (parcel == NULL) {
-        return;
-    }
-    if (parcel->data == NULL || parcel->beginPos < parcel->allocUnit) {
-        return;
-    }
-
-    uint32_t contentSize = parcel->endPos - parcel->beginPos;
-    if (contentSize > 0) {
-        if (memmove_s(parcel->data, parcel->endPos - parcel->beginPos,
-            parcel->data + parcel->beginPos, parcel->endPos - parcel->beginPos) != EOK) {
-            LOGE("Move parcel's data failed.");
-        }
-    }
-    parcel->beginPos = 0;
-    parcel->endPos = contentSize;
-}
-
-static uint32_t GetParcelIncreaseSize(HcParcel *parcel, uint32_t newSize)
-{
-    if (parcel == NULL || parcel->allocUnit == 0) {
-        return 0;
-    }
-    if (newSize % parcel->allocUnit) {
-        return (newSize / parcel->allocUnit + 1) * parcel->allocUnit;
-    } else {
-        return (newSize / parcel->allocUnit) * parcel->allocUnit;
-    }
-}
-
-HcBool ParcelWrite(HcParcel *parcel, const void *src, uint32_t dataSize)
-{
-    errno_t rc;
-    if (parcel == NULL || src == NULL || dataSize == 0) {
-        LOGE("%s: Bad Parameters!", __func__);
-        return HC_FALSE;
-    }
-    if (parcel->endPos > PARCEL_UINT_MAX - dataSize) {
-        LOGE("%s: Bad Parameters overflow!", __func__);
-        return HC_FALSE;
-    }
-    if (parcel->endPos + dataSize > parcel->length) {
-        ParcelRecycle(parcel);
-        if (parcel->endPos + dataSize > parcel->length) {
-            uint32_t newSize = GetParcelIncreaseSize(parcel, parcel->endPos + dataSize);
-            if (!ParcelIncrease(parcel, newSize)) {
-                LOGE("%s: ParcelIncrease failed", __func__);
-                return HC_FALSE;
-            }
-        }
-    }
-    rc = memmove_s(parcel->data + parcel->endPos, dataSize, src, dataSize);
-    if (rc != EOK) {
-        LOGE("%s: get data failed:%d.\n", __func__, rc);
-        return HC_FALSE;
-    }
-    parcel->endPos += dataSize;
-    return HC_TRUE;
-}
-
-HcBool ParcelWriteInt32(HcParcel *parcel, int src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelWriteUint32(HcParcel *parcel, uint32_t src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelWriteInt16(HcParcel *parcel, short src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelWriteUint16(HcParcel *parcel, uint16_t src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelWriteInt8(HcParcel *parcel, char src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelWriteUint8(HcParcel *parcel, uint8_t src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelWriteUint64(HcParcel *parcel, uint64_t src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelWriteInt64(HcParcel *parcel, int64_t src)
-{
-    return ParcelWrite(parcel, &src, sizeof(src));
-}
-
-HcBool ParcelReadParcel(HcParcel *src, HcParcel *dst, uint32_t size, HcBool copy)
-{
-    if (src == NULL || dst == NULL) {
-        return HC_FALSE;
-    }
-    if (GetParcelDataSize(src) < size) {
-        return HC_FALSE;
-    }
-    if (!ParcelWrite(dst, (void*)GetParcelData(src), size)) {
-        return HC_FALSE;
-    }
-
-    if (!copy) {
-        src->beginPos += size;
-    }
-    return HC_TRUE;
-}
-
-HcBool ParcelCopy(HcParcel *src, HcParcel *dst)
-{
-    if (src == NULL || dst == NULL) {
-        return HC_FALSE;
-    }
-    if (GetParcelDataSize(src) == 0) {
-        return HC_TRUE;
-    }
-    return ParcelReadParcel(src, dst, GetParcelDataSize(src), HC_TRUE);
-}
-
-void DataRevert(void *data, uint32_t length)
-{
-    if (data != NULL) {
-        uint8_t *pc = (uint8_t *) data;
-        uint32_t i = 0;
-        for (; i < length / 2; ++i) { /* half of the length */
-            /* swap p[i] and p[length-i-1] */
-            pc[i] ^= pc[length - i - 1];
-            pc[length - i - 1] ^= pc[i];
-            pc[i] ^= pc[length - i - 1];
-        }
-    }
-}
-
-HcBool ParcelReadInt32Revert(HcParcel *parcel, int32_t *dst)
-{
-    HcBool ret = ParcelRead(parcel, dst, sizeof(int));
-    if (ret) {
-        DataRevert(dst, sizeof(int));
-    }
-    return ret;
-}
-
-HcBool ParcelReadUint32Revert(HcParcel *parcel, uint32_t *dst)
-{
-    HcBool ret = ParcelRead(parcel, dst, sizeof(uint32_t));
-    if (ret) {
-        DataRevert(dst, sizeof(uint32_t));
-    }
-    return ret;
-}
-
-HcBool ParcelReadInt16Revert(HcParcel *parcel, short *dst)
-{
-    HcBool ret = ParcelRead(parcel, dst, sizeof(short));
-    if (ret) {
-        DataRevert(dst, sizeof(short));
-    }
-    return ret;
-}
-
-HcBool ParcelReadUint16Revert(HcParcel *parcel, uint16_t *dst)
-{
-    if (parcel == NULL || dst == NULL) {
-        return HC_FALSE;
-    }
-    HcBool ret = ParcelRead(parcel, dst, sizeof(uint16_t));
-    if (ret) {
-        DataRevert(dst, sizeof(uint16_t));
-    }
-    return ret;
-}
-
-HcBool ParcelReadInt8Revert(HcParcel *parcel, char *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(char));
-}
-
-HcBool ParcelReadUint8Revert(HcParcel *parcel, uint8_t *dst)
-{
-    return ParcelRead(parcel, dst, sizeof(uint8_t));
-}
-
-HcBool ParcelReadUint64Revert(HcParcel *parcel, uint64_t *dst)
-{
-    HcBool ret = ParcelRead(parcel, dst, sizeof(uint64_t));
-    if (ret) {
-        DataRevert(dst, sizeof(uint64_t));
-    }
-    return ret;
-}
-
-HcBool ParcelReadInt64Revert(HcParcel *parcel, int64_t *dst)
-{
-    HcBool ret = ParcelRead(parcel, dst, sizeof(int64_t));
-    if (ret) {
-        DataRevert(dst, sizeof(int64_t));
-    }
-    return ret;
-}
-
-HcBool ParcelWriteInt32Revert(HcParcel *parcel, int src)
-{
-    DataRevert(&src, sizeof(src));
-    return ParcelWriteInt32(parcel, src);
-}
-
-HcBool ParcelWriteUint32Revert(HcParcel *parcel, uint32_t src)
-{
-    DataRevert(&src, sizeof(src));
-    return ParcelWriteUint32(parcel, src);
-}
-
-HcBool ParcelWriteInt16Revert(HcParcel *parcel, short src)
-{
-    DataRevert(&src, sizeof(src));
-    return ParcelWriteInt16(parcel, src);
-}
-
-HcBool ParcelWriteUint16Revert(HcParcel *parcel, uint16_t src)
-{
-    DataRevert(&src, sizeof(src));
-    return ParcelWriteUint16(parcel, src);
-}
-
-HcBool ParcelWriteInt8Revert(HcParcel *parcel, char src)
-{
-    return ParcelWriteInt8(parcel, src);
-}
-
-HcBool ParcelWriteUint8Revert(HcParcel *parcel, uint8_t src)
-{
-    return ParcelWriteUint8(parcel, src);
-}
-
-HcBool ParcelWriteUint64Revert(HcParcel *parcel, uint64_t src)
-{
-    DataRevert(&src, sizeof(src));
-    return ParcelWriteUint64(parcel, src);
-}
-
-HcBool ParcelWriteInt64Revert(HcParcel *parcel, int64_t src)
-{
-    DataRevert(&src, sizeof(src));
-    return ParcelWriteInt64(parcel, src);
-}
-
-HcBool ParcelPopBack(HcParcel *parcel, uint32_t size)
-{
-    if (parcel != NULL && size > 0 && GetParcelDataSize(parcel) >= size) {
-        parcel->endPos -= size;
-        return HC_TRUE;
-    }
-    return HC_FALSE;
-}
-
-HcBool ParcelPopFront(HcParcel *parcel, uint32_t size)
-{
-    if ((parcel != NULL) && (size > 0) && (GetParcelDataSize(parcel) >= size)) {
-        parcel->beginPos += size;
-        return HC_TRUE;
-    }
-    return HC_FALSE;
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_parcel.h"
+#include "hc_log.h"
+#include "securec.h"
+
+const int PARCEL_DEFAULT_INCREASE_STEP = 16;
+const uint32_t PARCEL_UINT_MAX = 0xffffffffU;
+
+HcParcel CreateParcel(uint32_t size, uint32_t allocUnit)
+{
+    HcParcel parcel;
+    (void)memset_s(&parcel, sizeof(parcel), 0, sizeof(parcel));
+    parcel.allocUnit = allocUnit;
+    if (parcel.allocUnit == 0) {
+        parcel.allocUnit = PARCEL_DEFAULT_INCREASE_STEP;
+    }
+    if (size > 0) {
+        parcel.data = (char*)HcMalloc(size, 0);
+        if (parcel.data != NULL) {
+            parcel.length = size;
+        }
+    }
+    return parcel;
+}
+
+void DeleteParcel(HcParcel *parcel)
+{
+    if (parcel == NULL) {
+        return;
+    }
+
+    if (parcel->data != NULL) {
+        HcFree(parcel->data);
+        parcel->data = 0;
+    }
+    parcel->length = 0;
+    parcel->beginPos = 0;
+    parcel->endPos = 0;
+}
+
+void ClearParcel(HcParcel *parcel)
+{
+    if (parcel != NULL) {
+        parcel->beginPos = 0;
+        parcel->endPos = 0;
+    }
+}
+
+void ResetParcel(HcParcel *parcel, uint32_t size, uint32_t allocUnit)
+{
+    if (parcel != NULL) {
+        DeleteParcel(parcel);
+        HcParcel newParcel = CreateParcel(size, allocUnit);
+        (void)memcpy_s(parcel, sizeof(HcParcel), &newParcel, sizeof(HcParcel));
+    }
+}
+
+uint32_t GetParcelDataSize(const HcParcel *parcel)
+{
+    if (parcel == NULL) {
+        return 0;
+    }
+    if (parcel->endPos >= parcel->beginPos) {
+        return parcel->endPos - parcel->beginPos;
+    }
+    return 0;
+}
+
+const char *GetParcelData(const HcParcel *parcel)
+{
+    if (parcel == NULL) {
+        return NULL;
+    }
+    return parcel->data + parcel->beginPos;
+}
+
+const char* GetParcelLastChar(const HcParcel *parcel)
+{
+    if (parcel == NULL || GetParcelDataSize(parcel) == 0) {
+        return NULL;
+    }
+    return parcel->data + parcel->endPos - 1;
+}
+
+HcBool ParcelReadWithoutPopData(HcParcel *parcel, void *dst, uint32_t dataSize)
+{
+#ifdef IS_BIG_ENDIAN
+    HcBool ret = ParcelReadRevert(parcel, dst, dataSize);
+#else
+    HcBool ret = ParcelRead(parcel, dst, dataSize);
+#endif
+    if (ret == HC_TRUE) {
+        parcel->beginPos -= dataSize;
+    }
+    return ret;
+}
+
+HcBool ParcelRead(HcParcel *parcel, void *dst, uint32_t dataSize)
+{
+    errno_t rc;
+    if (parcel == NULL || dst == NULL || dataSize == 0) {
+        LOGE("%s: Bad Parameters!", __func__);
+        return HC_FALSE;
+    }
+    if (parcel->beginPos > PARCEL_UINT_MAX - dataSize) {
+        LOGE("%s: Bad Parameters!", __func__);
+        return HC_FALSE;
+    }
+    if (parcel->beginPos + dataSize > parcel->endPos) {
+        LOGI("%s: parcel size < dataSize you want to read: parcel size %d while dataSize %u!",
+            __func__, GetParcelDataSize(parcel), dataSize);
+        return HC_FALSE;
+    }
+    rc = memmove_s(dst, dataSize, parcel->data + parcel->beginPos, dataSize);
+    if (rc != EOK) {
+        LOGE("%s: get data failed:%d.\n", __func__, rc);
+        return HC_FALSE;
+    }
+    parcel->beginPos += dataSize;
+    return HC_TRUE;
+}
+
+HcBool ParcelEraseBlock(HcParcel *parcel, uint32_t start, uint32_t dataSize, void *dst)
+{
+    errno_t rc;
+    if (parcel == NULL || dst == NULL || dataSize == 0) {
+        LOGE("%s: Bad Parameters!", __func__);
+        return HC_FALSE;
+    }
+    if (start > PARCEL_UINT_MAX - dataSize) {
+        return HC_FALSE;
+    }
+    uint32_t parcelSizeOrg = GetParcelDataSize(parcel);
+    if (parcelSizeOrg < start + dataSize) {
+        return HC_FALSE;
+    }
+    char *beginCopy = parcel->data + parcel->beginPos + start;
+    uint32_t copySize = parcelSizeOrg - start - dataSize;
+
+    rc = memmove_s(dst, dataSize, beginCopy, dataSize);
+    if (rc != EOK) {
+        LOGE("%s: get data failed:%d.\n", __func__, rc);
+        return HC_FALSE;
+    }
+    if (copySize != 0) {
+        rc = memmove_s(beginCopy, copySize, beginCopy + dataSize, copySize);
+        if (rc != EOK) {
+            LOGE("%s: copy data failed:%d.\n", __func__, rc);
+            return HC_FALSE;
+        }
+    }
+    parcel->endPos -= dataSize;
+    return HC_TRUE;
+}
+
+
+HcBool ParcelReadRevert(HcParcel *parcel, void *dst, uint32_t dataSize)
+{
+    if (ParcelRead(parcel, dst, dataSize)) {
+        DataRevert(dst, dataSize);
+        return HC_TRUE;
+    } else {
+        return HC_FALSE;
+    }
+}
+
+HcBool ParcelWriteRevert(HcParcel *parcel, const void *src, uint32_t dataSize)
+{
+    errno_t rc;
+    void *srcCopy = HcMalloc(dataSize, 0);
+    if (srcCopy == NULL) {
+        return HC_FALSE;
+    }
+    rc = memmove_s(srcCopy, dataSize, src, dataSize);
+    if (rc != EOK) {
+        HcFree(srcCopy);
+        return HC_FALSE;
+    }
+    DataRevert(srcCopy, dataSize);
+    HcBool ret = ParcelWrite(parcel, srcCopy,  dataSize);
+    HcFree(srcCopy);
+    return ret;
+}
+
+HcBool ParcelReadInt32(HcParcel *parcel, int *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(int));
+}
+
+HcBool ParcelReadUint32(HcParcel *parcel, uint32_t *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(uint32_t));
+}
+
+HcBool ParcelReadInt16(HcParcel *parcel, short *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(short));
+}
+
+HcBool ParcelReadUint16(HcParcel *parcel, uint16_t *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(uint16_t));
+}
+
+HcBool ParcelReadInt8(HcParcel *parcel, char *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(char));
+}
+
+HcBool ParcelReadUint8(HcParcel *parcel, uint8_t *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(uint8_t));
+}
+
+HcBool ParcelReadUint64(HcParcel *parcel, uint64_t *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(uint64_t));
+}
+
+HcBool ParcelReadInt64(HcParcel *parcel, int64_t *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(int64_t));
+}
+
+static HcBool ParcelRealloc(HcParcel *parcel, uint32_t size)
+{
+    if (parcel->length >= size) {
+        LOGE("%s: ParcelRealloc failed, length is too big", __func__);
+        return HC_FALSE;
+    }
+    char *newData = (char*)HcMalloc(size, 0);
+    if (newData == NULL) {
+        LOGE("%s: ParcelRealloc failed, out of memory", __func__);
+        return HC_FALSE;
+    }
+    if (memcpy_s(newData, size, parcel->data, parcel->length) != EOK) {
+        HcFree(newData);
+        return HC_FALSE;
+    }
+    HcFree(parcel->data);
+    parcel->data = newData;
+    parcel->length = size;
+    return HC_TRUE;
+}
+
+static HcBool ParcelIncrease(HcParcel *parcel, uint32_t size)
+{
+    if (parcel == NULL || size == 0) {
+        LOGE("%s: ParcelIncrease, invalid parameter", __func__);
+        return HC_FALSE;
+    }
+    if (parcel->data == NULL) {
+        if (parcel->length != 0) {
+            LOGE("%s: ParcelIncrease faile, invalid length", __func__);
+            return HC_FALSE;
+        }
+        (*parcel) = CreateParcel(size, parcel->allocUnit);
+        if (parcel->data == NULL) {
+            LOGE("%s: ParcelIncrease failed, create parcel failed", __func__);
+            return HC_FALSE;
+        } else {
+            return HC_TRUE;
+        }
+    } else {
+        return ParcelRealloc(parcel, size);
+    }
+}
+
+static void ParcelRecycle(HcParcel *parcel)
+{
+    if (parcel == NULL) {
+        return;
+    }
+    if (parcel->data == NULL || parcel->beginPos < parcel->allocUnit) {
+        return;
+    }
+
+    uint32_t contentSize = parcel->endPos - parcel->beginPos;
+    if (contentSize > 0) {
+        if (memmove_s(parcel->data, parcel->endPos - parcel->beginPos,
+            parcel->data + parcel->beginPos, parcel->endPos - parcel->beginPos) != EOK) {
+            LOGE("Move parcel's data failed.");
+        }
+    }
+    parcel->beginPos = 0;
+    parcel->endPos = contentSize;
+}
+
+static uint32_t GetParcelIncreaseSize(HcParcel *parcel, uint32_t newSize)
+{
+    if (parcel == NULL || parcel->allocUnit == 0) {
+        return 0;
+    }
+    if (newSize % parcel->allocUnit) {
+        return (newSize / parcel->allocUnit + 1) * parcel->allocUnit;
+    } else {
+        return (newSize / parcel->allocUnit) * parcel->allocUnit;
+    }
+}
+
+HcBool ParcelWrite(HcParcel *parcel, const void *src, uint32_t dataSize)
+{
+    errno_t rc;
+    if (parcel == NULL || src == NULL || dataSize == 0) {
+        LOGE("%s: Bad Parameters!", __func__);
+        return HC_FALSE;
+    }
+    if (parcel->endPos > PARCEL_UINT_MAX - dataSize) {
+        LOGE("%s: Bad Parameters overflow!", __func__);
+        return HC_FALSE;
+    }
+    if (parcel->endPos + dataSize > parcel->length) {
+        ParcelRecycle(parcel);
+        if (parcel->endPos + dataSize > parcel->length) {
+            uint32_t newSize = GetParcelIncreaseSize(parcel, parcel->endPos + dataSize);
+            if (!ParcelIncrease(parcel, newSize)) {
+                LOGE("%s: ParcelIncrease failed", __func__);
+                return HC_FALSE;
+            }
+        }
+    }
+    rc = memmove_s(parcel->data + parcel->endPos, dataSize, src, dataSize);
+    if (rc != EOK) {
+        LOGE("%s: get data failed:%d.\n", __func__, rc);
+        return HC_FALSE;
+    }
+    parcel->endPos += dataSize;
+    return HC_TRUE;
+}
+
+HcBool ParcelWriteInt32(HcParcel *parcel, int src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelWriteUint32(HcParcel *parcel, uint32_t src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelWriteInt16(HcParcel *parcel, short src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelWriteUint16(HcParcel *parcel, uint16_t src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelWriteInt8(HcParcel *parcel, char src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelWriteUint8(HcParcel *parcel, uint8_t src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelWriteUint64(HcParcel *parcel, uint64_t src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelWriteInt64(HcParcel *parcel, int64_t src)
+{
+    return ParcelWrite(parcel, &src, sizeof(src));
+}
+
+HcBool ParcelReadParcel(HcParcel *src, HcParcel *dst, uint32_t size, HcBool copy)
+{
+    if (src == NULL || dst == NULL) {
+        return HC_FALSE;
+    }
+    if (GetParcelDataSize(src) < size) {
+        return HC_FALSE;
+    }
+    if (!ParcelWrite(dst, (void*)GetParcelData(src), size)) {
+        return HC_FALSE;
+    }
+
+    if (!copy) {
+        src->beginPos += size;
+    }
+    return HC_TRUE;
+}
+
+HcBool ParcelCopy(HcParcel *src, HcParcel *dst)
+{
+    if (src == NULL || dst == NULL) {
+        return HC_FALSE;
+    }
+    if (GetParcelDataSize(src) == 0) {
+        return HC_TRUE;
+    }
+    return ParcelReadParcel(src, dst, GetParcelDataSize(src), HC_TRUE);
+}
+
+void DataRevert(void *data, uint32_t length)
+{
+    if (data != NULL) {
+        uint8_t *pc = (uint8_t *) data;
+        uint32_t i = 0;
+        for (; i < length / 2; ++i) { /* half of the length */
+            /* swap p[i] and p[length-i-1] */
+            pc[i] ^= pc[length - i - 1];
+            pc[length - i - 1] ^= pc[i];
+            pc[i] ^= pc[length - i - 1];
+        }
+    }
+}
+
+HcBool ParcelReadInt32Revert(HcParcel *parcel, int32_t *dst)
+{
+    HcBool ret = ParcelRead(parcel, dst, sizeof(int));
+    if (ret) {
+        DataRevert(dst, sizeof(int));
+    }
+    return ret;
+}
+
+HcBool ParcelReadUint32Revert(HcParcel *parcel, uint32_t *dst)
+{
+    HcBool ret = ParcelRead(parcel, dst, sizeof(uint32_t));
+    if (ret) {
+        DataRevert(dst, sizeof(uint32_t));
+    }
+    return ret;
+}
+
+HcBool ParcelReadInt16Revert(HcParcel *parcel, short *dst)
+{
+    HcBool ret = ParcelRead(parcel, dst, sizeof(short));
+    if (ret) {
+        DataRevert(dst, sizeof(short));
+    }
+    return ret;
+}
+
+HcBool ParcelReadUint16Revert(HcParcel *parcel, uint16_t *dst)
+{
+    if (parcel == NULL || dst == NULL) {
+        return HC_FALSE;
+    }
+    HcBool ret = ParcelRead(parcel, dst, sizeof(uint16_t));
+    if (ret) {
+        DataRevert(dst, sizeof(uint16_t));
+    }
+    return ret;
+}
+
+HcBool ParcelReadInt8Revert(HcParcel *parcel, char *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(char));
+}
+
+HcBool ParcelReadUint8Revert(HcParcel *parcel, uint8_t *dst)
+{
+    return ParcelRead(parcel, dst, sizeof(uint8_t));
+}
+
+HcBool ParcelReadUint64Revert(HcParcel *parcel, uint64_t *dst)
+{
+    HcBool ret = ParcelRead(parcel, dst, sizeof(uint64_t));
+    if (ret) {
+        DataRevert(dst, sizeof(uint64_t));
+    }
+    return ret;
+}
+
+HcBool ParcelReadInt64Revert(HcParcel *parcel, int64_t *dst)
+{
+    HcBool ret = ParcelRead(parcel, dst, sizeof(int64_t));
+    if (ret) {
+        DataRevert(dst, sizeof(int64_t));
+    }
+    return ret;
+}
+
+HcBool ParcelWriteInt32Revert(HcParcel *parcel, int src)
+{
+    DataRevert(&src, sizeof(src));
+    return ParcelWriteInt32(parcel, src);
+}
+
+HcBool ParcelWriteUint32Revert(HcParcel *parcel, uint32_t src)
+{
+    DataRevert(&src, sizeof(src));
+    return ParcelWriteUint32(parcel, src);
+}
+
+HcBool ParcelWriteInt16Revert(HcParcel *parcel, short src)
+{
+    DataRevert(&src, sizeof(src));
+    return ParcelWriteInt16(parcel, src);
+}
+
+HcBool ParcelWriteUint16Revert(HcParcel *parcel, uint16_t src)
+{
+    DataRevert(&src, sizeof(src));
+    return ParcelWriteUint16(parcel, src);
+}
+
+HcBool ParcelWriteInt8Revert(HcParcel *parcel, char src)
+{
+    return ParcelWriteInt8(parcel, src);
+}
+
+HcBool ParcelWriteUint8Revert(HcParcel *parcel, uint8_t src)
+{
+    return ParcelWriteUint8(parcel, src);
+}
+
+HcBool ParcelWriteUint64Revert(HcParcel *parcel, uint64_t src)
+{
+    DataRevert(&src, sizeof(src));
+    return ParcelWriteUint64(parcel, src);
+}
+
+HcBool ParcelWriteInt64Revert(HcParcel *parcel, int64_t src)
+{
+    DataRevert(&src, sizeof(src));
+    return ParcelWriteInt64(parcel, src);
+}
+
+HcBool ParcelPopBack(HcParcel *parcel, uint32_t size)
+{
+    if (parcel != NULL && size > 0 && GetParcelDataSize(parcel) >= size) {
+        parcel->endPos -= size;
+        return HC_TRUE;
+    }
+    return HC_FALSE;
+}
+
+HcBool ParcelPopFront(HcParcel *parcel, uint32_t size)
+{
+    if ((parcel != NULL) && (size > 0) && (GetParcelDataSize(parcel) >= size)) {
+        parcel->beginPos += size;
+        return HC_TRUE;
+    }
+    return HC_FALSE;
+}
diff -Naru deviceauth/hals/src/common/hc_string.c deviceauth_new/hals/src/common/hc_string.c
--- deviceauth/hals/src/common/hc_string.c	2025-02-12 16:28:23.198851800 +0800
+++ deviceauth_new/hals/src/common/hc_string.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,175 +1,175 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_string.h"
-
-const uint32_t STRING_ALLOC_SIZE = 10;
-const uint32_t STRING_END_CHAR_LENGTH = 1;
-const char STRING_END_CHAR = '\0';
-
-/*
- * Append a HcString
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: append string.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringAppend(HcString *self, HcString str)
-{
-    uint32_t length = GetParcelDataSize(&str.parcel);
-    if (self != NULL && length > 0) {
-        // remove '\0'
-        ParcelPopBack(&self->parcel, STRING_END_CHAR_LENGTH);
-        // append string(include '\0')
-        return StringAppendPointer(self, GetParcelData(&str.parcel));
-    }
-
-    return HC_FALSE;
-}
-
-/*
- * Append string pointer
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: string pointer.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringAppendPointer(HcString *self, const char *str)
-{
-    if (self != NULL && str != NULL) {
-        // remove '\0'
-        ParcelPopBack(&self->parcel, STRING_END_CHAR_LENGTH);
-        // append string (include '\0')
-        return ParcelWrite(&self->parcel, (void *)str, strlen(str) + 1);
-    }
-
-    return HC_FALSE;
-}
-
-/*
- * Append a char
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: char.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringAppendChar(HcString *self, char c)
-{
-    if (self != NULL && c != STRING_END_CHAR) {
-        // remove '\0'
-        ParcelPopBack(&self->parcel, STRING_END_CHAR_LENGTH);
-
-        if (ParcelWriteInt8(&self->parcel, c)) {
-            return ParcelWriteInt8(&self->parcel, (uint32_t)STRING_END_CHAR);
-        }
-    }
-
-    return HC_FALSE;
-}
-
-/*
- * Assign a value to the HcString
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: assign value of ta_sting.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringSet(HcString *self, HcString str)
-{
-    if (self != NULL) {
-        DeleteParcel(&self->parcel);
-        return StringAppend(self, str);
-    }
-
-    return HC_FALSE;
-}
-
-/*
- * Assign a value to the HcString
- * Notice: It will add '\0' automatically.
- * @param self: self pointer.
- * @param str: assign value of string pointer.
- * @return HC_TRUE (ok), HC_FALSE (error)
- */
-HcBool StringSetPointer(HcString *self, const char *str)
-{
-    if (self != NULL) {
-        DeleteParcel(&self->parcel);
-        return StringAppendPointer(self, str);
-    }
-
-    return HC_FALSE;
-}
-
-/*
- * Get the string pointer data
- * @param self: self pointer.
- * @return the pointer data of the string
- */
-const char* StringGet(const HcString *self)
-{
-    if (self == NULL) {
-        return NULL;
-    }
-
-    return GetParcelData(&self->parcel);
-}
-
-/*
- * Get the length of the string
- * @param self: self pointer.
- * @return the length of the string
- */
-uint32_t StringLength(const HcString *self)
-{
-    if (self == NULL) {
-        return 0;
-    } else {
-        uint32_t length = GetParcelDataSize(&self->parcel);
-        if (length > 0) {
-            return length - STRING_END_CHAR_LENGTH;
-        } else {
-            return 0;
-        }
-    }
-}
-
-/*
- * Create a string.
- * Notice: You should delete_string when you don't need the string anymore.
- * @return return the created string.
- */
-HcString CreateString()
-{
-    HcString str;
-    str.parcel = CreateParcel(0, STRING_ALLOC_SIZE);
-    ParcelWriteInt8(&str.parcel, STRING_END_CHAR);
-    return str;
-}
-
-/*
- * Delete a string. In fact it will not destroy the string,
- * but only free the allocate memory of the string and reset the member's value
- * of the string.
- * You can continue to use the string if you want.
- * Notice: You should delete the string when you don't need it any more to avoid memory leak.
- * @param str: The string you want to delete.
- */
-void DeleteString(HcString *str)
-{
-    if (str != NULL) {
-        DeleteParcel(&str->parcel);
-    }
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_string.h"
+
+const uint32_t STRING_ALLOC_SIZE = 10;
+const uint32_t STRING_END_CHAR_LENGTH = 1;
+const char STRING_END_CHAR = '\0';
+
+/*
+ * Append a HcString
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: append string.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringAppend(HcString *self, HcString str)
+{
+    uint32_t length = GetParcelDataSize(&str.parcel);
+    if (self != NULL && length > 0) {
+        // remove '\0'
+        ParcelPopBack(&self->parcel, STRING_END_CHAR_LENGTH);
+        // append string(include '\0')
+        return StringAppendPointer(self, GetParcelData(&str.parcel));
+    }
+
+    return HC_FALSE;
+}
+
+/*
+ * Append string pointer
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: string pointer.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringAppendPointer(HcString *self, const char *str)
+{
+    if (self != NULL && str != NULL) {
+        // remove '\0'
+        ParcelPopBack(&self->parcel, STRING_END_CHAR_LENGTH);
+        // append string (include '\0')
+        return ParcelWrite(&self->parcel, (void *)str, strlen(str) + 1);
+    }
+
+    return HC_FALSE;
+}
+
+/*
+ * Append a char
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: char.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringAppendChar(HcString *self, char c)
+{
+    if (self != NULL && c != STRING_END_CHAR) {
+        // remove '\0'
+        ParcelPopBack(&self->parcel, STRING_END_CHAR_LENGTH);
+
+        if (ParcelWriteInt8(&self->parcel, c)) {
+            return ParcelWriteInt8(&self->parcel, (uint32_t)STRING_END_CHAR);
+        }
+    }
+
+    return HC_FALSE;
+}
+
+/*
+ * Assign a value to the HcString
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: assign value of ta_sting.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringSet(HcString *self, HcString str)
+{
+    if (self != NULL) {
+        DeleteParcel(&self->parcel);
+        return StringAppend(self, str);
+    }
+
+    return HC_FALSE;
+}
+
+/*
+ * Assign a value to the HcString
+ * Notice: It will add '\0' automatically.
+ * @param self: self pointer.
+ * @param str: assign value of string pointer.
+ * @return HC_TRUE (ok), HC_FALSE (error)
+ */
+HcBool StringSetPointer(HcString *self, const char *str)
+{
+    if (self != NULL) {
+        DeleteParcel(&self->parcel);
+        return StringAppendPointer(self, str);
+    }
+
+    return HC_FALSE;
+}
+
+/*
+ * Get the string pointer data
+ * @param self: self pointer.
+ * @return the pointer data of the string
+ */
+const char* StringGet(const HcString *self)
+{
+    if (self == NULL) {
+        return NULL;
+    }
+
+    return GetParcelData(&self->parcel);
+}
+
+/*
+ * Get the length of the string
+ * @param self: self pointer.
+ * @return the length of the string
+ */
+uint32_t StringLength(const HcString *self)
+{
+    if (self == NULL) {
+        return 0;
+    } else {
+        uint32_t length = GetParcelDataSize(&self->parcel);
+        if (length > 0) {
+            return length - STRING_END_CHAR_LENGTH;
+        } else {
+            return 0;
+        }
+    }
+}
+
+/*
+ * Create a string.
+ * Notice: You should delete_string when you don't need the string anymore.
+ * @return return the created string.
+ */
+HcString CreateString()
+{
+    HcString str;
+    str.parcel = CreateParcel(0, STRING_ALLOC_SIZE);
+    ParcelWriteInt8(&str.parcel, STRING_END_CHAR);
+    return str;
+}
+
+/*
+ * Delete a string. In fact it will not destroy the string,
+ * but only free the allocate memory of the string and reset the member's value
+ * of the string.
+ * You can continue to use the string if you want.
+ * Notice: You should delete the string when you don't need it any more to avoid memory leak.
+ * @param str: The string you want to delete.
+ */
+void DeleteString(HcString *str)
+{
+    if (str != NULL) {
+        DeleteParcel(&str->parcel);
+    }
+}
diff -Naru deviceauth/hals/src/common/hc_task_thread.c deviceauth_new/hals/src/common/hc_task_thread.c
--- deviceauth/hals/src/common/hc_task_thread.c	2025-02-12 16:28:23.238036200 +0800
+++ deviceauth_new/hals/src/common/hc_task_thread.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,149 +1,149 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_task_thread.h"
-#include "hc_error.h"
-#include "hc_log.h"
-
-#define TASK_ALLOC_UINT 5
-
-IMPLEMENT_HC_VECTOR(TaskVec, HcTaskWrap, TASK_ALLOC_UINT)
-
-static HcTaskBase* PopTask(HcTaskThread* thread)
-{
-    if (thread == NULL) {
-        return NULL;
-    }
-
-    thread->queueLock.lock(&thread->queueLock);
-    HcTaskWrap task;
-    HcBool ret = thread->tasks.popFront(&thread->tasks, &task);
-    thread->queueLock.unlock(&thread->queueLock);
-    if (ret) {
-        return task.task;
-    }
-    return NULL;
-}
-
-static void PushTask(struct HcTaskThreadT* thread, HcTaskBase* task)
-{
-    if (thread == NULL || task == NULL) {
-        return;
-    }
-
-    thread->queueLock.lock(&thread->queueLock);
-    HcTaskWrap taskWarp;
-    taskWarp.task = task;
-    thread->tasks.pushBack(&thread->tasks, &taskWarp);
-    thread->thread.notify(&thread->thread);
-    thread->queueLock.unlock(&thread->queueLock);
-}
-
-static void Clear(struct HcTaskThreadT* thread)
-{
-    thread->queueLock.lock(&thread->queueLock);
-    HcTaskWrap *taskWarp = NULL;
-    uint32_t index;
-    FOR_EACH_HC_VECTOR(thread->tasks, index, taskWarp) {
-        if (taskWarp->task->destroy) {
-            taskWarp->task->destroy(taskWarp->task);
-        }
-        HcFree(taskWarp->task);
-    }
-    thread->tasks.clear(&thread->tasks);
-    thread->queueLock.unlock(&thread->queueLock);
-}
-
-static void StopAndClear(struct HcTaskThreadT* thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-    thread->clear(thread);
-    thread->quit = HC_TRUE;
-    thread->thread.notify(&thread->thread);
-    thread->thread.join(&thread->thread);
-}
-
-static int32_t StartTaskThread(struct HcTaskThreadT* thread)
-{
-    if (thread == NULL) {
-        return HAL_ERR_BAD_ALLOC;
-    }
-
-    thread->quit = HC_FALSE;
-    int32_t res = thread->thread.start(&thread->thread);
-    if (res != HAL_SUCCESS) {
-        LOGE("Start thread failed, res:%d", res);
-    }
-    return res;
-}
-
-static int TaskThreadLoop(void* args)
-{
-    HcTaskThread* thread = (HcTaskThread*)args;
-    if (thread == NULL) {
-        return -1;
-    }
-
-    while (1) {
-        if (thread->quit) {
-            break;
-        }
-        HcTaskBase* task = PopTask(thread);
-        if (task != NULL) {
-            if (task->doAction) {
-                task->doAction(task);
-            }
-            if (task->destroy) {
-                task->destroy(task);
-            }
-            HcFree(task);
-        } else {
-            thread->thread.wait(&thread->thread);
-        }
-    }
-    return 0;
-}
-
-int32_t InitHcTaskThread(HcTaskThread* thread, size_t stackSize, const char* threadName)
-{
-    if (thread == NULL) {
-        return -1;
-    }
-
-    thread->pushTask = PushTask;
-    thread->startThread = StartTaskThread;
-    thread->clear = Clear;
-    thread->stopAndClear = StopAndClear;
-    int32_t res = InitThread(&thread->thread, TaskThreadLoop, stackSize, threadName);
-    if (res != 0) {
-        return res;
-    }
-    res = InitHcMutex(&thread->queueLock);
-    if (res != 0) {
-        DestroyThread(&thread->thread);
-        return res;
-    }
-    thread->tasks = CREATE_HC_VECTOR(TaskVec);
-    return 0;
-}
-
-void DestroyHcTaskThread(HcTaskThread* thread)
-{
-    DESTROY_HC_VECTOR(TaskVec, &thread->tasks);
-    DestroyHcMutex(&thread->queueLock);
-    DestroyThread(&thread->thread);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_task_thread.h"
+#include "hc_error.h"
+#include "hc_log.h"
+
+#define TASK_ALLOC_UINT 5
+
+IMPLEMENT_HC_VECTOR(TaskVec, HcTaskWrap, TASK_ALLOC_UINT)
+
+static HcTaskBase* PopTask(HcTaskThread* thread)
+{
+    if (thread == NULL) {
+        return NULL;
+    }
+
+    thread->queueLock.lock(&thread->queueLock);
+    HcTaskWrap task;
+    HcBool ret = thread->tasks.popFront(&thread->tasks, &task);
+    thread->queueLock.unlock(&thread->queueLock);
+    if (ret) {
+        return task.task;
+    }
+    return NULL;
+}
+
+static void PushTask(struct HcTaskThreadT* thread, HcTaskBase* task)
+{
+    if (thread == NULL || task == NULL) {
+        return;
+    }
+
+    thread->queueLock.lock(&thread->queueLock);
+    HcTaskWrap taskWarp;
+    taskWarp.task = task;
+    thread->tasks.pushBack(&thread->tasks, &taskWarp);
+    thread->thread.notify(&thread->thread);
+    thread->queueLock.unlock(&thread->queueLock);
+}
+
+static void Clear(struct HcTaskThreadT* thread)
+{
+    thread->queueLock.lock(&thread->queueLock);
+    HcTaskWrap *taskWarp = NULL;
+    uint32_t index;
+    FOR_EACH_HC_VECTOR(thread->tasks, index, taskWarp) {
+        if (taskWarp->task->destroy) {
+            taskWarp->task->destroy(taskWarp->task);
+        }
+        HcFree(taskWarp->task);
+    }
+    thread->tasks.clear(&thread->tasks);
+    thread->queueLock.unlock(&thread->queueLock);
+}
+
+static void StopAndClear(struct HcTaskThreadT* thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+    thread->clear(thread);
+    thread->quit = HC_TRUE;
+    thread->thread.notify(&thread->thread);
+    thread->thread.join(&thread->thread);
+}
+
+static int32_t StartTaskThread(struct HcTaskThreadT* thread)
+{
+    if (thread == NULL) {
+        return HAL_ERR_BAD_ALLOC;
+    }
+
+    thread->quit = HC_FALSE;
+    int32_t res = thread->thread.start(&thread->thread);
+    if (res != HAL_SUCCESS) {
+        LOGE("Start thread failed, res:%d", res);
+    }
+    return res;
+}
+
+static int TaskThreadLoop(void* args)
+{
+    HcTaskThread* thread = (HcTaskThread*)args;
+    if (thread == NULL) {
+        return -1;
+    }
+
+    while (1) {
+        if (thread->quit) {
+            break;
+        }
+        HcTaskBase* task = PopTask(thread);
+        if (task != NULL) {
+            if (task->doAction) {
+                task->doAction(task);
+            }
+            if (task->destroy) {
+                task->destroy(task);
+            }
+            HcFree(task);
+        } else {
+            thread->thread.wait(&thread->thread);
+        }
+    }
+    return 0;
+}
+
+int32_t InitHcTaskThread(HcTaskThread* thread, size_t stackSize, const char* threadName)
+{
+    if (thread == NULL) {
+        return -1;
+    }
+
+    thread->pushTask = PushTask;
+    thread->startThread = StartTaskThread;
+    thread->clear = Clear;
+    thread->stopAndClear = StopAndClear;
+    int32_t res = InitThread(&thread->thread, TaskThreadLoop, stackSize, threadName);
+    if (res != 0) {
+        return res;
+    }
+    res = InitHcMutex(&thread->queueLock);
+    if (res != 0) {
+        DestroyThread(&thread->thread);
+        return res;
+    }
+    thread->tasks = CREATE_HC_VECTOR(TaskVec);
+    return 0;
+}
+
+void DestroyHcTaskThread(HcTaskThread* thread)
+{
+    DESTROY_HC_VECTOR(TaskVec, &thread->tasks);
+    DestroyHcMutex(&thread->queueLock);
+    DestroyThread(&thread->thread);
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/common/hc_tlv_parser.c deviceauth_new/hals/src/common/hc_tlv_parser.c
--- deviceauth/hals/src/common/hc_tlv_parser.c	2025-02-12 16:28:23.283668500 +0800
+++ deviceauth_new/hals/src/common/hc_tlv_parser.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,476 +1,476 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_tlv_parser.h"
-#include <stddef.h>
-#include "hc_log.h"
-
-#define MAX_TLV_LENGTH (32 * 1024)
-
-HcBool ParseTlvHead(TlvBase *tlv, HcParcel *parcel)
-{
-#ifdef IS_BIG_ENDIAN
-    if (!ParcelReadUint16Revert(parcel, &tlv->tag)) {
-        LOGE(" ParseTlvHead failed, read tag failed!!!");
-        return HC_FALSE;
-    }
-#else
-    if (!ParcelReadUint16(parcel, &tlv->tag)) {
-        LOGE(" ParseTlvHead failed, read tag failed!!!");
-        return HC_FALSE;
-    }
-#endif
-
-    if (tlv->tag != tlv->checkTag) {
-        LOGE(" ParseTlvHead failed, tag is error, expect:%x, get:%x!!!", tlv->checkTag, tlv->tag);
-        return HC_FALSE;
-    }
-#ifdef IS_BIG_ENDIAN
-    if (!ParcelReadUint16Revert(parcel, &tlv->length)) {
-        LOGE(" ParseTlvHead failed, read length failed!!!");
-        return HC_FALSE;
-    }
-#else
-    if (!ParcelReadUint16(parcel, &tlv->length)) {
-        LOGE(" ParseTlvHead failed, read length failed!!!");
-        return HC_FALSE;
-    }
-#endif
-    if (tlv->length > MAX_TLV_LENGTH) {
-        return HC_FALSE;
-    }
-    return HC_TRUE;
-}
-
-int32_t ParseTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool strict)
-{
-    if (!ParseTlvHead(tlv, parcel)) {
-        return TLV_FAIL;
-    } else {
-        if (GetParcelDataSize(parcel) < tlv->length) {
-            LOGE("parcel buffer too short tlv->tag is:%x, parcel size is %x and tlv->length is %x",
-                tlv->tag, GetParcelDataSize(parcel), tlv->length);
-            return TLV_FAIL;
-        }
-
-        int ret = tlv->parse(tlv, parcel, strict);
-        if (ret < 0 || ret > MAX_TLV_LENGTH) {
-            return TLV_FAIL;
-        } else {
-            return ret + sizeof(tlv->tag) + sizeof(tlv->length);
-        }
-    }
-}
-
-int32_t GetlenTlvNode(TlvBase *tlv)
-{
-    int32_t bodyLen = tlv->getlen(tlv);
-    if (bodyLen < 0 || bodyLen > MAX_TLV_LENGTH) {
-        return TLV_FAIL;
-    } else {
-        tlv->length = bodyLen + sizeof(tlv->tag) + sizeof(tlv->length);
-        return tlv->length;
-    }
-}
-
-void DeinitTlvNode(TlvBase *tlv)
-{
-    if (tlv != NULL) {
-        tlv->deinit(tlv);
-    }
-}
-
-int32_t EncodeTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool isRoot)
-{
-    int32_t bodyLen = tlv->getlen(tlv);
-    if (bodyLen < 0 || bodyLen > MAX_TLV_LENGTH) {
-        return TLV_FAIL;
-    } else if (bodyLen == 0) {
-        if (isRoot) {
-            ResetParcel(parcel, sizeof(uint16_t) + sizeof(uint16_t), 0);
-        }
-#ifdef IS_BIG_ENDIAN
-        ParcelWriteUint16Revert(parcel, tlv->checkTag);
-        ParcelWriteUint16Revert(parcel, bodyLen);
-#else
-        ParcelWriteUint16(parcel, tlv->checkTag);
-        ParcelWriteUint16(parcel, bodyLen);
-#endif
-        return sizeof(tlv->tag) + sizeof(tlv->length);
-    } else { // has value
-        if (isRoot) {
-            ResetParcel(parcel, sizeof(uint16_t) + sizeof(uint16_t) + bodyLen, 0);
-        }
-        int32_t encodeLen;
-        tlv->length = (uint16_t)bodyLen;
-#ifdef IS_BIG_ENDIAN
-        ParcelWriteUint16Revert(parcel, tlv->checkTag);
-        ParcelWriteUint16Revert(parcel, tlv->length);
-#else
-        ParcelWriteUint16(parcel, tlv->checkTag);
-        ParcelWriteUint16(parcel, tlv->length);
-#endif
-        encodeLen = tlv->encode(tlv, parcel);
-        if (encodeLen < 0 || encodeLen > MAX_TLV_LENGTH) {
-            return TLV_FAIL;
-        } else {
-            return encodeLen + sizeof(tlv->tag) + sizeof(tlv->length);
-        }
-    }
-}
-
-TlvBase* GetEmptyStructNode(TlvBase *tlv, unsigned short tag)
-{
-    if (tlv == NULL) {
-        return NULL;
-    }
-
-    unsigned int index;
-    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
-    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
-    for (index = 0; index < memberCount; ++index) {
-        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
-        if (tlvChild->checkTag == tag && tlvChild->hasValue == 0) {
-            return tlvChild;
-        }
-    }
-
-    return NULL;
-}
-
-int32_t CheckStructNodeAllHasValue(TlvBase *tlv)
-{
-    if (tlv == NULL) {
-        return 0;
-    } else {
-        unsigned int index;
-        unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
-        unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
-        for (index = 0; index < memberCount; ++index) {
-            TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
-            if (tlvChild->hasValue == 0) {
-                return -1;
-            }
-        }
-    }
-
-    return 0;
-}
-
-void SetStructNodeHasValue(TlvBase *tlv)
-{
-    if (tlv != NULL) {
-        tlv->hasValue = 1;
-    }
-}
-
-int32_t ParseAndSkipTlvUnknownNode(HcParcel *parcel)
-{
-    // read tag
-    uint16_t tag = 0;
-    if (!ParcelReadUint16(parcel, &tag)) {
-        return TLV_FAIL;
-    }
-
-    // read length
-    uint16_t length = 0;
-    if (!ParcelReadUint16(parcel, &length)) {
-        return TLV_FAIL;
-    }
-
-    // pop data
-    if (!ParcelPopFront(parcel, length)) {
-        return TLV_FAIL;
-    }
-
-    return sizeof(tag) + sizeof(length) + length;
-}
-
-int32_t ParseTlvStruct(TlvBase *tlv, HcParcel *parcel, HcBool strict)
-{
-    uint32_t childTotalLength = 0;
-    do {
-        uint16_t tag = 0;
-        if (!ParcelReadWithoutPopData(parcel, &tag, sizeof(tag))) {
-            return TLV_FAIL;
-        }
-        TlvBase *tlvChild = GetEmptyStructNode(tlv, tag);
-        if (tlvChild == NULL) {
-            if (strict) {
-                LOGE("ParseTlvStruct error, unknown tag in strict mode:%x", tlv->tag);
-                return TLV_FAIL;
-            }
-
-            int32_t unknownChildLength = ParseAndSkipTlvUnknownNode(parcel);
-            if (unknownChildLength < 0 || unknownChildLength > MAX_TLV_LENGTH) {
-                return TLV_FAIL;
-            }
-            childTotalLength += unknownChildLength;
-            if (childTotalLength > MAX_TLV_LENGTH) {
-                return TLV_FAIL;
-            }
-        } else {
-            int32_t childLength = ParseTlvNode(tlvChild, parcel, strict);
-            if (childLength < 0 || childLength > MAX_TLV_LENGTH) {
-                LOGE("ParseTlvStruct parse member child length error:%x", tag);
-                return TLV_FAIL;
-            }
-            SetStructNodeHasValue(tlvChild);
-            childTotalLength += childLength;
-            if (childTotalLength > MAX_TLV_LENGTH) {
-                return TLV_FAIL;
-            }
-        }
-    } while (childTotalLength < tlv->length);
-
-    if (childTotalLength > tlv->length) {
-        LOGE("ParseTlvStruct failed, because child length is too big");
-        return TLV_FAIL;
-    }
-
-    if (strict && CheckStructNodeAllHasValue(tlv) != 0) {
-        LOGE("ParseTlvStruct error, the tag's child value is empty, tag:%x", tlv->tag);
-        return TLV_FAIL;
-    }
-
-    return childTotalLength;
-}
-
-int32_t EncodeTlvStruct(TlvBase *tlv, HcParcel *parcel)
-{
-    unsigned int index;
-    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
-    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
-
-    uint32_t totalLen = 0;
-    for (index = 0; index < memberCount; ++index) {
-        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
-        int32_t childLen = EncodeTlvNode(tlvChild, parcel, HC_FALSE);
-        if (childLen < 0 || childLen > MAX_TLV_LENGTH) {
-            return TLV_FAIL;
-        } else {
-            totalLen += childLen;
-        }
-        if (totalLen > MAX_TLV_LENGTH) {
-            return TLV_FAIL;
-        }
-    }
-
-    return totalLen;
-}
-
-int32_t GetLenTlvStruct(TlvBase *tlv)
-{
-    unsigned int index;
-    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
-    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
-    uint32_t childTotalLength = 0;
-
-    for (index = 0; index < memberCount; ++index) {
-        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
-        int32_t childLength = GetlenTlvNode(tlvChild);
-        if (childLength <= 0 || childLength > MAX_TLV_LENGTH) {
-            return TLV_FAIL;
-        } else {
-            childTotalLength += childLength;
-        }
-        if (childTotalLength > MAX_TLV_LENGTH) {
-            return TLV_FAIL;
-        }
-    }
-
-    return childTotalLength;
-}
-
-void DeinitTlvStruct(TlvBase *tlv)
-{
-    unsigned int index;
-    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
-    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
-
-    for (index = 0; index < memberCount; ++index) {
-        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
-        DeinitTlvNode(tlvChild);
-    }
-}
-
-HcBool DecodeTlvMessage(TlvBase *msg, HcParcel *parcel, HcBool strict)
-{
-    if (msg == NULL || parcel == NULL) {
-        return HC_FALSE;
-    } else {
-        int32_t msgLen = ParseTlvNode(msg, parcel, strict);
-        if (msgLen > MAX_TLV_LENGTH) {
-            return HC_FALSE;
-        }
-        if ((int32_t)(msg->length + sizeof(msg->length) + sizeof(msg->tag)) != msgLen) {
-            return HC_FALSE;
-        }
-
-        if (GetParcelDataSize(parcel) != 0) {
-            return HC_FALSE;
-        }
-    }
-
-    return HC_TRUE;
-}
-
-
-HcBool EncodeTlvMessage(TlvBase *msg, HcParcel *parcel)
-{
-    if (msg == NULL || parcel == NULL) {
-        return HC_FALSE;
-    } else {
-        if (EncodeTlvNode(msg, parcel, HC_TRUE) < 0) {
-            return HC_FALSE;
-        }
-    }
-
-    return HC_TRUE;
-}
-
-int32_t ParseTlvBuffer(TlvBase *tlv, HcParcel *parcel, HcBool strict)
-{
-    (void)strict;
-    TlvBuffer *realTlv = (TlvBuffer *)(tlv);
-    if (tlv->length == 0 || ParcelReadParcel(parcel, &realTlv->data, tlv->length, HC_FALSE)) {
-        return tlv->length;
-    } else {
-        LOGE("ParseTlvBuffer error");
-        return TLV_FAIL;
-    }
-}
-
-int32_t GetlenTlvBuffer(TlvBase *tlv)
-{
-    TlvBuffer *realTlv = (TlvBuffer *)(tlv);
-    return (int32_t)GetParcelDataSize(&realTlv->data);
-}
-
-int32_t EncodeTlvBuffer(TlvBase *tlv, HcParcel *parcel)
-{
-    TlvBuffer *realTlv = (TlvBuffer *)(tlv);
-    int32_t len = GetlenTlvBuffer(tlv);
-    if (len <= 0 || len > MAX_TLV_LENGTH) {
-        return TLV_FAIL;
-    }
-
-    if (ParcelReadParcel(&realTlv->data, parcel, len, HC_TRUE)) {
-        return len;
-    } else {
-        return TLV_FAIL;
-    }
-}
-
-void DeinitTlvBuffer(TlvBase *tlv)
-{
-    DeleteParcel(&((TlvBuffer *)tlv)->data);
-}
-
-void InitTlvBuffer(TlvBuffer *tlv, unsigned short checkTag)
-{
-    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base));
-    tlv->base.parse = ParseTlvBuffer;
-    tlv->base.getlen = GetlenTlvBuffer;
-    tlv->base.encode = EncodeTlvBuffer;
-    tlv->base.deinit = DeinitTlvBuffer;
-    tlv->base.checkTag = checkTag;
-    tlv->data = CreateParcel(PARCEL_DEFAULT_LENGTH, PARCEL_DEFAULT_ALLOC_UNIT);
-}
-
-int32_t ParseTlvString(TlvBase *tlv, HcParcel *parcel, HcBool strict)
-{
-    (void)strict;
-    TlvString *realTlv = (TlvString *)(tlv);
-    ClearParcel(&realTlv->data.parcel);
-    if (tlv->length == 0 || ParcelReadParcel(parcel, &realTlv->data.parcel, tlv->length, HC_FALSE)) {
-        return tlv->length;
-    } else {
-        LOGE("ParseTlvBuffer error");
-        return TLV_FAIL;
-    }
-}
-
-int32_t GetlenTlvString(TlvBase *tlv)
-{
-    TlvString *realTlv = (TlvString *)(tlv);
-    return (int32_t)GetParcelDataSize(&realTlv->data.parcel);
-}
-
-int32_t EncodeTlvString(TlvBase *tlv, HcParcel *parcel)
-{
-    TlvString *realTlv = (TlvString *)(tlv);
-    int32_t len = GetlenTlvString(tlv);
-    if (len <= 0 || len > MAX_TLV_LENGTH) {
-        return TLV_FAIL;
-    }
-
-    if (ParcelReadParcel(&realTlv->data.parcel, parcel, len, HC_TRUE)) {
-        return len;
-    } else {
-        return TLV_FAIL;
-    }
-}
-
-void DeinitTlvString(TlvBase *tlv)
-{
-    DeleteString(&((TlvString*)tlv)->data);
-}
-
-void InitTlvString(TlvString *tlv, unsigned short checkTag)
-{
-    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base));
-    tlv->base.parse = ParseTlvString;
-    tlv->base.getlen = GetlenTlvString;
-    tlv->base.encode = EncodeTlvString;
-    tlv->base.deinit = DeinitTlvString;
-    tlv->base.checkTag = checkTag;
-    tlv->data = CreateString();
-}
-
-unsigned short GetTag(unsigned short checkTag, unsigned short defaultTag)
-{
-    if (checkTag == USE_DEFAULT_TAG) {
-        return defaultTag;
-    } else {
-        return checkTag;
-    }
-}
-
-void DeinitTlvFixMember(TlvBase* tlv)
-{
-    (void)tlv;
-    return;
-}
-
-#ifdef IS_BIG_ENDIAN
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt64, NEED_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt32, NEED_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt16, NEED_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt8, NEED_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint64, NEED_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint32, NEED_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint16, NEED_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint8, NEED_REVERT)
-#else
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt64, NO_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt32, NO_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt16, NO_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt8, NO_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint64, NO_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint32, NO_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint16, NO_REVERT)
-DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint8, NO_REVERT)
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_tlv_parser.h"
+#include <stddef.h>
+#include "hc_log.h"
+
+#define MAX_TLV_LENGTH (32 * 1024)
+
+HcBool ParseTlvHead(TlvBase *tlv, HcParcel *parcel)
+{
+#ifdef IS_BIG_ENDIAN
+    if (!ParcelReadUint16Revert(parcel, &tlv->tag)) {
+        LOGE(" ParseTlvHead failed, read tag failed!!!");
+        return HC_FALSE;
+    }
+#else
+    if (!ParcelReadUint16(parcel, &tlv->tag)) {
+        LOGE(" ParseTlvHead failed, read tag failed!!!");
+        return HC_FALSE;
+    }
+#endif
+
+    if (tlv->tag != tlv->checkTag) {
+        LOGE(" ParseTlvHead failed, tag is error, expect:%x, get:%x!!!", tlv->checkTag, tlv->tag);
+        return HC_FALSE;
+    }
+#ifdef IS_BIG_ENDIAN
+    if (!ParcelReadUint16Revert(parcel, &tlv->length)) {
+        LOGE(" ParseTlvHead failed, read length failed!!!");
+        return HC_FALSE;
+    }
+#else
+    if (!ParcelReadUint16(parcel, &tlv->length)) {
+        LOGE(" ParseTlvHead failed, read length failed!!!");
+        return HC_FALSE;
+    }
+#endif
+    if (tlv->length > MAX_TLV_LENGTH) {
+        return HC_FALSE;
+    }
+    return HC_TRUE;
+}
+
+int32_t ParseTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool strict)
+{
+    if (!ParseTlvHead(tlv, parcel)) {
+        return TLV_FAIL;
+    } else {
+        if (GetParcelDataSize(parcel) < tlv->length) {
+            LOGE("parcel buffer too short tlv->tag is:%x, parcel size is %x and tlv->length is %x",
+                tlv->tag, GetParcelDataSize(parcel), tlv->length);
+            return TLV_FAIL;
+        }
+
+        int ret = tlv->parse(tlv, parcel, strict);
+        if (ret < 0 || ret > MAX_TLV_LENGTH) {
+            return TLV_FAIL;
+        } else {
+            return ret + sizeof(tlv->tag) + sizeof(tlv->length);
+        }
+    }
+}
+
+int32_t GetlenTlvNode(TlvBase *tlv)
+{
+    int32_t bodyLen = tlv->getlen(tlv);
+    if (bodyLen < 0 || bodyLen > MAX_TLV_LENGTH) {
+        return TLV_FAIL;
+    } else {
+        tlv->length = bodyLen + sizeof(tlv->tag) + sizeof(tlv->length);
+        return tlv->length;
+    }
+}
+
+void DeinitTlvNode(TlvBase *tlv)
+{
+    if (tlv != NULL) {
+        tlv->deinit(tlv);
+    }
+}
+
+int32_t EncodeTlvNode(TlvBase *tlv, HcParcel *parcel, HcBool isRoot)
+{
+    int32_t bodyLen = tlv->getlen(tlv);
+    if (bodyLen < 0 || bodyLen > MAX_TLV_LENGTH) {
+        return TLV_FAIL;
+    } else if (bodyLen == 0) {
+        if (isRoot) {
+            ResetParcel(parcel, sizeof(uint16_t) + sizeof(uint16_t), 0);
+        }
+#ifdef IS_BIG_ENDIAN
+        ParcelWriteUint16Revert(parcel, tlv->checkTag);
+        ParcelWriteUint16Revert(parcel, bodyLen);
+#else
+        ParcelWriteUint16(parcel, tlv->checkTag);
+        ParcelWriteUint16(parcel, bodyLen);
+#endif
+        return sizeof(tlv->tag) + sizeof(tlv->length);
+    } else { // has value
+        if (isRoot) {
+            ResetParcel(parcel, sizeof(uint16_t) + sizeof(uint16_t) + bodyLen, 0);
+        }
+        int32_t encodeLen;
+        tlv->length = (uint16_t)bodyLen;
+#ifdef IS_BIG_ENDIAN
+        ParcelWriteUint16Revert(parcel, tlv->checkTag);
+        ParcelWriteUint16Revert(parcel, tlv->length);
+#else
+        ParcelWriteUint16(parcel, tlv->checkTag);
+        ParcelWriteUint16(parcel, tlv->length);
+#endif
+        encodeLen = tlv->encode(tlv, parcel);
+        if (encodeLen < 0 || encodeLen > MAX_TLV_LENGTH) {
+            return TLV_FAIL;
+        } else {
+            return encodeLen + sizeof(tlv->tag) + sizeof(tlv->length);
+        }
+    }
+}
+
+TlvBase* GetEmptyStructNode(TlvBase *tlv, unsigned short tag)
+{
+    if (tlv == NULL) {
+        return NULL;
+    }
+
+    unsigned int index;
+    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
+    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
+    for (index = 0; index < memberCount; ++index) {
+        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
+        if (tlvChild->checkTag == tag && tlvChild->hasValue == 0) {
+            return tlvChild;
+        }
+    }
+
+    return NULL;
+}
+
+int32_t CheckStructNodeAllHasValue(TlvBase *tlv)
+{
+    if (tlv == NULL) {
+        return 0;
+    } else {
+        unsigned int index;
+        unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
+        unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
+        for (index = 0; index < memberCount; ++index) {
+            TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
+            if (tlvChild->hasValue == 0) {
+                return -1;
+            }
+        }
+    }
+
+    return 0;
+}
+
+void SetStructNodeHasValue(TlvBase *tlv)
+{
+    if (tlv != NULL) {
+        tlv->hasValue = 1;
+    }
+}
+
+int32_t ParseAndSkipTlvUnknownNode(HcParcel *parcel)
+{
+    // read tag
+    uint16_t tag = 0;
+    if (!ParcelReadUint16(parcel, &tag)) {
+        return TLV_FAIL;
+    }
+
+    // read length
+    uint16_t length = 0;
+    if (!ParcelReadUint16(parcel, &length)) {
+        return TLV_FAIL;
+    }
+
+    // pop data
+    if (!ParcelPopFront(parcel, length)) {
+        return TLV_FAIL;
+    }
+
+    return sizeof(tag) + sizeof(length) + length;
+}
+
+int32_t ParseTlvStruct(TlvBase *tlv, HcParcel *parcel, HcBool strict)
+{
+    uint32_t childTotalLength = 0;
+    do {
+        uint16_t tag = 0;
+        if (!ParcelReadWithoutPopData(parcel, &tag, sizeof(tag))) {
+            return TLV_FAIL;
+        }
+        TlvBase *tlvChild = GetEmptyStructNode(tlv, tag);
+        if (tlvChild == NULL) {
+            if (strict) {
+                LOGE("ParseTlvStruct error, unknown tag in strict mode:%x", tlv->tag);
+                return TLV_FAIL;
+            }
+
+            int32_t unknownChildLength = ParseAndSkipTlvUnknownNode(parcel);
+            if (unknownChildLength < 0 || unknownChildLength > MAX_TLV_LENGTH) {
+                return TLV_FAIL;
+            }
+            childTotalLength += unknownChildLength;
+            if (childTotalLength > MAX_TLV_LENGTH) {
+                return TLV_FAIL;
+            }
+        } else {
+            int32_t childLength = ParseTlvNode(tlvChild, parcel, strict);
+            if (childLength < 0 || childLength > MAX_TLV_LENGTH) {
+                LOGE("ParseTlvStruct parse member child length error:%x", tag);
+                return TLV_FAIL;
+            }
+            SetStructNodeHasValue(tlvChild);
+            childTotalLength += childLength;
+            if (childTotalLength > MAX_TLV_LENGTH) {
+                return TLV_FAIL;
+            }
+        }
+    } while (childTotalLength < tlv->length);
+
+    if (childTotalLength > tlv->length) {
+        LOGE("ParseTlvStruct failed, because child length is too big");
+        return TLV_FAIL;
+    }
+
+    if (strict && CheckStructNodeAllHasValue(tlv) != 0) {
+        LOGE("ParseTlvStruct error, the tag's child value is empty, tag:%x", tlv->tag);
+        return TLV_FAIL;
+    }
+
+    return childTotalLength;
+}
+
+int32_t EncodeTlvStruct(TlvBase *tlv, HcParcel *parcel)
+{
+    unsigned int index;
+    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
+    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
+
+    uint32_t totalLen = 0;
+    for (index = 0; index < memberCount; ++index) {
+        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
+        int32_t childLen = EncodeTlvNode(tlvChild, parcel, HC_FALSE);
+        if (childLen < 0 || childLen > MAX_TLV_LENGTH) {
+            return TLV_FAIL;
+        } else {
+            totalLen += childLen;
+        }
+        if (totalLen > MAX_TLV_LENGTH) {
+            return TLV_FAIL;
+        }
+    }
+
+    return totalLen;
+}
+
+int32_t GetLenTlvStruct(TlvBase *tlv)
+{
+    unsigned int index;
+    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
+    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
+    uint32_t childTotalLength = 0;
+
+    for (index = 0; index < memberCount; ++index) {
+        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
+        int32_t childLength = GetlenTlvNode(tlvChild);
+        if (childLength <= 0 || childLength > MAX_TLV_LENGTH) {
+            return TLV_FAIL;
+        } else {
+            childTotalLength += childLength;
+        }
+        if (childTotalLength > MAX_TLV_LENGTH) {
+            return TLV_FAIL;
+        }
+    }
+
+    return childTotalLength;
+}
+
+void DeinitTlvStruct(TlvBase *tlv)
+{
+    unsigned int index;
+    unsigned int memberCount = *(unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offsetCount));
+    unsigned int *offset = (unsigned int *)((char *)tlv + offsetof(TlvOffsetExample, offset));
+
+    for (index = 0; index < memberCount; ++index) {
+        TlvBase *tlvChild = (TlvBase *)(((char *)tlv) + offset[index]);
+        DeinitTlvNode(tlvChild);
+    }
+}
+
+HcBool DecodeTlvMessage(TlvBase *msg, HcParcel *parcel, HcBool strict)
+{
+    if (msg == NULL || parcel == NULL) {
+        return HC_FALSE;
+    } else {
+        int32_t msgLen = ParseTlvNode(msg, parcel, strict);
+        if (msgLen > MAX_TLV_LENGTH) {
+            return HC_FALSE;
+        }
+        if ((int32_t)(msg->length + sizeof(msg->length) + sizeof(msg->tag)) != msgLen) {
+            return HC_FALSE;
+        }
+
+        if (GetParcelDataSize(parcel) != 0) {
+            return HC_FALSE;
+        }
+    }
+
+    return HC_TRUE;
+}
+
+
+HcBool EncodeTlvMessage(TlvBase *msg, HcParcel *parcel)
+{
+    if (msg == NULL || parcel == NULL) {
+        return HC_FALSE;
+    } else {
+        if (EncodeTlvNode(msg, parcel, HC_TRUE) < 0) {
+            return HC_FALSE;
+        }
+    }
+
+    return HC_TRUE;
+}
+
+int32_t ParseTlvBuffer(TlvBase *tlv, HcParcel *parcel, HcBool strict)
+{
+    (void)strict;
+    TlvBuffer *realTlv = (TlvBuffer *)(tlv);
+    if (tlv->length == 0 || ParcelReadParcel(parcel, &realTlv->data, tlv->length, HC_FALSE)) {
+        return tlv->length;
+    } else {
+        LOGE("ParseTlvBuffer error");
+        return TLV_FAIL;
+    }
+}
+
+int32_t GetlenTlvBuffer(TlvBase *tlv)
+{
+    TlvBuffer *realTlv = (TlvBuffer *)(tlv);
+    return (int32_t)GetParcelDataSize(&realTlv->data);
+}
+
+int32_t EncodeTlvBuffer(TlvBase *tlv, HcParcel *parcel)
+{
+    TlvBuffer *realTlv = (TlvBuffer *)(tlv);
+    int32_t len = GetlenTlvBuffer(tlv);
+    if (len <= 0 || len > MAX_TLV_LENGTH) {
+        return TLV_FAIL;
+    }
+
+    if (ParcelReadParcel(&realTlv->data, parcel, len, HC_TRUE)) {
+        return len;
+    } else {
+        return TLV_FAIL;
+    }
+}
+
+void DeinitTlvBuffer(TlvBase *tlv)
+{
+    DeleteParcel(&((TlvBuffer *)tlv)->data);
+}
+
+void InitTlvBuffer(TlvBuffer *tlv, unsigned short checkTag)
+{
+    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base));
+    tlv->base.parse = ParseTlvBuffer;
+    tlv->base.getlen = GetlenTlvBuffer;
+    tlv->base.encode = EncodeTlvBuffer;
+    tlv->base.deinit = DeinitTlvBuffer;
+    tlv->base.checkTag = checkTag;
+    tlv->data = CreateParcel(PARCEL_DEFAULT_LENGTH, PARCEL_DEFAULT_ALLOC_UNIT);
+}
+
+int32_t ParseTlvString(TlvBase *tlv, HcParcel *parcel, HcBool strict)
+{
+    (void)strict;
+    TlvString *realTlv = (TlvString *)(tlv);
+    ClearParcel(&realTlv->data.parcel);
+    if (tlv->length == 0 || ParcelReadParcel(parcel, &realTlv->data.parcel, tlv->length, HC_FALSE)) {
+        return tlv->length;
+    } else {
+        LOGE("ParseTlvBuffer error");
+        return TLV_FAIL;
+    }
+}
+
+int32_t GetlenTlvString(TlvBase *tlv)
+{
+    TlvString *realTlv = (TlvString *)(tlv);
+    return (int32_t)GetParcelDataSize(&realTlv->data.parcel);
+}
+
+int32_t EncodeTlvString(TlvBase *tlv, HcParcel *parcel)
+{
+    TlvString *realTlv = (TlvString *)(tlv);
+    int32_t len = GetlenTlvString(tlv);
+    if (len <= 0 || len > MAX_TLV_LENGTH) {
+        return TLV_FAIL;
+    }
+
+    if (ParcelReadParcel(&realTlv->data.parcel, parcel, len, HC_TRUE)) {
+        return len;
+    } else {
+        return TLV_FAIL;
+    }
+}
+
+void DeinitTlvString(TlvBase *tlv)
+{
+    DeleteString(&((TlvString*)tlv)->data);
+}
+
+void InitTlvString(TlvString *tlv, unsigned short checkTag)
+{
+    (void)memset_s(&tlv->base, sizeof(tlv->base), 0, sizeof(tlv->base));
+    tlv->base.parse = ParseTlvString;
+    tlv->base.getlen = GetlenTlvString;
+    tlv->base.encode = EncodeTlvString;
+    tlv->base.deinit = DeinitTlvString;
+    tlv->base.checkTag = checkTag;
+    tlv->data = CreateString();
+}
+
+unsigned short GetTag(unsigned short checkTag, unsigned short defaultTag)
+{
+    if (checkTag == USE_DEFAULT_TAG) {
+        return defaultTag;
+    } else {
+        return checkTag;
+    }
+}
+
+void DeinitTlvFixMember(TlvBase* tlv)
+{
+    (void)tlv;
+    return;
+}
+
+#ifdef IS_BIG_ENDIAN
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt64, NEED_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt32, NEED_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt16, NEED_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt8, NEED_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint64, NEED_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint32, NEED_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint16, NEED_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint8, NEED_REVERT)
+#else
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt64, NO_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt32, NO_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt16, NO_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvInt8, NO_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint64, NO_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint32, NO_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint16, NO_REVERT)
+DEFINE_TLV_FIX_LENGTH_TYPE(TlvUint8, NO_REVERT)
+#endif
diff -Naru deviceauth/hals/src/common/json_utils.c deviceauth_new/hals/src/common/json_utils.c
--- deviceauth/hals/src/common/json_utils.c	2025-02-12 16:28:23.319875900 +0800
+++ deviceauth_new/hals/src/common/json_utils.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,584 +1,584 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "json_utils.h"
-#include "cJSON.h"
-#include "common_util.h"
-#include "hc_error.h"
-#include "hc_log.h"
-#include "hc_types.h"
-
-#define RECURSE_FLAG_TRUE 1
-
-CJson *CreateJsonFromString(const char *jsonStr)
-{
-    if (jsonStr == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-    return cJSON_Parse(jsonStr);
-}
-
-CJson *CreateJson(void)
-{
-    return cJSON_CreateObject();
-}
-
-CJson *CreateJsonArray(void)
-{
-    return cJSON_CreateArray();
-}
-
-CJson *DuplicateJson(const CJson *jsonObj)
-{
-    if (jsonObj == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-    return cJSON_Duplicate(jsonObj, RECURSE_FLAG_TRUE);
-}
-
-void FreeJson(CJson *jsonObj)
-{
-    cJSON_Delete(jsonObj);
-}
-
-void DeleteItemFromJson(CJson *jsonObj, const char *key)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return;
-    }
-    cJSON_DeleteItemFromObjectCaseSensitive(jsonObj, key);
-}
-
-void DeleteAllItemExceptOne(CJson *jsonObj, const char *key)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return;
-    }
-
-    CJson *curItem = jsonObj->child;
-    CJson *nextItem = NULL;
-    while (curItem != NULL) {
-        nextItem = curItem->next;
-        if (strcmp(key, curItem->string) != 0) {
-            cJSON_Delete(cJSON_DetachItemViaPointer(jsonObj, curItem));
-        }
-        curItem = nextItem;
-    }
-}
-
-void DeleteAllItem(CJson *jsonObj)
-{
-    if (jsonObj == NULL) {
-        LOGE("Param is null.");
-        return;
-    }
-
-    CJson *curItem = jsonObj->child;
-    CJson *nextItem = NULL;
-    while (curItem != NULL) {
-        nextItem = curItem->next;
-        cJSON_Delete(cJSON_DetachItemViaPointer(jsonObj, curItem));
-        curItem = nextItem;
-    }
-}
-
-CJson *DetachItemFromJson(CJson *jsonObj, const char *key)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-
-    return cJSON_DetachItemFromObjectCaseSensitive(jsonObj, key);
-}
-
-char *PackJsonToString(const CJson *jsonObj)
-{
-    if (jsonObj == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-    return cJSON_PrintUnformatted(jsonObj);
-}
-
-void FreeJsonString(char *jsonStr)
-{
-    cJSON_free(jsonStr);
-}
-
-int GetItemNum(const CJson *jsonObj)
-{
-    if (jsonObj == NULL) {
-        LOGE("Param is null.");
-        return 0;
-    }
-    return cJSON_GetArraySize(jsonObj);
-}
-
-const char *GetItemKey(const CJson *item)
-{
-    if (item == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-    return item->string;
-}
-
-CJson *GetObjFromJson(const CJson *jsonObj, const char *key)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-
-    cJSON *objValue = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (objValue != NULL) {
-        return objValue;
-    }
-
-    int len = cJSON_GetArraySize(jsonObj);
-    for (int i = 0; i < len; i++) {
-        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
-        if (cJSON_IsObject(item)) {
-            cJSON *obj = GetObjFromJson(item, key);
-            if (obj != NULL) {
-                return obj;
-            }
-        }
-    }
-
-    return NULL;
-}
-
-CJson *GetItemFromArray(const CJson *jsonArr, int index)
-{
-    if (jsonArr == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-    return cJSON_GetArrayItem(jsonArr, index);
-}
-
-const char *GetStringFromJson(const CJson *jsonObj, const char *key)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return NULL;
-    }
-
-    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (jsonObjTmp != NULL && cJSON_IsString(jsonObjTmp)) {
-        return cJSON_GetStringValue(jsonObjTmp);
-    }
-
-    int len = cJSON_GetArraySize(jsonObj);
-    for (int i = 0; i < len; i++) {
-        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
-        if (cJSON_IsObject(item)) {
-            const char *resValue = GetStringFromJson(item, key);
-            if (resValue != NULL) {
-                return resValue;
-            }
-        }
-    }
-
-    return NULL;
-}
-
-int32_t GetByteFromJson(const CJson *jsonObj, const char *key, uint8_t *byte, uint32_t len)
-{
-    if (jsonObj == NULL || key == NULL || byte == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    const char *valueStr = GetStringFromJson(jsonObj, key);
-    if (valueStr == NULL) {
-        return HAL_ERR_JSON_GET;
-    }
-    if (len < strlen(valueStr) / BYTE_TO_HEX_OPER_LENGTH) {
-        LOGE("Invalid length.");
-        return HAL_ERR_INVALID_LEN;
-    }
-    int32_t ret = HexStringToByte(valueStr, byte, len);
-    if (ret != HAL_SUCCESS) {
-        LOGE("Convert hex string to byte failed.");
-        return ret;
-    }
-
-    return ret;
-}
-
-int32_t GetIntFromJson(const CJson *jsonObj, const char *key, int *value)
-{
-    if (jsonObj == NULL || key == NULL || value == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (jsonObjTmp != NULL && cJSON_IsNumber(jsonObjTmp)) {
-        *value = (int)cJSON_GetNumberValue(jsonObjTmp);
-        return HAL_SUCCESS;
-    }
-
-    int len = cJSON_GetArraySize(jsonObj);
-    for (int i = 0; i < len; i++) {
-        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
-        if (cJSON_IsObject(item)) {
-            int32_t ret = GetIntFromJson(item, key, value);
-            if (ret == HAL_SUCCESS) {
-                return ret;
-            }
-        }
-    }
-
-    return HAL_ERR_JSON_GET;
-}
-
-int32_t GetUnsignedIntFromJson(const CJson *jsonObj, const char *key, uint32_t *value)
-{
-    if (jsonObj == NULL || key == NULL || value == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (jsonObjTmp != NULL && cJSON_IsNumber(jsonObjTmp)) {
-        double realValue = cJSON_GetNumberValue(jsonObjTmp);
-        if (realValue < 0) {
-            int32_t tmpValue = (int32_t)realValue;
-            *value = (uint32_t)tmpValue;
-        } else {
-            *value = (uint32_t)realValue;
-        }
-        return HAL_SUCCESS;
-    }
-
-    int len = cJSON_GetArraySize(jsonObj);
-    for (int i = 0; i < len; i++) {
-        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
-        if (cJSON_IsObject(item)) {
-            int32_t ret = GetUnsignedIntFromJson(item, key, value);
-            if (ret == HAL_SUCCESS) {
-                return ret;
-            }
-        }
-    }
-
-    return HAL_ERR_JSON_GET;
-}
-
-int32_t GetInt64FromJson(const CJson *jsonObj, const char *key, int64_t *value)
-{
-    const char *str = GetStringFromJson(jsonObj, key);
-    if (str == NULL) {
-        LOGE("Failed to get int64_t from json!");
-        return HAL_ERR_JSON_GET;
-    }
-    *value = StringToInt64(str);
-    return HAL_SUCCESS;
-}
-
-int32_t GetBoolFromJson(const CJson *jsonObj, const char *key, bool *value)
-{
-    if (jsonObj == NULL || key == NULL || value == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (jsonObjTmp != NULL && cJSON_IsBool(jsonObjTmp)) {
-        *value = cJSON_IsTrue(jsonObjTmp) ? true : false;
-        return HAL_SUCCESS;
-    }
-
-    int len = cJSON_GetArraySize(jsonObj);
-    for (int i = 0; i < len; i++) {
-        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
-        if (cJSON_IsObject(item)) {
-            int32_t ret = GetBoolFromJson(item, key, value);
-            if (ret == HAL_SUCCESS) {
-                return ret;
-            }
-        }
-    }
-
-    return HAL_ERR_JSON_GET;
-}
-
-char *GetStringValue(const CJson *item)
-{
-    return cJSON_GetStringValue(item);
-}
-
-int32_t AddObjToJson(CJson *jsonObj, const char *key, const CJson *childObj)
-{
-    if (jsonObj == NULL || key == NULL || childObj == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *tmpObj = cJSON_Duplicate(childObj, RECURSE_FLAG_TRUE);
-    if (tmpObj == NULL) {
-        LOGE("Duplicate json object failed.");
-        return HAL_ERR_JSON_DUPLICATE;
-    }
-
-    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (objInJson == NULL) {
-        if (cJSON_AddItemToObject(jsonObj, key, tmpObj) == false) {
-            LOGE("Add object to json failed.");
-            cJSON_Delete(tmpObj);
-            return HAL_ERR_JSON_ADD;
-        }
-    } else {
-        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmpObj) == false) {
-            LOGE("Replace object in json failed.");
-            cJSON_Delete(tmpObj);
-            return HAL_ERR_JSON_REPLACE;
-        }
-    }
-
-    return HAL_SUCCESS;
-}
-
-int32_t AddObjToArray(CJson *jsonArr, CJson *item)
-{
-    if (jsonArr == NULL || item == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    if (cJSON_IsArray(jsonArr) == false) {
-        LOGE("Object is not array.");
-        return HAL_ERR_INVALID_PARAM;
-    }
-
-    bool ret = cJSON_AddItemToArray(jsonArr, item);
-    if (ret == false) {
-        LOGE("Add object to array failed.");
-        return HAL_ERR_JSON_ADD;
-    }
-
-    return HAL_SUCCESS;
-}
-
-int32_t AddStringToArray(CJson *jsonArr, const char *string)
-{
-    if (jsonArr == NULL || string == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    if (cJSON_IsArray(jsonArr) == false) {
-        LOGE("Object is not array.");
-        return HAL_ERR_INVALID_PARAM;
-    }
-
-    cJSON *strObj = cJSON_CreateString(string);
-    if (strObj == NULL) {
-        LOGE("Create string json object failed.");
-        return HAL_ERR_BAD_ALLOC;
-    }
-    bool ret = cJSON_AddItemToArray(jsonArr, strObj);
-    if (ret == false) {
-        LOGE("Add string to array failed.");
-        cJSON_Delete(strObj);
-        return HAL_ERR_JSON_ADD;
-    }
-
-    return HAL_SUCCESS;
-}
-
-int32_t AddStringToJson(CJson *jsonObj, const char *key, const char *value)
-{
-    if (jsonObj == NULL || key == NULL || value == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (objInJson == NULL) {
-        if (cJSON_AddStringToObject(jsonObj, key, value) == NULL) {
-            LOGE("Add string to json failed.");
-            return HAL_ERR_JSON_GET;
-        }
-    } else {
-        cJSON *tmp = cJSON_CreateString(value);
-        if (tmp == NULL) {
-            LOGE("Create string json object failed.");
-            return HAL_ERR_BAD_ALLOC;
-        }
-        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmp) == false) {
-            LOGE("Replace string in json failed.");
-            cJSON_Delete(tmp);
-            return HAL_ERR_JSON_REPLACE;
-        }
-    }
-
-    return HAL_SUCCESS;
-}
-
-int32_t AddByteToJson(CJson *jsonObj, const char *key, const uint8_t *byte, uint32_t len)
-{
-    if (jsonObj == NULL || key == NULL || byte == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    uint32_t hexLen = len * BYTE_TO_HEX_OPER_LENGTH + 1;
-    char *hexStr = (char *)HcMalloc(hexLen, 0);
-    if (hexStr == NULL) {
-        LOGE("Malloc hex string failed.");
-        return HAL_ERR_BAD_ALLOC;
-    }
-    int32_t ret = ByteToHexString(byte, len, hexStr, hexLen);
-    if (ret != HAL_SUCCESS) {
-        LOGE("Convert byte to hex string failed.");
-        HcFree(hexStr);
-        return ret;
-    }
-
-    ret = AddStringToJson(jsonObj, key, hexStr);
-    if (ret != HAL_SUCCESS) {
-        LOGE("Add string to json failed.");
-        HcFree(hexStr);
-        return ret;
-    }
-
-    HcFree(hexStr);
-    return HAL_SUCCESS;
-}
-
-int32_t AddBoolToJson(CJson *jsonObj, const char *key, bool value)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (objInJson == NULL) {
-        if (cJSON_AddBoolToObject(jsonObj, key, value) == NULL) {
-            LOGE("Add bool to json failed.");
-            return HAL_ERR_JSON_GET;
-        }
-    } else {
-        cJSON *tmp = cJSON_CreateBool(value);
-        if (tmp == NULL) {
-            LOGE("Create bool json object failed.");
-            return HAL_ERR_BAD_ALLOC;
-        }
-        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmp) == false) {
-            LOGE("Repalce bool in json failed.");
-            cJSON_Delete(tmp);
-            return HAL_ERR_JSON_REPLACE;
-        }
-    }
-
-    return HAL_SUCCESS;
-}
-
-int32_t AddIntToJson(CJson *jsonObj, const char *key, int value)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
-    if (objInJson == NULL) {
-        if (cJSON_AddNumberToObject(jsonObj, key, value) == NULL) {
-            LOGE("Add int to json failed.");
-            return HAL_ERR_JSON_GET;
-        }
-    } else {
-        cJSON *tmp = cJSON_CreateNumber(value);
-        if (tmp == NULL) {
-            LOGE("Create int json object failed.");
-            return HAL_ERR_BAD_ALLOC;
-        }
-        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmp) == false) {
-            LOGE("Replace int in json failed.");
-            cJSON_Delete(tmp);
-            return HAL_ERR_JSON_REPLACE;
-        }
-    }
-
-    return HAL_SUCCESS;
-}
-
-int32_t AddInt64StringToJson(CJson *jsonObj, const char *key, int64_t value)
-{
-    char buffer[65] = { 0 };
-    if (sprintf_s(buffer, sizeof(buffer), "%" PRId64, value) <= 0) {
-        LOGE("Failed to convert int64_t to string!");
-        return HAL_FAILED;
-    }
-    if (AddStringToJson(jsonObj, key, buffer) != HAL_SUCCESS) {
-        LOGE("Failed to add int64_t string to json!");
-        return HAL_ERR_JSON_ADD;
-    }
-    return HAL_SUCCESS;
-}
-
-int32_t AddStringArrayToJson(CJson *jsonObj, const char *key, const char * const *stringArray, uint32_t arrayLen)
-{
-    if (jsonObj == NULL || key == NULL || stringArray == NULL) {
-        LOGE("Param is null.");
-        return HAL_ERR_NULL_PTR;
-    }
-
-    cJSON *strArrayObj = cJSON_CreateStringArray(stringArray, arrayLen);
-    if (strArrayObj == NULL) {
-        LOGE("Create string array object failed.");
-        return HAL_ERR_BAD_ALLOC;
-    }
-    if (cJSON_AddItemToObject(jsonObj, key, strArrayObj) == false) {
-        LOGE("Add string array to json failed.");
-        cJSON_Delete(strArrayObj);
-        return HAL_ERR_JSON_ADD;
-    }
-    return HAL_SUCCESS;
-}
-
-void ClearSensitiveStringInJson(CJson *jsonObj, const char *key)
-{
-    if (jsonObj == NULL || key == NULL) {
-        LOGE("Param is null.");
-        return;
-    }
-    char *str = (char *)GetStringFromJson(jsonObj, key);
-    if (str == NULL) {
-        LOGD("Not find this value in json.");
-        return;
-    }
-    (void)memset_s(str, strlen(str), 0, strlen(str));
-}
-
-void ClearAndFreeJsonString(char *jsonStr)
-{
-    if (jsonStr == NULL) {
-        LOGE("Param is invalid.");
-        return;
-    }
-    (void)memset_s(jsonStr, strlen(jsonStr), 0, strlen(jsonStr));
-    FreeJsonString(jsonStr);
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "json_utils.h"
+#include "cJSON.h"
+#include "common_util.h"
+#include "hc_error.h"
+#include "hc_log.h"
+#include "hc_types.h"
+
+#define RECURSE_FLAG_TRUE 1
+
+CJson *CreateJsonFromString(const char *jsonStr)
+{
+    if (jsonStr == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+    return cJSON_Parse(jsonStr);
+}
+
+CJson *CreateJson(void)
+{
+    return cJSON_CreateObject();
+}
+
+CJson *CreateJsonArray(void)
+{
+    return cJSON_CreateArray();
+}
+
+CJson *DuplicateJson(const CJson *jsonObj)
+{
+    if (jsonObj == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+    return cJSON_Duplicate(jsonObj, RECURSE_FLAG_TRUE);
+}
+
+void FreeJson(CJson *jsonObj)
+{
+    cJSON_Delete(jsonObj);
+}
+
+void DeleteItemFromJson(CJson *jsonObj, const char *key)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return;
+    }
+    cJSON_DeleteItemFromObjectCaseSensitive(jsonObj, key);
+}
+
+void DeleteAllItemExceptOne(CJson *jsonObj, const char *key)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return;
+    }
+
+    CJson *curItem = jsonObj->child;
+    CJson *nextItem = NULL;
+    while (curItem != NULL) {
+        nextItem = curItem->next;
+        if (strcmp(key, curItem->string) != 0) {
+            cJSON_Delete(cJSON_DetachItemViaPointer(jsonObj, curItem));
+        }
+        curItem = nextItem;
+    }
+}
+
+void DeleteAllItem(CJson *jsonObj)
+{
+    if (jsonObj == NULL) {
+        LOGE("Param is null.");
+        return;
+    }
+
+    CJson *curItem = jsonObj->child;
+    CJson *nextItem = NULL;
+    while (curItem != NULL) {
+        nextItem = curItem->next;
+        cJSON_Delete(cJSON_DetachItemViaPointer(jsonObj, curItem));
+        curItem = nextItem;
+    }
+}
+
+CJson *DetachItemFromJson(CJson *jsonObj, const char *key)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+
+    return cJSON_DetachItemFromObjectCaseSensitive(jsonObj, key);
+}
+
+char *PackJsonToString(const CJson *jsonObj)
+{
+    if (jsonObj == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+    return cJSON_PrintUnformatted(jsonObj);
+}
+
+void FreeJsonString(char *jsonStr)
+{
+    cJSON_free(jsonStr);
+}
+
+int GetItemNum(const CJson *jsonObj)
+{
+    if (jsonObj == NULL) {
+        LOGE("Param is null.");
+        return 0;
+    }
+    return cJSON_GetArraySize(jsonObj);
+}
+
+const char *GetItemKey(const CJson *item)
+{
+    if (item == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+    return item->string;
+}
+
+CJson *GetObjFromJson(const CJson *jsonObj, const char *key)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+
+    cJSON *objValue = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (objValue != NULL) {
+        return objValue;
+    }
+
+    int len = cJSON_GetArraySize(jsonObj);
+    for (int i = 0; i < len; i++) {
+        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
+        if (cJSON_IsObject(item)) {
+            cJSON *obj = GetObjFromJson(item, key);
+            if (obj != NULL) {
+                return obj;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+CJson *GetItemFromArray(const CJson *jsonArr, int index)
+{
+    if (jsonArr == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+    return cJSON_GetArrayItem(jsonArr, index);
+}
+
+const char *GetStringFromJson(const CJson *jsonObj, const char *key)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return NULL;
+    }
+
+    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (jsonObjTmp != NULL && cJSON_IsString(jsonObjTmp)) {
+        return cJSON_GetStringValue(jsonObjTmp);
+    }
+
+    int len = cJSON_GetArraySize(jsonObj);
+    for (int i = 0; i < len; i++) {
+        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
+        if (cJSON_IsObject(item)) {
+            const char *resValue = GetStringFromJson(item, key);
+            if (resValue != NULL) {
+                return resValue;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+int32_t GetByteFromJson(const CJson *jsonObj, const char *key, uint8_t *byte, uint32_t len)
+{
+    if (jsonObj == NULL || key == NULL || byte == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    const char *valueStr = GetStringFromJson(jsonObj, key);
+    if (valueStr == NULL) {
+        return HAL_ERR_JSON_GET;
+    }
+    if (len < strlen(valueStr) / BYTE_TO_HEX_OPER_LENGTH) {
+        LOGE("Invalid length.");
+        return HAL_ERR_INVALID_LEN;
+    }
+    int32_t ret = HexStringToByte(valueStr, byte, len);
+    if (ret != HAL_SUCCESS) {
+        LOGE("Convert hex string to byte failed.");
+        return ret;
+    }
+
+    return ret;
+}
+
+int32_t GetIntFromJson(const CJson *jsonObj, const char *key, int *value)
+{
+    if (jsonObj == NULL || key == NULL || value == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (jsonObjTmp != NULL && cJSON_IsNumber(jsonObjTmp)) {
+        *value = (int)cJSON_GetNumberValue(jsonObjTmp);
+        return HAL_SUCCESS;
+    }
+
+    int len = cJSON_GetArraySize(jsonObj);
+    for (int i = 0; i < len; i++) {
+        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
+        if (cJSON_IsObject(item)) {
+            int32_t ret = GetIntFromJson(item, key, value);
+            if (ret == HAL_SUCCESS) {
+                return ret;
+            }
+        }
+    }
+
+    return HAL_ERR_JSON_GET;
+}
+
+int32_t GetUnsignedIntFromJson(const CJson *jsonObj, const char *key, uint32_t *value)
+{
+    if (jsonObj == NULL || key == NULL || value == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (jsonObjTmp != NULL && cJSON_IsNumber(jsonObjTmp)) {
+        double realValue = cJSON_GetNumberValue(jsonObjTmp);
+        if (realValue < 0) {
+            int32_t tmpValue = (int32_t)realValue;
+            *value = (uint32_t)tmpValue;
+        } else {
+            *value = (uint32_t)realValue;
+        }
+        return HAL_SUCCESS;
+    }
+
+    int len = cJSON_GetArraySize(jsonObj);
+    for (int i = 0; i < len; i++) {
+        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
+        if (cJSON_IsObject(item)) {
+            int32_t ret = GetUnsignedIntFromJson(item, key, value);
+            if (ret == HAL_SUCCESS) {
+                return ret;
+            }
+        }
+    }
+
+    return HAL_ERR_JSON_GET;
+}
+
+int32_t GetInt64FromJson(const CJson *jsonObj, const char *key, int64_t *value)
+{
+    const char *str = GetStringFromJson(jsonObj, key);
+    if (str == NULL) {
+        LOGE("Failed to get int64_t from json!");
+        return HAL_ERR_JSON_GET;
+    }
+    *value = StringToInt64(str);
+    return HAL_SUCCESS;
+}
+
+int32_t GetBoolFromJson(const CJson *jsonObj, const char *key, bool *value)
+{
+    if (jsonObj == NULL || key == NULL || value == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *jsonObjTmp = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (jsonObjTmp != NULL && cJSON_IsBool(jsonObjTmp)) {
+        *value = cJSON_IsTrue(jsonObjTmp) ? true : false;
+        return HAL_SUCCESS;
+    }
+
+    int len = cJSON_GetArraySize(jsonObj);
+    for (int i = 0; i < len; i++) {
+        cJSON *item = cJSON_GetArrayItem(jsonObj, i);
+        if (cJSON_IsObject(item)) {
+            int32_t ret = GetBoolFromJson(item, key, value);
+            if (ret == HAL_SUCCESS) {
+                return ret;
+            }
+        }
+    }
+
+    return HAL_ERR_JSON_GET;
+}
+
+char *GetStringValue(const CJson *item)
+{
+    return cJSON_GetStringValue(item);
+}
+
+int32_t AddObjToJson(CJson *jsonObj, const char *key, const CJson *childObj)
+{
+    if (jsonObj == NULL || key == NULL || childObj == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *tmpObj = cJSON_Duplicate(childObj, RECURSE_FLAG_TRUE);
+    if (tmpObj == NULL) {
+        LOGE("Duplicate json object failed.");
+        return HAL_ERR_JSON_DUPLICATE;
+    }
+
+    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (objInJson == NULL) {
+        if (cJSON_AddItemToObject(jsonObj, key, tmpObj) == false) {
+            LOGE("Add object to json failed.");
+            cJSON_Delete(tmpObj);
+            return HAL_ERR_JSON_ADD;
+        }
+    } else {
+        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmpObj) == false) {
+            LOGE("Replace object in json failed.");
+            cJSON_Delete(tmpObj);
+            return HAL_ERR_JSON_REPLACE;
+        }
+    }
+
+    return HAL_SUCCESS;
+}
+
+int32_t AddObjToArray(CJson *jsonArr, CJson *item)
+{
+    if (jsonArr == NULL || item == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    if (cJSON_IsArray(jsonArr) == false) {
+        LOGE("Object is not array.");
+        return HAL_ERR_INVALID_PARAM;
+    }
+
+    bool ret = cJSON_AddItemToArray(jsonArr, item);
+    if (ret == false) {
+        LOGE("Add object to array failed.");
+        return HAL_ERR_JSON_ADD;
+    }
+
+    return HAL_SUCCESS;
+}
+
+int32_t AddStringToArray(CJson *jsonArr, const char *string)
+{
+    if (jsonArr == NULL || string == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    if (cJSON_IsArray(jsonArr) == false) {
+        LOGE("Object is not array.");
+        return HAL_ERR_INVALID_PARAM;
+    }
+
+    cJSON *strObj = cJSON_CreateString(string);
+    if (strObj == NULL) {
+        LOGE("Create string json object failed.");
+        return HAL_ERR_BAD_ALLOC;
+    }
+    bool ret = cJSON_AddItemToArray(jsonArr, strObj);
+    if (ret == false) {
+        LOGE("Add string to array failed.");
+        cJSON_Delete(strObj);
+        return HAL_ERR_JSON_ADD;
+    }
+
+    return HAL_SUCCESS;
+}
+
+int32_t AddStringToJson(CJson *jsonObj, const char *key, const char *value)
+{
+    if (jsonObj == NULL || key == NULL || value == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (objInJson == NULL) {
+        if (cJSON_AddStringToObject(jsonObj, key, value) == NULL) {
+            LOGE("Add string to json failed.");
+            return HAL_ERR_JSON_GET;
+        }
+    } else {
+        cJSON *tmp = cJSON_CreateString(value);
+        if (tmp == NULL) {
+            LOGE("Create string json object failed.");
+            return HAL_ERR_BAD_ALLOC;
+        }
+        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmp) == false) {
+            LOGE("Replace string in json failed.");
+            cJSON_Delete(tmp);
+            return HAL_ERR_JSON_REPLACE;
+        }
+    }
+
+    return HAL_SUCCESS;
+}
+
+int32_t AddByteToJson(CJson *jsonObj, const char *key, const uint8_t *byte, uint32_t len)
+{
+    if (jsonObj == NULL || key == NULL || byte == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    uint32_t hexLen = len * BYTE_TO_HEX_OPER_LENGTH + 1;
+    char *hexStr = (char *)HcMalloc(hexLen, 0);
+    if (hexStr == NULL) {
+        LOGE("Malloc hex string failed.");
+        return HAL_ERR_BAD_ALLOC;
+    }
+    int32_t ret = ByteToHexString(byte, len, hexStr, hexLen);
+    if (ret != HAL_SUCCESS) {
+        LOGE("Convert byte to hex string failed.");
+        HcFree(hexStr);
+        return ret;
+    }
+
+    ret = AddStringToJson(jsonObj, key, hexStr);
+    if (ret != HAL_SUCCESS) {
+        LOGE("Add string to json failed.");
+        HcFree(hexStr);
+        return ret;
+    }
+
+    HcFree(hexStr);
+    return HAL_SUCCESS;
+}
+
+int32_t AddBoolToJson(CJson *jsonObj, const char *key, bool value)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (objInJson == NULL) {
+        if (cJSON_AddBoolToObject(jsonObj, key, value) == NULL) {
+            LOGE("Add bool to json failed.");
+            return HAL_ERR_JSON_GET;
+        }
+    } else {
+        cJSON *tmp = cJSON_CreateBool(value);
+        if (tmp == NULL) {
+            LOGE("Create bool json object failed.");
+            return HAL_ERR_BAD_ALLOC;
+        }
+        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmp) == false) {
+            LOGE("Repalce bool in json failed.");
+            cJSON_Delete(tmp);
+            return HAL_ERR_JSON_REPLACE;
+        }
+    }
+
+    return HAL_SUCCESS;
+}
+
+int32_t AddIntToJson(CJson *jsonObj, const char *key, int value)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *objInJson = cJSON_GetObjectItemCaseSensitive(jsonObj, key);
+    if (objInJson == NULL) {
+        if (cJSON_AddNumberToObject(jsonObj, key, value) == NULL) {
+            LOGE("Add int to json failed.");
+            return HAL_ERR_JSON_GET;
+        }
+    } else {
+        cJSON *tmp = cJSON_CreateNumber(value);
+        if (tmp == NULL) {
+            LOGE("Create int json object failed.");
+            return HAL_ERR_BAD_ALLOC;
+        }
+        if (cJSON_ReplaceItemInObjectCaseSensitive(jsonObj, key, tmp) == false) {
+            LOGE("Replace int in json failed.");
+            cJSON_Delete(tmp);
+            return HAL_ERR_JSON_REPLACE;
+        }
+    }
+
+    return HAL_SUCCESS;
+}
+
+int32_t AddInt64StringToJson(CJson *jsonObj, const char *key, int64_t value)
+{
+    char buffer[65] = { 0 };
+    if (sprintf_s(buffer, sizeof(buffer), "%" PRId64, value) <= 0) {
+        LOGE("Failed to convert int64_t to string!");
+        return HAL_FAILED;
+    }
+    if (AddStringToJson(jsonObj, key, buffer) != HAL_SUCCESS) {
+        LOGE("Failed to add int64_t string to json!");
+        return HAL_ERR_JSON_ADD;
+    }
+    return HAL_SUCCESS;
+}
+
+int32_t AddStringArrayToJson(CJson *jsonObj, const char *key, const char * const *stringArray, uint32_t arrayLen)
+{
+    if (jsonObj == NULL || key == NULL || stringArray == NULL) {
+        LOGE("Param is null.");
+        return HAL_ERR_NULL_PTR;
+    }
+
+    cJSON *strArrayObj = cJSON_CreateStringArray(stringArray, arrayLen);
+    if (strArrayObj == NULL) {
+        LOGE("Create string array object failed.");
+        return HAL_ERR_BAD_ALLOC;
+    }
+    if (cJSON_AddItemToObject(jsonObj, key, strArrayObj) == false) {
+        LOGE("Add string array to json failed.");
+        cJSON_Delete(strArrayObj);
+        return HAL_ERR_JSON_ADD;
+    }
+    return HAL_SUCCESS;
+}
+
+void ClearSensitiveStringInJson(CJson *jsonObj, const char *key)
+{
+    if (jsonObj == NULL || key == NULL) {
+        LOGE("Param is null.");
+        return;
+    }
+    char *str = (char *)GetStringFromJson(jsonObj, key);
+    if (str == NULL) {
+        LOGD("Not find this value in json.");
+        return;
+    }
+    (void)memset_s(str, strlen(str), 0, strlen(str));
+}
+
+void ClearAndFreeJsonString(char *jsonStr)
+{
+    if (jsonStr == NULL) {
+        LOGE("Param is invalid.");
+        return;
+    }
+    (void)memset_s(jsonStr, strlen(jsonStr), 0, strlen(jsonStr));
+    FreeJsonString(jsonStr);
+}
diff -Naru deviceauth/hals/src/dev_info/3516/hc_dev_info.c deviceauth_new/hals/src/dev_info/3516/hc_dev_info.c
--- deviceauth/hals/src/dev_info/3516/hc_dev_info.c	2025-02-12 16:28:23.379396400 +0800
+++ deviceauth_new/hals/src/dev_info/3516/hc_dev_info.c	2025-02-12 15:01:27.830543400 +0800
@@ -16,9 +16,12 @@
 #include "hc_dev_info.h"
 #include "hc_error.h"
 #include "hc_log.h"
-#include "parameter.h"
 #include "securec.h"
 
+#ifndef LITE_DEVICE
+#include "parameter.h"
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -28,9 +31,16 @@
     if (udid == NULL || udidLen < INPUT_UDID_LEN || udidLen > MAX_INPUT_UDID_LEN) {
         return HAL_ERR_INVALID_PARAM;
     }
-    int32_t res = GetDevUdid((char *)udid, udidLen);
-    if (res != 0) {
-        LOGE("[OS]: GetDevUdid fail! res: %d", res);
+#ifndef LITE_DEVICE
+    int32_t ret = GetDevUdid((char *)udid, udidLen);
+    if (ret == 0) {
+        return HAL_SUCCESS;
+    }
+#endif
+    LOGD("using fake udid");
+    const char *udidTemp = "ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00";
+    (void)memset_s(udid, udidLen, 0, udidLen);
+    if (memcpy_s(udid, udidLen, udidTemp, strlen(udidTemp)) != EOK) {
         return HAL_FAILED;
     }
     return HAL_SUCCESS;
@@ -43,7 +53,6 @@
 #else
     const char *storageFile = "/storage/deviceauth/hcgroup.dat";
 #endif
-    LOGI("[OS]: storageFile: %s", storageFile);
     return storageFile;
 }
 
diff -Naru deviceauth/hals/src/dev_info/3861/hc_dev_info.c deviceauth_new/hals/src/dev_info/3861/hc_dev_info.c
--- deviceauth/hals/src/dev_info/3861/hc_dev_info.c	2025-02-12 16:28:23.421556300 +0800
+++ deviceauth_new/hals/src/dev_info/3861/hc_dev_info.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,46 +1,46 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_dev_info.h"
-#include "securec.h"
-#include "parameter.h"
-#include "hc_error.h"
-#include "hc_log.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int32_t HcGetUdid(uint8_t *udid, int32_t udidLen)
-{
-    if (udid == NULL || udidLen < INPUT_UDID_LEN || udidLen > MAX_INPUT_UDID_LEN) {
-        return HAL_ERR_INVALID_PARAM;
-    }
-    int32_t ret = GetDevUdid((char *)udid, udidLen);
-    if (ret != 0) {
-        LOGE("Failed to get dev udid, ret = %d", ret);
-        return HAL_FAILED;
-    }
-    return HAL_SUCCESS;
-}
-
-const char *GetStoragePath()
-{
-    return "hcgroup.dat";
-}
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_dev_info.h"
+#include "securec.h"
+#include "parameter.h"
+#include "hc_error.h"
+#include "hc_log.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int32_t HcGetUdid(uint8_t *udid, int32_t udidLen)
+{
+    if (udid == NULL || udidLen < INPUT_UDID_LEN || udidLen > MAX_INPUT_UDID_LEN) {
+        return HAL_ERR_INVALID_PARAM;
+    }
+    int32_t ret = GetDevUdid((char *)udid, udidLen);
+    if (ret != 0) {
+        LOGE("Failed to get dev udid, ret = %d", ret);
+        return HAL_FAILED;
+    }
+    return HAL_SUCCESS;
+}
+
+const char *GetStoragePath()
+{
+    return "hcgroup.dat";
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -Naru deviceauth/hals/src/linux/hc_condition.c deviceauth_new/hals/src/linux/hc_condition.c
--- deviceauth/hals/src/linux/hc_condition.c	2025-02-12 16:28:23.488517100 +0800
+++ deviceauth_new/hals/src/linux/hc_condition.c	2025-02-12 15:01:27.830543400 +0800
@@ -1,166 +1,166 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_condition.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int Wait(pthread_cond_t* cond, HcMutex* mutex)
-{
-    if (cond == NULL || mutex == NULL) {
-        return -1;
-    }
-    return -pthread_cond_wait(cond, &mutex->mutex);
-}
-
-void Notify(pthread_cond_t* cond)
-{
-    if (cond == NULL) {
-        return;
-    }
-    pthread_cond_signal(cond);
-}
-
-int HcCondWaitWithoutLock(struct HcConditionT* hcCond)
-{
-    if (hcCond == NULL || hcCond->mutex == NULL) {
-        return -1;
-    }
-    if (hcCond->notified) {
-        hcCond->notified = HC_FALSE;
-        return 0;
-    } else {
-        int ret;
-        hcCond->waited = HC_TRUE;
-        ret = Wait(&hcCond->cond, hcCond->mutex);
-        hcCond->waited = HC_FALSE;
-        hcCond->notified = HC_FALSE;
-        return ret;
-    }
-}
-
-void HcCondNotifyWithoutLock(struct HcConditionT* hcCond)
-{
-    if (hcCond == NULL || hcCond->mutex == NULL) {
-        return;
-    }
-
-    if (!hcCond->waited) {
-        hcCond->notified = HC_TRUE;
-    } else {
-        hcCond->notified = HC_FALSE;
-    }
-    Notify(&hcCond->cond);
-}
-
-int HcCondWait(struct HcConditionT* hcCond)
-{
-    if (hcCond == NULL) {
-        return -1;
-    }
-    if (hcCond->mutex == NULL) {
-        return -1;
-    }
-
-    hcCond->mutex->lock(hcCond->mutex);
-    if (hcCond->notified) {
-        hcCond->notified = HC_FALSE;
-        hcCond->mutex->unlock(hcCond->mutex);
-        return 0;
-    } else {
-        int ret;
-        hcCond->waited = HC_TRUE;
-        ret = Wait(&hcCond->cond, hcCond->mutex);
-        hcCond->waited = HC_FALSE;
-        hcCond->notified = HC_FALSE;
-        hcCond->mutex->unlock(hcCond->mutex);
-        return ret;
-    }
-}
-
-void HcCondNotify(struct HcConditionT* hcCond)
-{
-    if (hcCond == NULL || hcCond->mutex == NULL) {
-        return;
-    }
-
-    hcCond->mutex->lock(hcCond->mutex);
-
-    if (!hcCond->waited) {
-        hcCond->notified = HC_TRUE;
-    } else {
-        hcCond->notified = HC_FALSE;
-    }
-    Notify(&hcCond->cond);
-    hcCond->mutex->unlock(hcCond->mutex);
-}
-
-int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex)
-{
-    if (hcCond == NULL) {
-        return -1;
-    }
-    hcCond->notified = HC_FALSE;
-    hcCond->waited = HC_FALSE;
-    hcCond->wait = HcCondWait;
-    hcCond->notify = HcCondNotify;
-    hcCond->waitWithoutLock = HcCondWaitWithoutLock;
-    hcCond->notifyWithoutLock = HcCondNotifyWithoutLock;
-
-    pthread_condattr_t attr;
-    pthread_condattr_init(&attr);
-    pthread_cond_init(&hcCond->cond, &attr);
-    pthread_condattr_destroy(&attr);
-
-    if (mutex != NULL) {
-        hcCond->mutex = mutex;
-        hcCond->innerMutex = HC_FALSE;
-    } else {
-        hcCond->mutex = (HcMutex*)HcMalloc(sizeof(HcMutex), 0);
-        if (hcCond->mutex != NULL) {
-            int32_t res;
-            res = InitHcMutex(hcCond->mutex);
-            if (res != 0) {
-                HcFree(hcCond->mutex);
-                hcCond->mutex = NULL;
-                return res;
-            }
-            hcCond->innerMutex = HC_TRUE;
-        } else {
-            return -1;
-        }
-    }
-    return 0;
-}
-
-void DestroyHcCond(HcCondition* hcCond)
-{
-    if (hcCond == NULL) {
-        return;
-    }
-
-    if (hcCond->innerMutex && hcCond->mutex) {
-        DestroyHcMutex(hcCond->mutex);
-        HcFree(hcCond->mutex);
-        hcCond->mutex = NULL;
-    }
-    pthread_cond_destroy(&hcCond->cond);
-}
-
-#ifdef __cplusplus
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_condition.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int Wait(pthread_cond_t* cond, HcMutex* mutex)
+{
+    if (cond == NULL || mutex == NULL) {
+        return -1;
+    }
+    return -pthread_cond_wait(cond, &mutex->mutex);
+}
+
+void Notify(pthread_cond_t* cond)
+{
+    if (cond == NULL) {
+        return;
+    }
+    pthread_cond_signal(cond);
+}
+
+int HcCondWaitWithoutLock(struct HcConditionT* hcCond)
+{
+    if (hcCond == NULL || hcCond->mutex == NULL) {
+        return -1;
+    }
+    if (hcCond->notified) {
+        hcCond->notified = HC_FALSE;
+        return 0;
+    } else {
+        int ret;
+        hcCond->waited = HC_TRUE;
+        ret = Wait(&hcCond->cond, hcCond->mutex);
+        hcCond->waited = HC_FALSE;
+        hcCond->notified = HC_FALSE;
+        return ret;
+    }
+}
+
+void HcCondNotifyWithoutLock(struct HcConditionT* hcCond)
+{
+    if (hcCond == NULL || hcCond->mutex == NULL) {
+        return;
+    }
+
+    if (!hcCond->waited) {
+        hcCond->notified = HC_TRUE;
+    } else {
+        hcCond->notified = HC_FALSE;
+    }
+    Notify(&hcCond->cond);
+}
+
+int HcCondWait(struct HcConditionT* hcCond)
+{
+    if (hcCond == NULL) {
+        return -1;
+    }
+    if (hcCond->mutex == NULL) {
+        return -1;
+    }
+
+    hcCond->mutex->lock(hcCond->mutex);
+    if (hcCond->notified) {
+        hcCond->notified = HC_FALSE;
+        hcCond->mutex->unlock(hcCond->mutex);
+        return 0;
+    } else {
+        int ret;
+        hcCond->waited = HC_TRUE;
+        ret = Wait(&hcCond->cond, hcCond->mutex);
+        hcCond->waited = HC_FALSE;
+        hcCond->notified = HC_FALSE;
+        hcCond->mutex->unlock(hcCond->mutex);
+        return ret;
+    }
+}
+
+void HcCondNotify(struct HcConditionT* hcCond)
+{
+    if (hcCond == NULL || hcCond->mutex == NULL) {
+        return;
+    }
+
+    hcCond->mutex->lock(hcCond->mutex);
+
+    if (!hcCond->waited) {
+        hcCond->notified = HC_TRUE;
+    } else {
+        hcCond->notified = HC_FALSE;
+    }
+    Notify(&hcCond->cond);
+    hcCond->mutex->unlock(hcCond->mutex);
+}
+
+int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex)
+{
+    if (hcCond == NULL) {
+        return -1;
+    }
+    hcCond->notified = HC_FALSE;
+    hcCond->waited = HC_FALSE;
+    hcCond->wait = HcCondWait;
+    hcCond->notify = HcCondNotify;
+    hcCond->waitWithoutLock = HcCondWaitWithoutLock;
+    hcCond->notifyWithoutLock = HcCondNotifyWithoutLock;
+
+    pthread_condattr_t attr;
+    pthread_condattr_init(&attr);
+    pthread_cond_init(&hcCond->cond, &attr);
+    pthread_condattr_destroy(&attr);
+
+    if (mutex != NULL) {
+        hcCond->mutex = mutex;
+        hcCond->innerMutex = HC_FALSE;
+    } else {
+        hcCond->mutex = (HcMutex*)HcMalloc(sizeof(HcMutex), 0);
+        if (hcCond->mutex != NULL) {
+            int32_t res;
+            res = InitHcMutex(hcCond->mutex);
+            if (res != 0) {
+                HcFree(hcCond->mutex);
+                hcCond->mutex = NULL;
+                return res;
+            }
+            hcCond->innerMutex = HC_TRUE;
+        } else {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+void DestroyHcCond(HcCondition* hcCond)
+{
+    if (hcCond == NULL) {
+        return;
+    }
+
+    if (hcCond->innerMutex && hcCond->mutex) {
+        DestroyHcMutex(hcCond->mutex);
+        HcFree(hcCond->mutex);
+        hcCond->mutex = NULL;
+    }
+    pthread_cond_destroy(&hcCond->cond);
+}
+
+#ifdef __cplusplus
+}
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/src/linux/hc_init_protection.c deviceauth_new/hals/src/linux/hc_init_protection.c
--- deviceauth/hals/src/linux/hc_init_protection.c	2025-02-12 16:28:23.545556300 +0800
+++ deviceauth_new/hals/src/linux/hc_init_protection.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,45 +1,45 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_init_protection.h"
-#include <stdbool.h>
-
-static bool g_isInitialized = false;
-
-int CheckInit()
-{
-    if (g_isInitialized) {
-        return FINISH_INIT;
-    }
-    return CONTINUE_INIT;
-}
-
-int CheckDestroy()
-{
-    if (!g_isInitialized) {
-        return FINISH_DESTROY;
-    }
-    return CONTINUE_DESTROY;
-}
-
-void SetInitStatus()
-{
-    g_isInitialized = true;
-}
-
-void SetDeInitStatus()
-{
-    g_isInitialized = false;
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_init_protection.h"
+#include <stdbool.h>
+
+static bool g_isInitialized = false;
+
+int CheckInit()
+{
+    if (g_isInitialized) {
+        return FINISH_INIT;
+    }
+    return CONTINUE_INIT;
+}
+
+int CheckDestroy()
+{
+    if (!g_isInitialized) {
+        return FINISH_DESTROY;
+    }
+    return CONTINUE_DESTROY;
+}
+
+void SetInitStatus()
+{
+    g_isInitialized = true;
+}
+
+void SetDeInitStatus()
+{
+    g_isInitialized = false;
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/linux/hc_mutex.c deviceauth_new/hals/src/linux/hc_mutex.c
--- deviceauth/hals/src/linux/hc_mutex.c	2025-02-12 16:28:23.578789500 +0800
+++ deviceauth_new/hals/src/linux/hc_mutex.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,62 +1,62 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_mutex.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int MutexLock(HcMutex* mutex)
-{
-    if (mutex == NULL) {
-        return -1;
-    }
-    return -pthread_mutex_lock(&mutex->mutex);
-}
-
-void MutexUnlock(HcMutex* mutex)
-{
-    if (mutex == NULL) {
-        return;
-    }
-    pthread_mutex_unlock(&mutex->mutex);
-}
-
-int32_t InitHcMutex(struct HcMutexT* mutex)
-{
-    if (mutex == NULL) {
-        return -1;
-    }
-    int res = pthread_mutex_init(&mutex->mutex, NULL);
-    if (res != 0) {
-        return res;
-    }
-    mutex->lock = MutexLock;
-    mutex->unlock = MutexUnlock;
-    return res;
-}
-
-void DestroyHcMutex(struct HcMutexT* mutex)
-{
-    if (mutex == NULL) {
-        return;
-    }
-    pthread_mutex_destroy(&mutex->mutex);
-}
-
-#ifdef __cplusplus
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_mutex.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int MutexLock(HcMutex* mutex)
+{
+    if (mutex == NULL) {
+        return -1;
+    }
+    return -pthread_mutex_lock(&mutex->mutex);
+}
+
+void MutexUnlock(HcMutex* mutex)
+{
+    if (mutex == NULL) {
+        return;
+    }
+    pthread_mutex_unlock(&mutex->mutex);
+}
+
+int32_t InitHcMutex(struct HcMutexT* mutex)
+{
+    if (mutex == NULL) {
+        return -1;
+    }
+    int res = pthread_mutex_init(&mutex->mutex, NULL);
+    if (res != 0) {
+        return res;
+    }
+    mutex->lock = MutexLock;
+    mutex->unlock = MutexUnlock;
+    return res;
+}
+
+void DestroyHcMutex(struct HcMutexT* mutex)
+{
+    if (mutex == NULL) {
+        return;
+    }
+    pthread_mutex_destroy(&mutex->mutex);
+}
+
+#ifdef __cplusplus
+}
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/src/linux/hc_thread.c deviceauth_new/hals/src/linux/hc_thread.c
--- deviceauth/hals/src/linux/hc_thread.c	2025-02-12 16:28:23.607061200 +0800
+++ deviceauth_new/hals/src/linux/hc_thread.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,154 +1,154 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_thread.h"
-#include "hc_error.h"
-#include "hc_log.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define MAX_THREAD_STACK_SIZE (8 * 1024 * 1024)
-
-void* StaticThreadFunc(void* args)
-{
-    HcThread* thread = (HcThread*)args;
-    if (thread == NULL) {
-        return NULL;
-    }
-
-    if (thread->threadFunc) {
-        thread->threadFunc(args);
-    }
-    thread->threadLock.lock(&thread->threadLock);
-    thread->running = HC_FALSE;
-    thread->threadWaitObj.notifyWithoutLock(&thread->threadWaitObj);
-    thread->threadLock.unlock(&thread->threadLock);
-    return 0;
-}
-
-int Start(struct HcThreadT* thread)
-{
-    if (thread == NULL) {
-        return HAL_ERR_NULL_PTR;
-    }
-    thread->threadLock.lock(&thread->threadLock);
-    if (thread->running) {
-        thread->threadLock.unlock(&thread->threadLock);
-        return 0;
-    }
-    thread->running = HC_TRUE;
-
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-    if (thread->stackSize > 0 && thread->stackSize <= MAX_THREAD_STACK_SIZE) {
-        pthread_attr_setstacksize(&attr, thread->stackSize);
-    }
-
-    int result = pthread_create(&thread->thread, &attr, StaticThreadFunc, thread);
-    pthread_attr_destroy(&attr);
-
-    if (result != 0) {
-        LOGE("pthread_create failed.");
-        thread->running = HC_FALSE;
-    }
-    thread->threadLock.unlock(&thread->threadLock);
-    return result;
-}
-
-void Join(struct HcThreadT* thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-    thread->threadLock.lock(&thread->threadLock);
-    if (thread->running) {
-        thread->threadWaitObj.waitWithoutLock(&thread->threadWaitObj);
-    }
-    thread->threadLock.unlock(&thread->threadLock);
-}
-
-void BizWait(struct HcThreadT* thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-    thread->bizWaitObj.wait(&thread->bizWaitObj);
-}
-
-void BizNotify(struct HcThreadT* thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-    thread->bizWaitObj.notify(&thread->bizWaitObj);
-}
-
-int32_t InitThread(HcThread* thread, ThreadFunc func, size_t stackSize, const char* threadName)
-{
-    if (thread == NULL) {
-        return -1;
-    }
-
-    thread->threadFunc = func;
-    thread->start = Start;
-    thread->wait = BizWait;
-    thread->notify = BizNotify;
-    thread->join = Join;
-    thread->stackSize = stackSize;
-    thread->running = HC_FALSE;
-    thread->name = CreateString();
-    if (StringSetPointer(&thread->name, threadName) != HC_TRUE) {
-        return -1;
-    }
-
-    int32_t res = InitHcMutex(&thread->threadLock);
-    if (res != 0) {
-        DeleteString(&thread->name);
-        return res;
-    }
-    res = InitHcCond(&thread->threadWaitObj, &thread->threadLock);
-    if (res != 0) {
-        DeleteString(&thread->name);
-        DestroyHcMutex(&thread->threadLock);
-        return res;
-    }
-    res = InitHcCond(&thread->bizWaitObj, NULL);
-    if (res != 0) {
-        DeleteString(&thread->name);
-        DestroyHcMutex(&thread->threadLock);
-        DestroyHcCond(&thread->threadWaitObj);
-    }
-    return res;
-}
-
-void DestroyThread(HcThread* thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-
-    DestroyHcCond(&thread->bizWaitObj);
-    DestroyHcCond(&thread->threadWaitObj);
-    DestroyHcMutex(&thread->threadLock);
-    DeleteString(&thread->name);
-}
-
-#ifdef __cplusplus
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_thread.h"
+#include "hc_error.h"
+#include "hc_log.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MAX_THREAD_STACK_SIZE (8 * 1024 * 1024)
+
+void* StaticThreadFunc(void* args)
+{
+    HcThread* thread = (HcThread*)args;
+    if (thread == NULL) {
+        return NULL;
+    }
+
+    if (thread->threadFunc) {
+        thread->threadFunc(args);
+    }
+    thread->threadLock.lock(&thread->threadLock);
+    thread->running = HC_FALSE;
+    thread->threadWaitObj.notifyWithoutLock(&thread->threadWaitObj);
+    thread->threadLock.unlock(&thread->threadLock);
+    return 0;
+}
+
+int Start(struct HcThreadT* thread)
+{
+    if (thread == NULL) {
+        return HAL_ERR_NULL_PTR;
+    }
+    thread->threadLock.lock(&thread->threadLock);
+    if (thread->running) {
+        thread->threadLock.unlock(&thread->threadLock);
+        return 0;
+    }
+    thread->running = HC_TRUE;
+
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    if (thread->stackSize > 0 && thread->stackSize <= MAX_THREAD_STACK_SIZE) {
+        pthread_attr_setstacksize(&attr, thread->stackSize);
+    }
+
+    int result = pthread_create(&thread->thread, &attr, StaticThreadFunc, thread);
+    pthread_attr_destroy(&attr);
+
+    if (result != 0) {
+        LOGE("pthread_create failed.");
+        thread->running = HC_FALSE;
+    }
+    thread->threadLock.unlock(&thread->threadLock);
+    return result;
+}
+
+void Join(struct HcThreadT* thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+    thread->threadLock.lock(&thread->threadLock);
+    if (thread->running) {
+        thread->threadWaitObj.waitWithoutLock(&thread->threadWaitObj);
+    }
+    thread->threadLock.unlock(&thread->threadLock);
+}
+
+void BizWait(struct HcThreadT* thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+    thread->bizWaitObj.wait(&thread->bizWaitObj);
+}
+
+void BizNotify(struct HcThreadT* thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+    thread->bizWaitObj.notify(&thread->bizWaitObj);
+}
+
+int32_t InitThread(HcThread* thread, ThreadFunc func, size_t stackSize, const char* threadName)
+{
+    if (thread == NULL) {
+        return -1;
+    }
+
+    thread->threadFunc = func;
+    thread->start = Start;
+    thread->wait = BizWait;
+    thread->notify = BizNotify;
+    thread->join = Join;
+    thread->stackSize = stackSize;
+    thread->running = HC_FALSE;
+    thread->name = CreateString();
+    if (StringSetPointer(&thread->name, threadName) != HC_TRUE) {
+        return -1;
+    }
+
+    int32_t res = InitHcMutex(&thread->threadLock);
+    if (res != 0) {
+        DeleteString(&thread->name);
+        return res;
+    }
+    res = InitHcCond(&thread->threadWaitObj, &thread->threadLock);
+    if (res != 0) {
+        DeleteString(&thread->name);
+        DestroyHcMutex(&thread->threadLock);
+        return res;
+    }
+    res = InitHcCond(&thread->bizWaitObj, NULL);
+    if (res != 0) {
+        DeleteString(&thread->name);
+        DestroyHcMutex(&thread->threadLock);
+        DestroyHcCond(&thread->threadWaitObj);
+    }
+    return res;
+}
+
+void DestroyThread(HcThread* thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+
+    DestroyHcCond(&thread->bizWaitObj);
+    DestroyHcCond(&thread->threadWaitObj);
+    DestroyHcMutex(&thread->threadLock);
+    DeleteString(&thread->name);
+}
+
+#ifdef __cplusplus
+}
 #endif
\ No newline at end of file
diff -Naru deviceauth/hals/src/linux/hc_time.c deviceauth_new/hals/src/linux/hc_time.c
--- deviceauth/hals/src/linux/hc_time.c	2025-02-12 16:28:23.640788700 +0800
+++ deviceauth_new/hals/src/linux/hc_time.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,57 +1,57 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_time.h"
-#include <stdio.h>
-#include <time.h>
-#include "hc_log.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int64_t HcGetCurTime()
-{
-    struct timespec start;
-    int res = clock_gettime(CLOCK_MONOTONIC, &start);
-    if (res != 0) {
-        LOGE("clock_gettime failed, res:%d", res);
-        return -1;
-    }
-    return start.tv_sec;
-}
-
-int64_t HcGetIntervalTime(int64_t startTime)
-{
-    if (startTime < 0) {
-        LOGE("Start time is invalid");
-        return -1;
-    }
-    struct timespec end;
-    int res = clock_gettime(CLOCK_MONOTONIC, &end);
-    if (res != 0) {
-        LOGE("clock_gettime failed, res:%d", res);
-        return -1;
-    }
-    if (end.tv_sec < startTime) {
-        LOGE("End time is invalid");
-        return -1;
-    }
-    return (end.tv_sec - startTime);
-}
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_time.h"
+#include <stdio.h>
+#include <time.h>
+#include "hc_log.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int64_t HcGetCurTime()
+{
+    struct timespec start;
+    int res = clock_gettime(CLOCK_MONOTONIC, &start);
+    if (res != 0) {
+        LOGE("clock_gettime failed, res:%d", res);
+        return -1;
+    }
+    return start.tv_sec;
+}
+
+int64_t HcGetIntervalTime(int64_t startTime)
+{
+    if (startTime < 0) {
+        LOGE("Start time is invalid");
+        return -1;
+    }
+    struct timespec end;
+    int res = clock_gettime(CLOCK_MONOTONIC, &end);
+    if (res != 0) {
+        LOGE("clock_gettime failed, res:%d", res);
+        return -1;
+    }
+    if (end.tv_sec < startTime) {
+        LOGE("End time is invalid");
+        return -1;
+    }
+    return (end.tv_sec - startTime);
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -Naru deviceauth/hals/src/linux/hc_types.c deviceauth_new/hals/src/linux/hc_types.c
--- deviceauth/hals/src/linux/hc_types.c	2025-02-12 16:28:23.672533700 +0800
+++ deviceauth_new/hals/src/linux/hc_types.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,74 +1,74 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_types.h"
-#include "hc_log.h"
-#include "securec.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void* HcMalloc(uint32_t size, char val)
-{
-    if (size == 0) {
-        LOGE("Malloc size is invalid.");
-        return NULL;
-    }
-    void* addr = malloc(size);
-    if (addr != NULL) {
-        (void)memset_s(addr, size, val, size);
-    }
-    return addr;
-}
-
-void HcFree(void* addr)
-{
-    if (addr != NULL) {
-        free(addr);
-    }
-}
-
-uint32_t HcStrlen(const char *str)
-{
-    if (str == NULL) {
-        return 0;
-    }
-    const char *p = str;
-    while (*p++ != '\0') {}
-    return p - str - 1;
-}
-
-const char *HcFmtLogData(const char *funName, char *out, int32_t outSz, const char *fmtStr, ...)
-{
-    int32_t ret;
-    int32_t cnt;
-    int32_t n = 0;
-    va_list arglist;
-
-    cnt = sprintf_s(out, outSz, "%s: ", funName);
-    if (cnt <= 0) {
-        return NULL;
-    }
-    n += cnt;
-    va_start(arglist, fmtStr);
-    ret = vsprintf_s(out + n, outSz - n, fmtStr, arglist);
-    va_end(arglist);
-    return (ret > 0) ? ((const char *)out) : NULL;
-}
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_types.h"
+#include "hc_log.h"
+#include "securec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void* HcMalloc(uint32_t size, char val)
+{
+    if (size == 0) {
+        LOGE("Malloc size is invalid.");
+        return NULL;
+    }
+    void* addr = malloc(size);
+    if (addr != NULL) {
+        (void)memset_s(addr, size, val, size);
+    }
+    return addr;
+}
+
+void HcFree(void* addr)
+{
+    if (addr != NULL) {
+        free(addr);
+    }
+}
+
+uint32_t HcStrlen(const char *str)
+{
+    if (str == NULL) {
+        return 0;
+    }
+    const char *p = str;
+    while (*p++ != '\0') {}
+    return p - str - 1;
+}
+
+const char *HcFmtLogData(const char *funName, char *out, int32_t outSz, const char *fmtStr, ...)
+{
+    int32_t ret;
+    int32_t cnt;
+    int32_t n = 0;
+    va_list arglist;
+
+    cnt = sprintf_s(out, outSz, "%s: ", funName);
+    if (cnt <= 0) {
+        return NULL;
+    }
+    n += cnt;
+    va_start(arglist, fmtStr);
+    ret = vsprintf_s(out + n, outSz - n, fmtStr, arglist);
+    va_end(arglist);
+    return (ret > 0) ? ((const char *)out) : NULL;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -Naru deviceauth/hals/src/linux/lite/huks_adapter.c deviceauth_new/hals/src/linux/lite/huks_adapter.c
--- deviceauth/hals/src/linux/lite/huks_adapter.c	2025-02-12 16:28:23.710229200 +0800
+++ deviceauth_new/hals/src/linux/lite/huks_adapter.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,1127 +1,1127 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "huks_adapter.h"
-#include "common_util.h"
-#include "hc_log.h"
-#include "hks_api.h"
-#include "hks_param.h"
-#include "hks_type.h"
-#include "mbedtls_hash_to_point.h"
-
-static enum HksKeyAlg g_algToHksAlgorithm[] = {
-    HKS_ALG_ED25519,
-    HKS_ALG_X25519,
-    HKS_ALG_ECC
-};
-
-static int32_t BaseCheckParams(const Uint8Buff **inParams, const char **paramTags, uint32_t len)
-{
-    for (uint32_t i = 0; i < len; i++) {
-        CHECK_PTR_RETURN_HAL_ERROR_CODE(inParams[i], paramTags[i]);
-        CHECK_PTR_RETURN_HAL_ERROR_CODE(inParams[i]->val, paramTags[i]);
-        CHECK_LEN_ZERO_RETURN_ERROR_CODE(inParams[i]->length, paramTags[i]);
-    }
-    return HAL_SUCCESS;
-}
-
-static int32_t ConstructParamSet(struct HksParamSet **out, const struct HksParam *inParam,
-    const uint32_t inParamNum)
-{
-    struct HksParamSet *paramSet = NULL;
-    int32_t ret = HksInitParamSet(&paramSet);
-    if (ret != HKS_SUCCESS) {
-        LOGE("init param set failed, ret = %d", ret);
-        return HAL_ERR_INIT_PARAM_SET_FAILED;
-    }
-
-    ret = HksAddParams(paramSet, inParam, inParamNum);
-    if (ret != HKS_SUCCESS) {
-        LOGE("add param failed, ret = %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_ERR_ADD_PARAM_FAILED;
-    }
-
-    ret = HksBuildParamSet(&paramSet);
-    if (ret != HKS_SUCCESS) {
-        LOGE("build param set failed, ret = %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_ERR_BUILD_PARAM_SET_FAILED;
-    }
-
-    *out = paramSet;
-    return HAL_SUCCESS;
-}
-
-static int32_t InitHks()
-{
-    return HksInitialize();
-}
-
-static int32_t Sha256(const Uint8Buff *message, Uint8Buff *hash)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(message, "message");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(message->val, "message->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(message->length, "message->length");
-
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash, "hash");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash->val, "hash->val");
-    CHECK_LEN_EQUAL_RETURN(hash->length, SHA256_LEN, "hash->length");
-
-    struct HksBlob srcBlob = { message->length, message->val };
-    struct HksBlob hashBlob = { hash->length, hash->val };
-    struct HksParamSet *paramSet = NULL;
-    struct HksParam digestParam[] = {
-        {
-            .tag = HKS_TAG_DIGEST,
-            .uint32Param = HKS_DIGEST_SHA256
-        }
-    };
-    int32_t ret = ConstructParamSet(&paramSet, digestParam, CAL_ARRAY_SIZE(digestParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("construct param set failed, ret = %d", ret);
-        return ret;
-    }
-
-    ret = HksHash(paramSet, &srcBlob, &hashBlob);
-    if (ret != HKS_SUCCESS || hashBlob.size != SHA256_LEN) {
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t GenerateRandom(Uint8Buff *rand)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(rand, "rand");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(rand->val, "rand->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(rand->length, "rand->length");
-
-    struct HksBlob randBlob = { rand->length, rand->val };
-    int32_t ret = HksGenerateRandom(NULL, &randBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Generate random failed, ret: %d", ret);
-        return HAL_FAILED;
-    }
-
-    return HAL_SUCCESS;
-}
-
-static int32_t CheckKeyExist(const Uint8Buff *keyAlias)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
-
-    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
-    int32_t ret = HksKeyExist(&keyAliasBlob, NULL);
-    if (ret != HKS_SUCCESS) {
-        LOGI("Hks check key exist or not, ret = %d", ret);
-        return HAL_FAILED;
-    }
-
-    return HAL_SUCCESS;
-}
-
-static int32_t DeleteKey(const Uint8Buff *keyAlias)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
-
-    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
-    int32_t ret = HksDeleteKey(&keyAliasBlob, NULL);
-    if (ret == HKS_ERROR_NOT_EXIST) {
-        LOGI("Key not exists.");
-        return HAL_SUCCESS;
-    }
-    if (ret != HKS_SUCCESS) {
-        LOGE("Delete key failed, ret = %d", ret);
-        return HAL_FAILED;
-    }
-
-    return HAL_SUCCESS;
-}
-
-static int32_t ComputeHmac(const Uint8Buff *key, const Uint8Buff *message, Uint8Buff *outHmac, bool isAlias)
-{
-    const Uint8Buff *inParams[] = { key, message, outHmac };
-    const char *paramTags[] = {"key", "message", "outHmac"};
-    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-    CHECK_LEN_EQUAL_RETURN(outHmac->length, HMAC_LEN, "outHmac->length");
-
-    struct HksBlob keyBlob = { key->length, key->val };
-    struct HksBlob srcBlob = { message->length, message->val };
-    struct HksBlob hmacBlob = { outHmac->length, outHmac->val };
-    struct HksParamSet *paramSet = NULL;
-    struct HksParam hmacParam[] = {
-        {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_MAC
-        }, {
-            .tag = HKS_TAG_DIGEST,
-            .uint32Param = HKS_DIGEST_SHA256
-        }, {
-            .tag = HKS_TAG_IS_KEY_ALIAS,
-            .boolParam = isAlias
-        }
-    };
-    ret = ConstructParamSet(&paramSet, hmacParam, CAL_ARRAY_SIZE(hmacParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("construct param set failed, ret = %d", ret);
-        return ret;
-    }
-
-    ret = HksMac(&keyBlob, paramSet, &srcBlob, &hmacBlob);
-    if (ret != HKS_SUCCESS  || hmacBlob.size != HMAC_LEN) {
-        LOGE("Hmac failed, ret: %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t ComputeHkdf(const Uint8Buff *baseKey, const Uint8Buff *salt, const Uint8Buff *keyInfo,
-    Uint8Buff *outHkdf, bool isAlias)
-{
-    const Uint8Buff *inParams[] = { baseKey, salt, outHkdf };
-    const char *paramTags[] = { "baseKey", "salt", "outHkdf" };
-    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    struct HksBlob srcKeyBlob = { baseKey->length, baseKey->val };
-    struct HksBlob saltBlob = { salt->length, salt->val };
-    struct HksBlob keyInfoBlob = { 0, NULL };
-    if (keyInfo != NULL) {
-        keyInfoBlob.size = keyInfo->length;
-        keyInfoBlob.data = keyInfo->val;
-    }
-    struct HksBlob derivedKeyBlob = { outHkdf->length, outHkdf->val };
-
-    struct HksParamSet *paramSet = NULL;
-    struct HksParam hkdfParam[] = {
-        {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_DERIVE
-        }, {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = HKS_ALG_HKDF
-        }, {
-            .tag = HKS_TAG_DIGEST,
-            .uint32Param = HKS_DIGEST_SHA256
-        }, {
-            .tag = HKS_TAG_SALT,
-            .blob = saltBlob
-        }, {
-            .tag = HKS_TAG_INFO,
-            .blob = keyInfoBlob
-        }, {
-            .tag = HKS_TAG_IS_KEY_ALIAS,
-            .boolParam = isAlias
-        }
-    };
-
-    ret = ConstructParamSet(&paramSet, hkdfParam, CAL_ARRAY_SIZE(hkdfParam));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    ret = HksDeriveKey(paramSet, &srcKeyBlob, &derivedKeyBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Key derivation failed, ret: %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t CheckAesGcmEncryptParam(const Uint8Buff *key, const Uint8Buff *plain, const GcmParam *encryptInfo,
-    Uint8Buff *outCipher)
-{
-    const Uint8Buff *inParams[] = { key, plain, outCipher };
-    const char* paramTags[] = { "key", "plain", "outCipher" };
-    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(encryptInfo, "encryptInfo");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(encryptInfo->aad, "aad");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(encryptInfo->aadLen, "aadLen");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(encryptInfo->nonce, "nonce");
-    CHECK_LEN_LOWER_RETURN(encryptInfo->nonceLen, HKS_AE_NONCE_LEN, "nonceLen");
-    CHECK_LEN_LOWER_RETURN(outCipher->length, plain->length + HKS_AE_TAG_LEN, "outCipher");
-
-    return HAL_SUCCESS;
-}
-
-static int32_t AesGcmEncrypt(const Uint8Buff *key, const Uint8Buff *plain,
-    const GcmParam *encryptInfo, bool isAlias, Uint8Buff *outCipher)
-{
-    int32_t ret = CheckAesGcmEncryptParam(key, plain, encryptInfo, outCipher);
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    struct HksBlob keyBlob = { key->length, key->val };
-    struct HksBlob plainBlob = { plain->length, plain->val };
-    struct HksBlob cipherBlob = { outCipher->length, outCipher->val };
-
-    struct HksParamSet *paramSet = NULL;
-    struct HksParam encryptParam[] = {
-        {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_ENCRYPT
-        }, {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = HKS_ALG_AES
-        }, {
-            .tag = HKS_TAG_BLOCK_MODE,
-            .uint32Param = HKS_MODE_GCM
-        }, {
-            .tag = HKS_TAG_PADDING,
-            .uint32Param = HKS_PADDING_NONE
-        }, {
-            .tag = HKS_TAG_NONCE,
-            .blob = { encryptInfo->nonceLen, encryptInfo->nonce }
-        }, {
-            .tag = HKS_TAG_ASSOCIATED_DATA,
-            .blob = { encryptInfo->aadLen, encryptInfo->aad }
-        }, {
-            .tag = HKS_TAG_IS_KEY_ALIAS,
-            .boolParam = isAlias
-        }
-    };
-
-    ret = ConstructParamSet(&paramSet, encryptParam, CAL_ARRAY_SIZE(encryptParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("construct param set failed, ret = %d", ret);
-        return ret;
-    }
-
-    ret = HksEncrypt(&keyBlob, paramSet, &plainBlob, &cipherBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Aes-gcm encrypt failed, ret: %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t CheckAesGcmDecryptParam(const Uint8Buff *key, const Uint8Buff *cipher, const GcmParam *decryptInfo,
-    Uint8Buff *outPlain)
-{
-    const Uint8Buff *inParams[] = { key, cipher, outPlain };
-    const char *paramTags[] = { "key", "cipher", "outPlain" };
-    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(decryptInfo, "decryptInfo");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(decryptInfo->aad, "aad");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(decryptInfo->aadLen, "aadLen");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(decryptInfo->nonce, "nonce");
-    CHECK_LEN_LOWER_RETURN(decryptInfo->nonceLen, HKS_AE_NONCE_LEN, "nonceLen");
-    CHECK_LEN_LOWER_RETURN(outPlain->length, cipher->length - HKS_AE_TAG_LEN, "outPlain");
-
-    return HAL_SUCCESS;
-}
-
-static int32_t AesGcmDecrypt(const Uint8Buff *key, const Uint8Buff *cipher,
-    const GcmParam *decryptInfo, bool isAlias, Uint8Buff *outPlain)
-{
-    int32_t ret = CheckAesGcmDecryptParam(key, cipher, decryptInfo, outPlain);
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    struct HksBlob keyBlob = { key->length, key->val };
-    struct HksBlob cipherBlob = { cipher->length, cipher->val };
-    struct HksBlob plainBlob = { outPlain->length, outPlain->val };
-
-    struct HksParamSet *paramSet = NULL;
-    struct HksParam decryptParam[] = {
-        {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_DECRYPT
-        }, {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = HKS_ALG_AES
-        }, {
-            .tag = HKS_TAG_BLOCK_MODE,
-            .uint32Param = HKS_MODE_GCM
-        }, {
-            .tag = HKS_TAG_PADDING,
-            .uint32Param = HKS_PADDING_NONE
-        }, {
-            .tag = HKS_TAG_NONCE,
-            .blob = { decryptInfo->nonceLen, decryptInfo->nonce }
-        }, {
-            .tag = HKS_TAG_ASSOCIATED_DATA,
-            .blob = { decryptInfo->aadLen, decryptInfo->aad }
-        }, {
-            .tag = HKS_TAG_IS_KEY_ALIAS,
-            .boolParam = isAlias
-        }
-    };
-
-    ret = ConstructParamSet(&paramSet, decryptParam, CAL_ARRAY_SIZE(decryptParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("construct param set failed, ret = %d", ret);
-        return ret;
-    }
-
-    ret = HksDecrypt(&keyBlob, paramSet, &cipherBlob, &plainBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Aes-gcm decrypt failed, ret: %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t HashToPoint(const Uint8Buff *hash, Algorithm algo, Uint8Buff *outEcPoint)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash, "hash");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash->val, "hash->va");
-    CHECK_LEN_EQUAL_RETURN(hash->length, SHA256_LEN, "hash->length");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outEcPoint, "outEcPoint");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outEcPoint->val, "outEcPoint->va");
-    CHECK_LEN_EQUAL_RETURN(outEcPoint->length, SHA256_LEN, "outEcPoint->length");
-
-    if (algo != X25519) {
-        LOGE("Invalid algo: %d.", algo);
-        return HAL_ERR_INVALID_PARAM;
-    }
-
-    int32_t ret = MbedtlsHashToPoint(hash, outEcPoint);
-    if (ret != 0) {
-        LOGE("Hks hashToPoint failed, ret: %d", ret);
-        return HAL_FAILED;
-    }
-
-    return HAL_SUCCESS;
-}
-
-static int32_t ConstructAgreeWithStorageParams(struct HksParamSet **paramSet, uint32_t keyLen, Algorithm algo,
-    const KeyBuff *priKey, const KeyBuff *pubKey)
-{
-    struct HksBlob priKeyBlob = { priKey->keyLen, priKey->key };
-    struct HksBlob pubKeyBlob = { pubKey->keyLen, pubKey->key };
-    struct HksParam agreeParam[] = {
-        {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = HKS_ALG_AES
-        }, {
-            .tag = HKS_TAG_KEY_SIZE,
-            .uint32Param = keyLen * BITS_PER_BYTE
-        }, {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_DERIVE
-        }, {
-            .tag = HKS_TAG_DIGEST,
-            .uint32Param = HKS_DIGEST_SHA256
-        }, {
-            .tag = HKS_TAG_KEY_GENERATE_TYPE,
-            .uint32Param = HKS_KEY_GENERATE_TYPE_AGREE
-        }, {
-            .tag = HKS_TAG_AGREE_ALG,
-            .uint32Param = g_algToHksAlgorithm[algo]
-        }, {
-            .tag = HKS_TAG_AGREE_PRIVATE_KEY_ALIAS,
-            .blob = priKeyBlob
-        }, {
-            .tag = HKS_TAG_AGREE_PUBLIC_KEY,
-            .blob = pubKeyBlob
-        }, {
-            .tag = HKS_TAG_AGREE_PUBLIC_KEY_IS_KEY_ALIAS,
-            .boolParam = pubKey->isAlias
-        }
-    };
-
-    int32_t ret = ConstructParamSet(paramSet, agreeParam, CAL_ARRAY_SIZE(agreeParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("Construct param set failed, ret = %d", ret);
-        return ret;
-    }
-    return ret;
-}
-
-static int32_t AgreeSharedSecretWithStorage(const KeyBuff *priKey, const KeyBuff *pubKey, Algorithm algo,
-    uint32_t sharedKeyLen, const Uint8Buff *sharedKeyAlias)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey, "priKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey->key, "priKey->key");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(priKey->keyLen, "priKey->keyLen");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey, "pubKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey->key, "pubKey->key");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(pubKey->keyLen, "pubKey->keyLen");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKeyAlias, "sharedKeyAlias");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKeyAlias->val, "sharedKeyAlias->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(sharedKeyAlias->length, "sharedKeyAlias->length");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(sharedKeyLen, "sharedKeyLen");
-
-    struct HksBlob sharedKeyAliasBlob = { sharedKeyAlias->length, sharedKeyAlias->val };
-    struct HksParamSet *paramSet = NULL;
-    int32_t ret = ConstructAgreeWithStorageParams(&paramSet, sharedKeyLen, algo, priKey, pubKey);
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    ret = HksGenerateKey(&sharedKeyAliasBlob, paramSet, NULL);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Hks agree key with storage failed, ret = %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t AgreeSharedSecret(const KeyBuff *priKey, const KeyBuff *pubKey, Algorithm algo, Uint8Buff *sharedKey)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey, "priKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey->key, "priKey->key");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(priKey->keyLen, "priKey->keyLen");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey, "pubKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey->key, "pubKey->key");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(pubKey->keyLen, "pubKey->keyLen");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKey, "sharedKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKey->val, "sharedKey->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(sharedKey->length, "sharedKey->length");
-
-    struct HksBlob priKeyBlob = { priKey->keyLen, priKey->key };
-    struct HksBlob pubKeyBlob = { pubKey->keyLen, pubKey->key };
-    struct HksBlob sharedKeyBlob = { sharedKey->length, sharedKey->val };
-
-    struct HksParamSet *paramSet = NULL;
-    struct HksParam agreeParam[] = {
-        {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = g_algToHksAlgorithm[algo] // only support HKS_ALG_X25519 now
-        }, {
-            .tag = HKS_TAG_KEY_SIZE,
-            .uint32Param = sharedKey->length * BITS_PER_BYTE
-        }, {
-            .tag = HKS_TAG_IS_KEY_ALIAS,
-            .boolParam = priKey->isAlias
-        }
-    };
-
-    int32_t ret = ConstructParamSet(&paramSet, agreeParam, CAL_ARRAY_SIZE(agreeParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("Construct param set failed, ret = %d", ret);
-        return ret;
-    }
-
-    ret = HksAgreeKey(paramSet, &priKeyBlob, &pubKeyBlob, &sharedKeyBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Agree key failed, ret = %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t BigNumExpMod(const Uint8Buff *base, const Uint8Buff *exp, const char *bigNumHex, Uint8Buff *outNum)
-{
-    const Uint8Buff *inParams[] = { base, exp, outNum };
-    const char *paramTags[] = { "base", "exp", "outNum" };
-    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(bigNumHex, "bigNumHex");
-    uint32_t primeLen = strlen(bigNumHex) / BYTE_TO_HEX_OPER_LENGTH;
-    if ((primeLen != BIG_PRIME_LEN_384) && (primeLen != BIG_PRIME_LEN_256)) {
-        LOGE("Not support big number len %d", outNum->length);
-        return HAL_FAILED;
-    }
-    CHECK_LEN_EQUAL_RETURN(outNum->length, primeLen, "outNum->length");
-
-    struct HksBlob baseBlob = { base->length, base->val };
-    struct HksBlob expBlob = { exp->length, exp->val };
-    struct HksBlob outNumBlob = { outNum->length, outNum->val };
-    struct HksBlob bigNumBlob = { 0, NULL };
-    bigNumBlob.size = outNum->length;
-    bigNumBlob.data = (uint8_t *)HcMalloc(bigNumBlob.size, 0);
-    if (bigNumBlob.data == NULL) {
-        LOGE("malloc bigNumBlob.data failed.");
-        return HAL_ERR_BAD_ALLOC;
-    }
-    ret = HexStringToByte(bigNumHex, bigNumBlob.data, bigNumBlob.size);
-    if (ret != HAL_SUCCESS) {
-        LOGE("HexStringToByte for bigNumHex failed.");
-        HcFree(bigNumBlob.data);
-        return ret;
-    }
-
-    ret = HksBnExpMod(&outNumBlob, &baseBlob, &expBlob, &bigNumBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Huks calculate big number exp mod failed, ret = %d", ret);
-        HcFree(bigNumBlob.data);
-        return HAL_FAILED;
-    }
-    outNum->length = outNumBlob.size;
-
-    HcFree(bigNumBlob.data);
-    return HAL_SUCCESS;
-}
-
-static int32_t ConstructGenerateKeyPairWithStorageParams(struct HksParamSet **paramSet, Algorithm algo,
-    uint32_t keyLen, const struct HksBlob *authIdBlob)
-{
-    struct HksParam keyParam[] = {
-        {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = g_algToHksAlgorithm[algo]
-        }, {
-            .tag = HKS_TAG_KEY_STORAGE_FLAG,
-            .uint32Param = HKS_STORAGE_PERSISTENT
-        }, {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_SIGN | HKS_KEY_PURPOSE_VERIFY
-        }, {
-            .tag = HKS_TAG_KEY_SIZE,
-            .uint32Param = keyLen * BITS_PER_BYTE
-        }, {
-            .tag = HKS_TAG_KEY_AUTH_ID,
-            .blob = *authIdBlob
-        }
-    };
-
-    int32_t ret = ConstructParamSet(paramSet, keyParam, CAL_ARRAY_SIZE(keyParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("Construct param set failed, ret = %d", ret);
-        return ret;
-    }
-    return ret;
-}
-
-static int32_t GenerateKeyPairWithStorage(const Uint8Buff *keyAlias, uint32_t keyLen, Algorithm algo,
-    const ExtraInfo *exInfo)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo, "exInfo");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo->authId.val, "authId->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(exInfo->authId.length, "authId->length");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyLen, "keyLen");
-
-    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
-    struct HksBlob authIdBlob = { exInfo->authId.length, exInfo->authId.val };
-    struct HksParamSet *paramSet = NULL;
-    int32_t ret = ConstructGenerateKeyPairWithStorageParams(&paramSet, algo, keyLen, &authIdBlob);
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    ret = HksGenerateKey(&keyAliasBlob, paramSet, NULL);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Hks generate failed, ret=%d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t GetKeyPair(struct HksParamSet *outParamSet, Uint8Buff *outPriKey, Uint8Buff *outPubKey)
-{
-    int32_t ret = HksFreshParamSet(outParamSet, false); /* false means fresh by local, not through IPC */
-    if (ret != HKS_SUCCESS) {
-        LOGE("fresh param set failed, ret:%d", ret);
-        return HAL_ERR_FRESH_PARAM_SET_FAILED;
-    }
-
-    struct HksParam *pubKeyParam = NULL;
-    ret = HksGetParam(outParamSet, HKS_TAG_ASYMMETRIC_PUBLIC_KEY_DATA, &pubKeyParam);
-    if (ret != HKS_SUCCESS) {
-        LOGE("get pub key from param set failed, ret:%d", ret);
-        return HAL_ERR_GET_PARAM_FAILED;
-    }
-
-    struct HksParam *priKeyParam = NULL;
-    ret = HksGetParam(outParamSet, HKS_TAG_ASYMMETRIC_PRIVATE_KEY_DATA, &priKeyParam);
-    if (ret != HKS_SUCCESS) {
-        LOGE("get priv key from param set failed, ret:%d", ret);
-        return HAL_ERR_GET_PARAM_FAILED;
-    }
-
-    if (memcpy_s(outPubKey->val, outPubKey->length, pubKeyParam->blob.data, pubKeyParam->blob.size) != EOK) {
-        LOGE("parse x25519 output param set memcpy public key failed!");
-        return HAL_ERR_MEMORY_COPY;
-    }
-    outPubKey->length = pubKeyParam->blob.size;
-
-    if (memcpy_s(outPriKey->val, outPriKey->length, priKeyParam->blob.data, priKeyParam->blob.size) != EOK) {
-        LOGE("parse x25519 output param set memcpy private key failed!");
-        return HAL_ERR_MEMORY_COPY;
-    }
-    outPriKey->length = priKeyParam->blob.size;
-
-    return HAL_SUCCESS;
-}
-
-static int32_t ConstructGenerateKeyPairParams(struct HksParamSet **paramSet, Algorithm algo, uint32_t keyLen)
-{
-    struct HksParam keyParam[] = {
-        {
-            .tag = HKS_TAG_KEY_STORAGE_FLAG,
-            .uint32Param = HKS_STORAGE_TEMP
-        }, {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = g_algToHksAlgorithm[algo]
-        }, {
-            .tag = HKS_TAG_KEY_SIZE,
-            .uint32Param = keyLen * BITS_PER_BYTE
-        }, {
-            .tag = HKS_TAG_IS_KEY_ALIAS,
-            .uint32Param = false
-        }
-    };
-
-    int32_t ret = ConstructParamSet(paramSet, keyParam, CAL_ARRAY_SIZE(keyParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("Construct param set failed, ret = %d", ret);
-        return ret;
-    }
-    return ret;
-}
-
-static int32_t GenerateKeyPair(Algorithm algo, Uint8Buff *outPriKey, Uint8Buff *outPubKey)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPriKey, "outPriKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPriKey->val, "outPriKey->key");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(outPriKey->length, "outPriKey->keyLen");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey, "outPubKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey->val, "outPubKey->key");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(outPubKey->length, "outPubKey->keyLen");
-
-    if (outPriKey->length != outPubKey->length) {
-        LOGE("key len not equal.");
-        return HAL_ERR_INVALID_LEN;
-    }
-    uint32_t keyLen = outPriKey->length;
-
-    struct HksParamSet *paramSet = NULL;
-    struct HksParamSet *outParamSet = NULL;
-    int32_t ret = ConstructGenerateKeyPairParams(&paramSet, algo, keyLen);
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    /* need 2 HksParam struct for outPriKey and outPubKey */
-    uint32_t outParamSetSize = sizeof(struct HksParamSet) +
-        2 * (sizeof(struct HksParam)) + outPriKey->length + outPubKey->length;
-    outParamSet = (struct HksParamSet *)HcMalloc(outParamSetSize, 0);
-    if (outParamSet == NULL) {
-        LOGE("allocate buffer for output param set failed");
-        ret = HAL_ERR_BAD_ALLOC;
-        goto err;
-    }
-    outParamSet->paramSetSize = outParamSetSize;
-
-    ret = HksGenerateKey(NULL, paramSet, outParamSet);
-    if (ret != HKS_SUCCESS) {
-        LOGE("generate x25519 key failed, ret:%d", ret);
-        ret = HAL_FAILED;
-        goto err;
-    }
-
-    ret = GetKeyPair(outParamSet, outPriKey, outPubKey);
-    if (ret != HAL_SUCCESS) {
-        LOGE("parse x25519 output param set failed, ret:%d", ret);
-        goto err;
-    }
-err:
-    HksFreeParamSet(&paramSet);
-    HcFree(outParamSet);
-    return ret;
-}
-
-static int32_t ExportPublicKey(const Uint8Buff *keyAlias, Uint8Buff *outPubKey)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey, "outPubKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey->val, "outPubKey->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(outPubKey->length, "outPubKey->length");
-
-    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
-    struct HksBlob keyBlob = { outPubKey->length, outPubKey->val };
-
-    int32_t ret = HksExportPublicKey(&keyAliasBlob, NULL, &keyBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Export public key failed, ret=%d", ret);
-        return HAL_FAILED;
-    }
-    outPubKey->length = keyBlob.size;
-
-    return HAL_SUCCESS;
-}
-
-static int32_t ConstructSignParams(struct HksParamSet **paramSet, Algorithm algo)
-{
-    struct HksParam signParam[] = {
-        {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_SIGN
-        }, {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = g_algToHksAlgorithm[algo] // only support HKS_ALG_ED25519
-        }
-    };
-
-    int32_t ret = ConstructParamSet(paramSet, signParam, CAL_ARRAY_SIZE(signParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("Construct param set failed, ret = %d", ret);
-        return ret;
-    }
-    return ret;
-}
-
-static int32_t Sign(const Uint8Buff *keyAlias, const Uint8Buff *message, Algorithm algo,
-    Uint8Buff *outSignature, bool isAlias)
-{
-    struct HksParamSet *paramSet = NULL;
-    const Uint8Buff *inParams[] = { keyAlias, message, outSignature };
-    const char *paramTags[] = { "keyAlias", "message", "outSignature" };
-    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-    CHECK_LEN_EQUAL_RETURN(outSignature->length, SIGNATURE_LEN, "outSignature->length");
-
-    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
-    Uint8Buff messageHash = { NULL, 0 };
-    messageHash.length = SHA256_LEN;
-    messageHash.val = (uint8_t *)HcMalloc(messageHash.length, 0);
-    if (messageHash.val == NULL) {
-        LOGE("malloc messageHash.data failed.");
-        ret = HAL_ERR_BAD_ALLOC;
-        goto err;
-    }
-    ret = Sha256(message, &messageHash);
-    if (ret != HAL_SUCCESS) {
-        LOGE("Sha256 failed.");
-        goto err;
-    }
-    struct HksBlob messageBlob = { messageHash.length, messageHash.val };
-    struct HksBlob signatureBlob = { outSignature->length, outSignature->val };
-
-    ret = ConstructSignParams(&paramSet, algo);
-    if (ret != HAL_SUCCESS) {
-        goto err;
-    }
-
-    ret = HksSign(&keyAliasBlob, paramSet, &messageBlob, &signatureBlob);
-    if ((ret != HKS_SUCCESS) || (signatureBlob.size != SIGNATURE_LEN)) {
-        LOGE("Hks sign failed.");
-        ret = HAL_FAILED;
-        goto err;
-    }
-    ret = HAL_SUCCESS;
-err:
-    HksFreeParamSet(&paramSet);
-    HcFree(messageHash.val);
-    return ret;
-}
-
-static int32_t ConstructVerifyParams(struct HksParamSet **paramSet, Algorithm algo, bool isAlias)
-{
-    struct HksParam verifyParam[] = {
-        {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_VERIFY
-        }, {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = g_algToHksAlgorithm[algo] // only support HKS_ALG_ED25519
-        }, {
-            .tag = HKS_TAG_IS_KEY_ALIAS,
-            .boolParam = isAlias
-        }
-    };
-
-    int32_t ret = ConstructParamSet(paramSet, verifyParam, CAL_ARRAY_SIZE(verifyParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("Construct param set failed, ret = %d", ret);
-        return ret;
-    }
-    return ret;
-}
-
-static int32_t Verify(const Uint8Buff *key, const Uint8Buff *message, Algorithm algo,
-    const Uint8Buff *signature, bool isAlias)
-{
-    struct HksParamSet *paramSet = NULL;
-    const Uint8Buff *inParams[] = { key, message, signature };
-    const char *paramTags[] = { "key", "message", "signature" };
-    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-    CHECK_LEN_EQUAL_RETURN(signature->length, SIGNATURE_LEN, "signature");
-
-    struct HksBlob keyAliasBlob = { key->length, key->val };
-    Uint8Buff messageHash = { NULL, 0 };
-    messageHash.length = SHA256_LEN;
-    messageHash.val = (uint8_t *)HcMalloc(messageHash.length, 0);
-    if (messageHash.val == NULL) {
-        LOGE("malloc messageHash.data failed.");
-        ret = HAL_ERR_BAD_ALLOC;
-        goto err;
-    }
-    ret = Sha256(message, &messageHash);
-    if (ret != HAL_SUCCESS) {
-        LOGE("Sha256 failed.");
-        goto err;
-    }
-    struct HksBlob messageBlob = { messageHash.length, messageHash.val };
-    struct HksBlob signatureBlob = { signature->length, signature->val };
-
-    ret = ConstructVerifyParams(&paramSet, algo, isAlias);
-    if (ret != HAL_SUCCESS) {
-        goto err;
-    }
-
-    ret = HksVerify(&keyAliasBlob, paramSet, &messageBlob, &signatureBlob);
-    if ((ret != HKS_SUCCESS)) {
-        LOGE("HksVerify failed, ret: %d", ret);
-        ret = HAL_FAILED;
-        goto err;
-    }
-    ret = HAL_SUCCESS;
-err:
-    HksFreeParamSet(&paramSet);
-    HcFree(messageHash.val);
-    return ret;
-}
-
-static int32_t ConstructImportPublicKeyParams(struct HksParamSet **paramSet, Algorithm algo, uint32_t keyLen,
-    const struct HksBlob *authIdBlob, const union KeyRoleInfoUnion *roleInfoUnion)
-{
-    struct HksParam importParam[] = {
-        {
-            .tag = HKS_TAG_ALGORITHM,
-            .uint32Param = g_algToHksAlgorithm[algo]
-        }, {
-            .tag = HKS_TAG_KEY_SIZE,
-            .uint32Param = keyLen * BITS_PER_BYTE
-        }, {
-            .tag = HKS_TAG_PADDING,
-            .uint32Param = HKS_PADDING_NONE
-        }, {
-            .tag = HKS_TAG_KEY_AUTH_ID,
-            .blob = *authIdBlob
-        }, {
-            .tag = HKS_TAG_IS_ALLOWED_WRAP,
-            .boolParam = true
-        }, {
-            .tag = HKS_TAG_PURPOSE,
-            .uint32Param = HKS_KEY_PURPOSE_VERIFY
-        }, {
-            .tag = HKS_TAG_KEY_ROLE,
-            .uint32Param = roleInfoUnion->roleInfo
-        }, {
-            .tag = HKS_TAG_DIGEST,
-            .uint32Param = HKS_DIGEST_SHA256
-        }
-    };
-
-    int32_t ret = ConstructParamSet(paramSet, importParam, CAL_ARRAY_SIZE(importParam));
-    if (ret != HAL_SUCCESS) {
-        LOGE("Construct param set failed, ret = %d", ret);
-        return ret;
-    }
-    return ret;
-}
-
-static int32_t ImportPublicKey(const Uint8Buff *keyAlias, const Uint8Buff *pubKey, Algorithm algo,
-    const ExtraInfo *exInfo)
-{
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey, "pubKey");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey->val, "pubKey->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(pubKey->length, "pubKey->length");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo, "exInfo");
-    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo->authId.val, "authId->val");
-    CHECK_LEN_ZERO_RETURN_ERROR_CODE(exInfo->authId.length, "authId->length");
-    CHECK_LEN_HIGHER_RETURN(exInfo->pairType, PAIR_TYPE_END - 1, "pairType");
-
-    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
-    struct HksBlob pubKeyBlob = { pubKey->length, pubKey->val };
-
-    struct HksBlob authIdBlob = { exInfo->authId.length, exInfo->authId.val };
-    union KeyRoleInfoUnion roleInfoUnion;
-    roleInfoUnion.roleInfoStruct.userType = (uint8_t)exInfo->userType;
-    roleInfoUnion.roleInfoStruct.pairType = (uint8_t)exInfo->pairType;
-    roleInfoUnion.roleInfoStruct.reserved1 = (uint8_t)0;
-    roleInfoUnion.roleInfoStruct.reserved2 = (uint8_t)0;
-
-    struct HksParamSet *paramSet = NULL;
-
-    int32_t ret = ConstructImportPublicKeyParams(&paramSet, algo, pubKey->length, &authIdBlob, &roleInfoUnion);
-    if (ret != HAL_SUCCESS) {
-        return ret;
-    }
-
-    ret = HksImportKey(&keyAliasBlob, paramSet, &pubKeyBlob);
-    if (ret != HKS_SUCCESS) {
-        LOGE("Hks importKey failed, ret: %d", ret);
-        HksFreeParamSet(&paramSet);
-        return HAL_FAILED;
-    }
-
-    HksFreeParamSet(&paramSet);
-    return HAL_SUCCESS;
-}
-
-static int32_t Compare(const uint8_t *a, uint32_t lenA, const uint8_t *b, uint32_t lenB)
-{
-    const uint8_t *tmpA = a;
-    const uint8_t *tmpB = b;
-    uint32_t len = lenA;
-    if (lenA < lenB) {
-        for (uint32_t i = 0; i < lenB - lenA; i++) {
-            if (b[i] > 0) {
-                return 1; // a < b
-            }
-        }
-        tmpA = a;
-        tmpB = b + lenB - lenA;
-        len = lenA;
-    }
-    if (lenA > lenB) {
-        for (uint32_t i = 0; i < lenA - lenB; i++) {
-            if (a[i] > 0) {
-                return -1; // a > b
-            }
-        }
-        tmpA = a + lenA - lenB;
-        tmpB = b;
-        len = lenB;
-    }
-    for (uint32_t i = 0; i < len; i++) {
-        if (*(tmpA + i) > *(tmpB + i)) {
-            return -1; // a > b
-        }
-        if (*(tmpA + i) < *(tmpB + i)) {
-            return 1; // a < b
-        }
-    }
-    return 0; // a == b
-}
-
-bool CheckDlPublicKey(const Uint8Buff *key, const char *primeHex)
-{
-    if (key == NULL || key->val == NULL || primeHex == NULL) {
-        LOGE("Params is null.");
-        return false;
-    }
-    uint8_t min = 1;
-
-    uint32_t innerKeyLen = HcStrlen(primeHex) / BYTE_TO_HEX_OPER_LENGTH;
-    if (key->length > innerKeyLen) {
-        LOGE("Key length > prime number length.");
-        return false;
-    }
-    uint8_t *primeByte = (uint8_t *)HcMalloc(innerKeyLen, 0);
-    if (primeByte == NULL) {
-        LOGE("Malloc for primeByte failed.");
-        return false;
-    }
-    if (HexStringToByte(primeHex, primeByte, innerKeyLen) != HAL_SUCCESS) {
-        LOGE("Convert prime number from hex string to byte failed.");
-        HcFree(primeByte);
-        return false;
-    }
-    /*
-     * P - 1, since the last byte of large prime number must be greater than 1,
-     * needn't to think about borrowing forward
-     */
-    primeByte[innerKeyLen - 1] -= 1;
-
-    if (Compare(key->val, key->length, &min, sizeof(uint8_t)) >= 0) {
-        LOGE("Pubkey is invalid, key <= 1.");
-        HcFree(primeByte);
-        return false;
-    }
-
-    if (Compare(key->val, key->length, primeByte, innerKeyLen) <= 0) {
-        LOGE("Pubkey is invalid, key >= p - 1.");
-        HcFree(primeByte);
-        return false;
-    }
-
-    HcFree(primeByte);
-    return true;
-}
-
-static const AlgLoader g_huksLoader = {
-    .initAlg = InitHks,
-    .sha256 = Sha256,
-    .generateRandom = GenerateRandom,
-    .computeHmac = ComputeHmac,
-    .computeHkdf = ComputeHkdf,
-    .importAsymmetricKey = NULL,
-    .checkKeyExist = CheckKeyExist,
-    .deleteKey = DeleteKey,
-    .aesGcmEncrypt = AesGcmEncrypt,
-    .aesGcmDecrypt = AesGcmDecrypt,
-    .hashToPoint = HashToPoint,
-    .agreeSharedSecretWithStorage = AgreeSharedSecretWithStorage,
-    .agreeSharedSecret = AgreeSharedSecret,
-    .bigNumExpMod = BigNumExpMod,
-    .generateKeyPairWithStorage = GenerateKeyPairWithStorage,
-    .generateKeyPair = GenerateKeyPair,
-    .exportPublicKey = ExportPublicKey,
-    .sign = Sign,
-    .verify = Verify,
-    .importPublicKey = ImportPublicKey,
-    .checkDlPublicKey = CheckDlPublicKey,
-    .checkEcPublicKey = NULL,
-    .bigNumCompare = NULL
-};
-
-const AlgLoader *GetRealLoaderInstance()
-{
-    return &g_huksLoader;
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "huks_adapter.h"
+#include "common_util.h"
+#include "hc_log.h"
+#include "hks_api.h"
+#include "hks_param.h"
+#include "hks_type.h"
+#include "mbedtls_hash_to_point.h"
+
+static enum HksKeyAlg g_algToHksAlgorithm[] = {
+    HKS_ALG_ED25519,
+    HKS_ALG_X25519,
+    HKS_ALG_ECC
+};
+
+static int32_t BaseCheckParams(const Uint8Buff **inParams, const char **paramTags, uint32_t len)
+{
+    for (uint32_t i = 0; i < len; i++) {
+        CHECK_PTR_RETURN_HAL_ERROR_CODE(inParams[i], paramTags[i]);
+        CHECK_PTR_RETURN_HAL_ERROR_CODE(inParams[i]->val, paramTags[i]);
+        CHECK_LEN_ZERO_RETURN_ERROR_CODE(inParams[i]->length, paramTags[i]);
+    }
+    return HAL_SUCCESS;
+}
+
+static int32_t ConstructParamSet(struct HksParamSet **out, const struct HksParam *inParam,
+    const uint32_t inParamNum)
+{
+    struct HksParamSet *paramSet = NULL;
+    int32_t ret = HksInitParamSet(&paramSet);
+    if (ret != HKS_SUCCESS) {
+        LOGE("init param set failed, ret = %d", ret);
+        return HAL_ERR_INIT_PARAM_SET_FAILED;
+    }
+
+    ret = HksAddParams(paramSet, inParam, inParamNum);
+    if (ret != HKS_SUCCESS) {
+        LOGE("add param failed, ret = %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_ERR_ADD_PARAM_FAILED;
+    }
+
+    ret = HksBuildParamSet(&paramSet);
+    if (ret != HKS_SUCCESS) {
+        LOGE("build param set failed, ret = %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_ERR_BUILD_PARAM_SET_FAILED;
+    }
+
+    *out = paramSet;
+    return HAL_SUCCESS;
+}
+
+static int32_t InitHks()
+{
+    return HksInitialize();
+}
+
+static int32_t Sha256(const Uint8Buff *message, Uint8Buff *hash)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(message, "message");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(message->val, "message->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(message->length, "message->length");
+
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash, "hash");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash->val, "hash->val");
+    CHECK_LEN_EQUAL_RETURN(hash->length, SHA256_LEN, "hash->length");
+
+    struct HksBlob srcBlob = { message->length, message->val };
+    struct HksBlob hashBlob = { hash->length, hash->val };
+    struct HksParamSet *paramSet = NULL;
+    struct HksParam digestParam[] = {
+        {
+            .tag = HKS_TAG_DIGEST,
+            .uint32Param = HKS_DIGEST_SHA256
+        }
+    };
+    int32_t ret = ConstructParamSet(&paramSet, digestParam, CAL_ARRAY_SIZE(digestParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("construct param set failed, ret = %d", ret);
+        return ret;
+    }
+
+    ret = HksHash(paramSet, &srcBlob, &hashBlob);
+    if (ret != HKS_SUCCESS || hashBlob.size != SHA256_LEN) {
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t GenerateRandom(Uint8Buff *rand)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(rand, "rand");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(rand->val, "rand->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(rand->length, "rand->length");
+
+    struct HksBlob randBlob = { rand->length, rand->val };
+    int32_t ret = HksGenerateRandom(NULL, &randBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Generate random failed, ret: %d", ret);
+        return HAL_FAILED;
+    }
+
+    return HAL_SUCCESS;
+}
+
+static int32_t CheckKeyExist(const Uint8Buff *keyAlias)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
+
+    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
+    int32_t ret = HksKeyExist(&keyAliasBlob, NULL);
+    if (ret != HKS_SUCCESS) {
+        LOGI("Hks check key exist or not, ret = %d", ret);
+        return HAL_FAILED;
+    }
+
+    return HAL_SUCCESS;
+}
+
+static int32_t DeleteKey(const Uint8Buff *keyAlias)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
+
+    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
+    int32_t ret = HksDeleteKey(&keyAliasBlob, NULL);
+    if (ret == HKS_ERROR_NOT_EXIST) {
+        LOGI("Key not exists.");
+        return HAL_SUCCESS;
+    }
+    if (ret != HKS_SUCCESS) {
+        LOGE("Delete key failed, ret = %d", ret);
+        return HAL_FAILED;
+    }
+
+    return HAL_SUCCESS;
+}
+
+static int32_t ComputeHmac(const Uint8Buff *key, const Uint8Buff *message, Uint8Buff *outHmac, bool isAlias)
+{
+    const Uint8Buff *inParams[] = { key, message, outHmac };
+    const char *paramTags[] = {"key", "message", "outHmac"};
+    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+    CHECK_LEN_EQUAL_RETURN(outHmac->length, HMAC_LEN, "outHmac->length");
+
+    struct HksBlob keyBlob = { key->length, key->val };
+    struct HksBlob srcBlob = { message->length, message->val };
+    struct HksBlob hmacBlob = { outHmac->length, outHmac->val };
+    struct HksParamSet *paramSet = NULL;
+    struct HksParam hmacParam[] = {
+        {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_MAC
+        }, {
+            .tag = HKS_TAG_DIGEST,
+            .uint32Param = HKS_DIGEST_SHA256
+        }, {
+            .tag = HKS_TAG_IS_KEY_ALIAS,
+            .boolParam = isAlias
+        }
+    };
+    ret = ConstructParamSet(&paramSet, hmacParam, CAL_ARRAY_SIZE(hmacParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("construct param set failed, ret = %d", ret);
+        return ret;
+    }
+
+    ret = HksMac(&keyBlob, paramSet, &srcBlob, &hmacBlob);
+    if (ret != HKS_SUCCESS  || hmacBlob.size != HMAC_LEN) {
+        LOGE("Hmac failed, ret: %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t ComputeHkdf(const Uint8Buff *baseKey, const Uint8Buff *salt, const Uint8Buff *keyInfo,
+    Uint8Buff *outHkdf, bool isAlias)
+{
+    const Uint8Buff *inParams[] = { baseKey, salt, outHkdf };
+    const char *paramTags[] = { "baseKey", "salt", "outHkdf" };
+    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    struct HksBlob srcKeyBlob = { baseKey->length, baseKey->val };
+    struct HksBlob saltBlob = { salt->length, salt->val };
+    struct HksBlob keyInfoBlob = { 0, NULL };
+    if (keyInfo != NULL) {
+        keyInfoBlob.size = keyInfo->length;
+        keyInfoBlob.data = keyInfo->val;
+    }
+    struct HksBlob derivedKeyBlob = { outHkdf->length, outHkdf->val };
+
+    struct HksParamSet *paramSet = NULL;
+    struct HksParam hkdfParam[] = {
+        {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_DERIVE
+        }, {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = HKS_ALG_HKDF
+        }, {
+            .tag = HKS_TAG_DIGEST,
+            .uint32Param = HKS_DIGEST_SHA256
+        }, {
+            .tag = HKS_TAG_SALT,
+            .blob = saltBlob
+        }, {
+            .tag = HKS_TAG_INFO,
+            .blob = keyInfoBlob
+        }, {
+            .tag = HKS_TAG_IS_KEY_ALIAS,
+            .boolParam = isAlias
+        }
+    };
+
+    ret = ConstructParamSet(&paramSet, hkdfParam, CAL_ARRAY_SIZE(hkdfParam));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    ret = HksDeriveKey(paramSet, &srcKeyBlob, &derivedKeyBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Key derivation failed, ret: %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t CheckAesGcmEncryptParam(const Uint8Buff *key, const Uint8Buff *plain, const GcmParam *encryptInfo,
+    Uint8Buff *outCipher)
+{
+    const Uint8Buff *inParams[] = { key, plain, outCipher };
+    const char* paramTags[] = { "key", "plain", "outCipher" };
+    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(encryptInfo, "encryptInfo");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(encryptInfo->aad, "aad");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(encryptInfo->aadLen, "aadLen");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(encryptInfo->nonce, "nonce");
+    CHECK_LEN_LOWER_RETURN(encryptInfo->nonceLen, HKS_AE_NONCE_LEN, "nonceLen");
+    CHECK_LEN_LOWER_RETURN(outCipher->length, plain->length + HKS_AE_TAG_LEN, "outCipher");
+
+    return HAL_SUCCESS;
+}
+
+static int32_t AesGcmEncrypt(const Uint8Buff *key, const Uint8Buff *plain,
+    const GcmParam *encryptInfo, bool isAlias, Uint8Buff *outCipher)
+{
+    int32_t ret = CheckAesGcmEncryptParam(key, plain, encryptInfo, outCipher);
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    struct HksBlob keyBlob = { key->length, key->val };
+    struct HksBlob plainBlob = { plain->length, plain->val };
+    struct HksBlob cipherBlob = { outCipher->length, outCipher->val };
+
+    struct HksParamSet *paramSet = NULL;
+    struct HksParam encryptParam[] = {
+        {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_ENCRYPT
+        }, {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = HKS_ALG_AES
+        }, {
+            .tag = HKS_TAG_BLOCK_MODE,
+            .uint32Param = HKS_MODE_GCM
+        }, {
+            .tag = HKS_TAG_PADDING,
+            .uint32Param = HKS_PADDING_NONE
+        }, {
+            .tag = HKS_TAG_NONCE,
+            .blob = { encryptInfo->nonceLen, encryptInfo->nonce }
+        }, {
+            .tag = HKS_TAG_ASSOCIATED_DATA,
+            .blob = { encryptInfo->aadLen, encryptInfo->aad }
+        }, {
+            .tag = HKS_TAG_IS_KEY_ALIAS,
+            .boolParam = isAlias
+        }
+    };
+
+    ret = ConstructParamSet(&paramSet, encryptParam, CAL_ARRAY_SIZE(encryptParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("construct param set failed, ret = %d", ret);
+        return ret;
+    }
+
+    ret = HksEncrypt(&keyBlob, paramSet, &plainBlob, &cipherBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Aes-gcm encrypt failed, ret: %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t CheckAesGcmDecryptParam(const Uint8Buff *key, const Uint8Buff *cipher, const GcmParam *decryptInfo,
+    Uint8Buff *outPlain)
+{
+    const Uint8Buff *inParams[] = { key, cipher, outPlain };
+    const char *paramTags[] = { "key", "cipher", "outPlain" };
+    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(decryptInfo, "decryptInfo");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(decryptInfo->aad, "aad");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(decryptInfo->aadLen, "aadLen");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(decryptInfo->nonce, "nonce");
+    CHECK_LEN_LOWER_RETURN(decryptInfo->nonceLen, HKS_AE_NONCE_LEN, "nonceLen");
+    CHECK_LEN_LOWER_RETURN(outPlain->length, cipher->length - HKS_AE_TAG_LEN, "outPlain");
+
+    return HAL_SUCCESS;
+}
+
+static int32_t AesGcmDecrypt(const Uint8Buff *key, const Uint8Buff *cipher,
+    const GcmParam *decryptInfo, bool isAlias, Uint8Buff *outPlain)
+{
+    int32_t ret = CheckAesGcmDecryptParam(key, cipher, decryptInfo, outPlain);
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    struct HksBlob keyBlob = { key->length, key->val };
+    struct HksBlob cipherBlob = { cipher->length, cipher->val };
+    struct HksBlob plainBlob = { outPlain->length, outPlain->val };
+
+    struct HksParamSet *paramSet = NULL;
+    struct HksParam decryptParam[] = {
+        {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_DECRYPT
+        }, {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = HKS_ALG_AES
+        }, {
+            .tag = HKS_TAG_BLOCK_MODE,
+            .uint32Param = HKS_MODE_GCM
+        }, {
+            .tag = HKS_TAG_PADDING,
+            .uint32Param = HKS_PADDING_NONE
+        }, {
+            .tag = HKS_TAG_NONCE,
+            .blob = { decryptInfo->nonceLen, decryptInfo->nonce }
+        }, {
+            .tag = HKS_TAG_ASSOCIATED_DATA,
+            .blob = { decryptInfo->aadLen, decryptInfo->aad }
+        }, {
+            .tag = HKS_TAG_IS_KEY_ALIAS,
+            .boolParam = isAlias
+        }
+    };
+
+    ret = ConstructParamSet(&paramSet, decryptParam, CAL_ARRAY_SIZE(decryptParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("construct param set failed, ret = %d", ret);
+        return ret;
+    }
+
+    ret = HksDecrypt(&keyBlob, paramSet, &cipherBlob, &plainBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Aes-gcm decrypt failed, ret: %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t HashToPoint(const Uint8Buff *hash, Algorithm algo, Uint8Buff *outEcPoint)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash, "hash");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(hash->val, "hash->va");
+    CHECK_LEN_EQUAL_RETURN(hash->length, SHA256_LEN, "hash->length");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outEcPoint, "outEcPoint");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outEcPoint->val, "outEcPoint->va");
+    CHECK_LEN_EQUAL_RETURN(outEcPoint->length, SHA256_LEN, "outEcPoint->length");
+
+    if (algo != X25519) {
+        LOGE("Invalid algo: %d.", algo);
+        return HAL_ERR_INVALID_PARAM;
+    }
+
+    int32_t ret = MbedtlsHashToPoint(hash, outEcPoint);
+    if (ret != 0) {
+        LOGE("Hks hashToPoint failed, ret: %d", ret);
+        return HAL_FAILED;
+    }
+
+    return HAL_SUCCESS;
+}
+
+static int32_t ConstructAgreeWithStorageParams(struct HksParamSet **paramSet, uint32_t keyLen, Algorithm algo,
+    const KeyBuff *priKey, const KeyBuff *pubKey)
+{
+    struct HksBlob priKeyBlob = { priKey->keyLen, priKey->key };
+    struct HksBlob pubKeyBlob = { pubKey->keyLen, pubKey->key };
+    struct HksParam agreeParam[] = {
+        {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = HKS_ALG_AES
+        }, {
+            .tag = HKS_TAG_KEY_SIZE,
+            .uint32Param = keyLen * BITS_PER_BYTE
+        }, {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_DERIVE
+        }, {
+            .tag = HKS_TAG_DIGEST,
+            .uint32Param = HKS_DIGEST_SHA256
+        }, {
+            .tag = HKS_TAG_KEY_GENERATE_TYPE,
+            .uint32Param = HKS_KEY_GENERATE_TYPE_AGREE
+        }, {
+            .tag = HKS_TAG_AGREE_ALG,
+            .uint32Param = g_algToHksAlgorithm[algo]
+        }, {
+            .tag = HKS_TAG_AGREE_PRIVATE_KEY_ALIAS,
+            .blob = priKeyBlob
+        }, {
+            .tag = HKS_TAG_AGREE_PUBLIC_KEY,
+            .blob = pubKeyBlob
+        }, {
+            .tag = HKS_TAG_AGREE_PUBLIC_KEY_IS_KEY_ALIAS,
+            .boolParam = pubKey->isAlias
+        }
+    };
+
+    int32_t ret = ConstructParamSet(paramSet, agreeParam, CAL_ARRAY_SIZE(agreeParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("Construct param set failed, ret = %d", ret);
+        return ret;
+    }
+    return ret;
+}
+
+static int32_t AgreeSharedSecretWithStorage(const KeyBuff *priKey, const KeyBuff *pubKey, Algorithm algo,
+    uint32_t sharedKeyLen, const Uint8Buff *sharedKeyAlias)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey, "priKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey->key, "priKey->key");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(priKey->keyLen, "priKey->keyLen");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey, "pubKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey->key, "pubKey->key");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(pubKey->keyLen, "pubKey->keyLen");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKeyAlias, "sharedKeyAlias");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKeyAlias->val, "sharedKeyAlias->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(sharedKeyAlias->length, "sharedKeyAlias->length");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(sharedKeyLen, "sharedKeyLen");
+
+    struct HksBlob sharedKeyAliasBlob = { sharedKeyAlias->length, sharedKeyAlias->val };
+    struct HksParamSet *paramSet = NULL;
+    int32_t ret = ConstructAgreeWithStorageParams(&paramSet, sharedKeyLen, algo, priKey, pubKey);
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    ret = HksGenerateKey(&sharedKeyAliasBlob, paramSet, NULL);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Hks agree key with storage failed, ret = %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t AgreeSharedSecret(const KeyBuff *priKey, const KeyBuff *pubKey, Algorithm algo, Uint8Buff *sharedKey)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey, "priKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(priKey->key, "priKey->key");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(priKey->keyLen, "priKey->keyLen");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey, "pubKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey->key, "pubKey->key");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(pubKey->keyLen, "pubKey->keyLen");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKey, "sharedKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(sharedKey->val, "sharedKey->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(sharedKey->length, "sharedKey->length");
+
+    struct HksBlob priKeyBlob = { priKey->keyLen, priKey->key };
+    struct HksBlob pubKeyBlob = { pubKey->keyLen, pubKey->key };
+    struct HksBlob sharedKeyBlob = { sharedKey->length, sharedKey->val };
+
+    struct HksParamSet *paramSet = NULL;
+    struct HksParam agreeParam[] = {
+        {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = g_algToHksAlgorithm[algo] // only support HKS_ALG_X25519 now
+        }, {
+            .tag = HKS_TAG_KEY_SIZE,
+            .uint32Param = sharedKey->length * BITS_PER_BYTE
+        }, {
+            .tag = HKS_TAG_IS_KEY_ALIAS,
+            .boolParam = priKey->isAlias
+        }
+    };
+
+    int32_t ret = ConstructParamSet(&paramSet, agreeParam, CAL_ARRAY_SIZE(agreeParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("Construct param set failed, ret = %d", ret);
+        return ret;
+    }
+
+    ret = HksAgreeKey(paramSet, &priKeyBlob, &pubKeyBlob, &sharedKeyBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Agree key failed, ret = %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t BigNumExpMod(const Uint8Buff *base, const Uint8Buff *exp, const char *bigNumHex, Uint8Buff *outNum)
+{
+    const Uint8Buff *inParams[] = { base, exp, outNum };
+    const char *paramTags[] = { "base", "exp", "outNum" };
+    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(bigNumHex, "bigNumHex");
+    uint32_t primeLen = strlen(bigNumHex) / BYTE_TO_HEX_OPER_LENGTH;
+    if ((primeLen != BIG_PRIME_LEN_384) && (primeLen != BIG_PRIME_LEN_256)) {
+        LOGE("Not support big number len %d", outNum->length);
+        return HAL_FAILED;
+    }
+    CHECK_LEN_EQUAL_RETURN(outNum->length, primeLen, "outNum->length");
+
+    struct HksBlob baseBlob = { base->length, base->val };
+    struct HksBlob expBlob = { exp->length, exp->val };
+    struct HksBlob outNumBlob = { outNum->length, outNum->val };
+    struct HksBlob bigNumBlob = { 0, NULL };
+    bigNumBlob.size = outNum->length;
+    bigNumBlob.data = (uint8_t *)HcMalloc(bigNumBlob.size, 0);
+    if (bigNumBlob.data == NULL) {
+        LOGE("malloc bigNumBlob.data failed.");
+        return HAL_ERR_BAD_ALLOC;
+    }
+    ret = HexStringToByte(bigNumHex, bigNumBlob.data, bigNumBlob.size);
+    if (ret != HAL_SUCCESS) {
+        LOGE("HexStringToByte for bigNumHex failed.");
+        HcFree(bigNumBlob.data);
+        return ret;
+    }
+
+    ret = HksBnExpMod(&outNumBlob, &baseBlob, &expBlob, &bigNumBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Huks calculate big number exp mod failed, ret = %d", ret);
+        HcFree(bigNumBlob.data);
+        return HAL_FAILED;
+    }
+    outNum->length = outNumBlob.size;
+
+    HcFree(bigNumBlob.data);
+    return HAL_SUCCESS;
+}
+
+static int32_t ConstructGenerateKeyPairWithStorageParams(struct HksParamSet **paramSet, Algorithm algo,
+    uint32_t keyLen, const struct HksBlob *authIdBlob)
+{
+    struct HksParam keyParam[] = {
+        {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = g_algToHksAlgorithm[algo]
+        }, {
+            .tag = HKS_TAG_KEY_STORAGE_FLAG,
+            .uint32Param = HKS_STORAGE_PERSISTENT
+        }, {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_SIGN | HKS_KEY_PURPOSE_VERIFY
+        }, {
+            .tag = HKS_TAG_KEY_SIZE,
+            .uint32Param = keyLen * BITS_PER_BYTE
+        }, {
+            .tag = HKS_TAG_KEY_AUTH_ID,
+            .blob = *authIdBlob
+        }
+    };
+
+    int32_t ret = ConstructParamSet(paramSet, keyParam, CAL_ARRAY_SIZE(keyParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("Construct param set failed, ret = %d", ret);
+        return ret;
+    }
+    return ret;
+}
+
+static int32_t GenerateKeyPairWithStorage(const Uint8Buff *keyAlias, uint32_t keyLen, Algorithm algo,
+    const ExtraInfo *exInfo)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo, "exInfo");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo->authId.val, "authId->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(exInfo->authId.length, "authId->length");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyLen, "keyLen");
+
+    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
+    struct HksBlob authIdBlob = { exInfo->authId.length, exInfo->authId.val };
+    struct HksParamSet *paramSet = NULL;
+    int32_t ret = ConstructGenerateKeyPairWithStorageParams(&paramSet, algo, keyLen, &authIdBlob);
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    ret = HksGenerateKey(&keyAliasBlob, paramSet, NULL);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Hks generate failed, ret=%d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t GetKeyPair(struct HksParamSet *outParamSet, Uint8Buff *outPriKey, Uint8Buff *outPubKey)
+{
+    int32_t ret = HksFreshParamSet(outParamSet, false); /* false means fresh by local, not through IPC */
+    if (ret != HKS_SUCCESS) {
+        LOGE("fresh param set failed, ret:%d", ret);
+        return HAL_ERR_FRESH_PARAM_SET_FAILED;
+    }
+
+    struct HksParam *pubKeyParam = NULL;
+    ret = HksGetParam(outParamSet, HKS_TAG_ASYMMETRIC_PUBLIC_KEY_DATA, &pubKeyParam);
+    if (ret != HKS_SUCCESS) {
+        LOGE("get pub key from param set failed, ret:%d", ret);
+        return HAL_ERR_GET_PARAM_FAILED;
+    }
+
+    struct HksParam *priKeyParam = NULL;
+    ret = HksGetParam(outParamSet, HKS_TAG_ASYMMETRIC_PRIVATE_KEY_DATA, &priKeyParam);
+    if (ret != HKS_SUCCESS) {
+        LOGE("get priv key from param set failed, ret:%d", ret);
+        return HAL_ERR_GET_PARAM_FAILED;
+    }
+
+    if (memcpy_s(outPubKey->val, outPubKey->length, pubKeyParam->blob.data, pubKeyParam->blob.size) != EOK) {
+        LOGE("parse x25519 output param set memcpy public key failed!");
+        return HAL_ERR_MEMORY_COPY;
+    }
+    outPubKey->length = pubKeyParam->blob.size;
+
+    if (memcpy_s(outPriKey->val, outPriKey->length, priKeyParam->blob.data, priKeyParam->blob.size) != EOK) {
+        LOGE("parse x25519 output param set memcpy private key failed!");
+        return HAL_ERR_MEMORY_COPY;
+    }
+    outPriKey->length = priKeyParam->blob.size;
+
+    return HAL_SUCCESS;
+}
+
+static int32_t ConstructGenerateKeyPairParams(struct HksParamSet **paramSet, Algorithm algo, uint32_t keyLen)
+{
+    struct HksParam keyParam[] = {
+        {
+            .tag = HKS_TAG_KEY_STORAGE_FLAG,
+            .uint32Param = HKS_STORAGE_TEMP
+        }, {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = g_algToHksAlgorithm[algo]
+        }, {
+            .tag = HKS_TAG_KEY_SIZE,
+            .uint32Param = keyLen * BITS_PER_BYTE
+        }, {
+            .tag = HKS_TAG_IS_KEY_ALIAS,
+            .uint32Param = false
+        }
+    };
+
+    int32_t ret = ConstructParamSet(paramSet, keyParam, CAL_ARRAY_SIZE(keyParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("Construct param set failed, ret = %d", ret);
+        return ret;
+    }
+    return ret;
+}
+
+static int32_t GenerateKeyPair(Algorithm algo, Uint8Buff *outPriKey, Uint8Buff *outPubKey)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPriKey, "outPriKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPriKey->val, "outPriKey->key");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(outPriKey->length, "outPriKey->keyLen");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey, "outPubKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey->val, "outPubKey->key");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(outPubKey->length, "outPubKey->keyLen");
+
+    if (outPriKey->length != outPubKey->length) {
+        LOGE("key len not equal.");
+        return HAL_ERR_INVALID_LEN;
+    }
+    uint32_t keyLen = outPriKey->length;
+
+    struct HksParamSet *paramSet = NULL;
+    struct HksParamSet *outParamSet = NULL;
+    int32_t ret = ConstructGenerateKeyPairParams(&paramSet, algo, keyLen);
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    /* need 2 HksParam struct for outPriKey and outPubKey */
+    uint32_t outParamSetSize = sizeof(struct HksParamSet) +
+        2 * (sizeof(struct HksParam)) + outPriKey->length + outPubKey->length;
+    outParamSet = (struct HksParamSet *)HcMalloc(outParamSetSize, 0);
+    if (outParamSet == NULL) {
+        LOGE("allocate buffer for output param set failed");
+        ret = HAL_ERR_BAD_ALLOC;
+        goto err;
+    }
+    outParamSet->paramSetSize = outParamSetSize;
+
+    ret = HksGenerateKey(NULL, paramSet, outParamSet);
+    if (ret != HKS_SUCCESS) {
+        LOGE("generate x25519 key failed, ret:%d", ret);
+        ret = HAL_FAILED;
+        goto err;
+    }
+
+    ret = GetKeyPair(outParamSet, outPriKey, outPubKey);
+    if (ret != HAL_SUCCESS) {
+        LOGE("parse x25519 output param set failed, ret:%d", ret);
+        goto err;
+    }
+err:
+    HksFreeParamSet(&paramSet);
+    HcFree(outParamSet);
+    return ret;
+}
+
+static int32_t ExportPublicKey(const Uint8Buff *keyAlias, Uint8Buff *outPubKey)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey, "outPubKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(outPubKey->val, "outPubKey->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(outPubKey->length, "outPubKey->length");
+
+    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
+    struct HksBlob keyBlob = { outPubKey->length, outPubKey->val };
+
+    int32_t ret = HksExportPublicKey(&keyAliasBlob, NULL, &keyBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Export public key failed, ret=%d", ret);
+        return HAL_FAILED;
+    }
+    outPubKey->length = keyBlob.size;
+
+    return HAL_SUCCESS;
+}
+
+static int32_t ConstructSignParams(struct HksParamSet **paramSet, Algorithm algo)
+{
+    struct HksParam signParam[] = {
+        {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_SIGN
+        }, {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = g_algToHksAlgorithm[algo] // only support HKS_ALG_ED25519
+        }
+    };
+
+    int32_t ret = ConstructParamSet(paramSet, signParam, CAL_ARRAY_SIZE(signParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("Construct param set failed, ret = %d", ret);
+        return ret;
+    }
+    return ret;
+}
+
+static int32_t Sign(const Uint8Buff *keyAlias, const Uint8Buff *message, Algorithm algo,
+    Uint8Buff *outSignature, bool isAlias)
+{
+    struct HksParamSet *paramSet = NULL;
+    const Uint8Buff *inParams[] = { keyAlias, message, outSignature };
+    const char *paramTags[] = { "keyAlias", "message", "outSignature" };
+    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+    CHECK_LEN_EQUAL_RETURN(outSignature->length, SIGNATURE_LEN, "outSignature->length");
+
+    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
+    Uint8Buff messageHash = { NULL, 0 };
+    messageHash.length = SHA256_LEN;
+    messageHash.val = (uint8_t *)HcMalloc(messageHash.length, 0);
+    if (messageHash.val == NULL) {
+        LOGE("malloc messageHash.data failed.");
+        ret = HAL_ERR_BAD_ALLOC;
+        goto err;
+    }
+    ret = Sha256(message, &messageHash);
+    if (ret != HAL_SUCCESS) {
+        LOGE("Sha256 failed.");
+        goto err;
+    }
+    struct HksBlob messageBlob = { messageHash.length, messageHash.val };
+    struct HksBlob signatureBlob = { outSignature->length, outSignature->val };
+
+    ret = ConstructSignParams(&paramSet, algo);
+    if (ret != HAL_SUCCESS) {
+        goto err;
+    }
+
+    ret = HksSign(&keyAliasBlob, paramSet, &messageBlob, &signatureBlob);
+    if ((ret != HKS_SUCCESS) || (signatureBlob.size != SIGNATURE_LEN)) {
+        LOGE("Hks sign failed.");
+        ret = HAL_FAILED;
+        goto err;
+    }
+    ret = HAL_SUCCESS;
+err:
+    HksFreeParamSet(&paramSet);
+    HcFree(messageHash.val);
+    return ret;
+}
+
+static int32_t ConstructVerifyParams(struct HksParamSet **paramSet, Algorithm algo, bool isAlias)
+{
+    struct HksParam verifyParam[] = {
+        {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_VERIFY
+        }, {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = g_algToHksAlgorithm[algo] // only support HKS_ALG_ED25519
+        }, {
+            .tag = HKS_TAG_IS_KEY_ALIAS,
+            .boolParam = isAlias
+        }
+    };
+
+    int32_t ret = ConstructParamSet(paramSet, verifyParam, CAL_ARRAY_SIZE(verifyParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("Construct param set failed, ret = %d", ret);
+        return ret;
+    }
+    return ret;
+}
+
+static int32_t Verify(const Uint8Buff *key, const Uint8Buff *message, Algorithm algo,
+    const Uint8Buff *signature, bool isAlias)
+{
+    struct HksParamSet *paramSet = NULL;
+    const Uint8Buff *inParams[] = { key, message, signature };
+    const char *paramTags[] = { "key", "message", "signature" };
+    int32_t ret = BaseCheckParams(inParams, paramTags, CAL_ARRAY_SIZE(inParams));
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+    CHECK_LEN_EQUAL_RETURN(signature->length, SIGNATURE_LEN, "signature");
+
+    struct HksBlob keyAliasBlob = { key->length, key->val };
+    Uint8Buff messageHash = { NULL, 0 };
+    messageHash.length = SHA256_LEN;
+    messageHash.val = (uint8_t *)HcMalloc(messageHash.length, 0);
+    if (messageHash.val == NULL) {
+        LOGE("malloc messageHash.data failed.");
+        ret = HAL_ERR_BAD_ALLOC;
+        goto err;
+    }
+    ret = Sha256(message, &messageHash);
+    if (ret != HAL_SUCCESS) {
+        LOGE("Sha256 failed.");
+        goto err;
+    }
+    struct HksBlob messageBlob = { messageHash.length, messageHash.val };
+    struct HksBlob signatureBlob = { signature->length, signature->val };
+
+    ret = ConstructVerifyParams(&paramSet, algo, isAlias);
+    if (ret != HAL_SUCCESS) {
+        goto err;
+    }
+
+    ret = HksVerify(&keyAliasBlob, paramSet, &messageBlob, &signatureBlob);
+    if ((ret != HKS_SUCCESS)) {
+        LOGE("HksVerify failed, ret: %d", ret);
+        ret = HAL_FAILED;
+        goto err;
+    }
+    ret = HAL_SUCCESS;
+err:
+    HksFreeParamSet(&paramSet);
+    HcFree(messageHash.val);
+    return ret;
+}
+
+static int32_t ConstructImportPublicKeyParams(struct HksParamSet **paramSet, Algorithm algo, uint32_t keyLen,
+    const struct HksBlob *authIdBlob, const union KeyRoleInfoUnion *roleInfoUnion)
+{
+    struct HksParam importParam[] = {
+        {
+            .tag = HKS_TAG_ALGORITHM,
+            .uint32Param = g_algToHksAlgorithm[algo]
+        }, {
+            .tag = HKS_TAG_KEY_SIZE,
+            .uint32Param = keyLen * BITS_PER_BYTE
+        }, {
+            .tag = HKS_TAG_PADDING,
+            .uint32Param = HKS_PADDING_NONE
+        }, {
+            .tag = HKS_TAG_KEY_AUTH_ID,
+            .blob = *authIdBlob
+        }, {
+            .tag = HKS_TAG_IS_ALLOWED_WRAP,
+            .boolParam = true
+        }, {
+            .tag = HKS_TAG_PURPOSE,
+            .uint32Param = HKS_KEY_PURPOSE_VERIFY
+        }, {
+            .tag = HKS_TAG_KEY_ROLE,
+            .uint32Param = roleInfoUnion->roleInfo
+        }, {
+            .tag = HKS_TAG_DIGEST,
+            .uint32Param = HKS_DIGEST_SHA256
+        }
+    };
+
+    int32_t ret = ConstructParamSet(paramSet, importParam, CAL_ARRAY_SIZE(importParam));
+    if (ret != HAL_SUCCESS) {
+        LOGE("Construct param set failed, ret = %d", ret);
+        return ret;
+    }
+    return ret;
+}
+
+static int32_t ImportPublicKey(const Uint8Buff *keyAlias, const Uint8Buff *pubKey, Algorithm algo,
+    const ExtraInfo *exInfo)
+{
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias, "keyAlias");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(keyAlias->val, "keyAlias->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(keyAlias->length, "keyAlias->length");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey, "pubKey");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(pubKey->val, "pubKey->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(pubKey->length, "pubKey->length");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo, "exInfo");
+    CHECK_PTR_RETURN_HAL_ERROR_CODE(exInfo->authId.val, "authId->val");
+    CHECK_LEN_ZERO_RETURN_ERROR_CODE(exInfo->authId.length, "authId->length");
+    CHECK_LEN_HIGHER_RETURN(exInfo->pairType, PAIR_TYPE_END - 1, "pairType");
+
+    struct HksBlob keyAliasBlob = { keyAlias->length, keyAlias->val };
+    struct HksBlob pubKeyBlob = { pubKey->length, pubKey->val };
+
+    struct HksBlob authIdBlob = { exInfo->authId.length, exInfo->authId.val };
+    union KeyRoleInfoUnion roleInfoUnion;
+    roleInfoUnion.roleInfoStruct.userType = (uint8_t)exInfo->userType;
+    roleInfoUnion.roleInfoStruct.pairType = (uint8_t)exInfo->pairType;
+    roleInfoUnion.roleInfoStruct.reserved1 = (uint8_t)0;
+    roleInfoUnion.roleInfoStruct.reserved2 = (uint8_t)0;
+
+    struct HksParamSet *paramSet = NULL;
+
+    int32_t ret = ConstructImportPublicKeyParams(&paramSet, algo, pubKey->length, &authIdBlob, &roleInfoUnion);
+    if (ret != HAL_SUCCESS) {
+        return ret;
+    }
+
+    ret = HksImportKey(&keyAliasBlob, paramSet, &pubKeyBlob);
+    if (ret != HKS_SUCCESS) {
+        LOGE("Hks importKey failed, ret: %d", ret);
+        HksFreeParamSet(&paramSet);
+        return HAL_FAILED;
+    }
+
+    HksFreeParamSet(&paramSet);
+    return HAL_SUCCESS;
+}
+
+static int32_t Compare(const uint8_t *a, uint32_t lenA, const uint8_t *b, uint32_t lenB)
+{
+    const uint8_t *tmpA = a;
+    const uint8_t *tmpB = b;
+    uint32_t len = lenA;
+    if (lenA < lenB) {
+        for (uint32_t i = 0; i < lenB - lenA; i++) {
+            if (b[i] > 0) {
+                return 1; // a < b
+            }
+        }
+        tmpA = a;
+        tmpB = b + lenB - lenA;
+        len = lenA;
+    }
+    if (lenA > lenB) {
+        for (uint32_t i = 0; i < lenA - lenB; i++) {
+            if (a[i] > 0) {
+                return -1; // a > b
+            }
+        }
+        tmpA = a + lenA - lenB;
+        tmpB = b;
+        len = lenB;
+    }
+    for (uint32_t i = 0; i < len; i++) {
+        if (*(tmpA + i) > *(tmpB + i)) {
+            return -1; // a > b
+        }
+        if (*(tmpA + i) < *(tmpB + i)) {
+            return 1; // a < b
+        }
+    }
+    return 0; // a == b
+}
+
+bool CheckDlPublicKey(const Uint8Buff *key, const char *primeHex)
+{
+    if (key == NULL || key->val == NULL || primeHex == NULL) {
+        LOGE("Params is null.");
+        return false;
+    }
+    uint8_t min = 1;
+
+    uint32_t innerKeyLen = HcStrlen(primeHex) / BYTE_TO_HEX_OPER_LENGTH;
+    if (key->length > innerKeyLen) {
+        LOGE("Key length > prime number length.");
+        return false;
+    }
+    uint8_t *primeByte = (uint8_t *)HcMalloc(innerKeyLen, 0);
+    if (primeByte == NULL) {
+        LOGE("Malloc for primeByte failed.");
+        return false;
+    }
+    if (HexStringToByte(primeHex, primeByte, innerKeyLen) != HAL_SUCCESS) {
+        LOGE("Convert prime number from hex string to byte failed.");
+        HcFree(primeByte);
+        return false;
+    }
+    /*
+     * P - 1, since the last byte of large prime number must be greater than 1,
+     * needn't to think about borrowing forward
+     */
+    primeByte[innerKeyLen - 1] -= 1;
+
+    if (Compare(key->val, key->length, &min, sizeof(uint8_t)) >= 0) {
+        LOGE("Pubkey is invalid, key <= 1.");
+        HcFree(primeByte);
+        return false;
+    }
+
+    if (Compare(key->val, key->length, primeByte, innerKeyLen) <= 0) {
+        LOGE("Pubkey is invalid, key >= p - 1.");
+        HcFree(primeByte);
+        return false;
+    }
+
+    HcFree(primeByte);
+    return true;
+}
+
+static const AlgLoader g_huksLoader = {
+    .initAlg = InitHks,
+    .sha256 = Sha256,
+    .generateRandom = GenerateRandom,
+    .computeHmac = ComputeHmac,
+    .computeHkdf = ComputeHkdf,
+    .importAsymmetricKey = NULL,
+    .checkKeyExist = CheckKeyExist,
+    .deleteKey = DeleteKey,
+    .aesGcmEncrypt = AesGcmEncrypt,
+    .aesGcmDecrypt = AesGcmDecrypt,
+    .hashToPoint = HashToPoint,
+    .agreeSharedSecretWithStorage = AgreeSharedSecretWithStorage,
+    .agreeSharedSecret = AgreeSharedSecret,
+    .bigNumExpMod = BigNumExpMod,
+    .generateKeyPairWithStorage = GenerateKeyPairWithStorage,
+    .generateKeyPair = GenerateKeyPair,
+    .exportPublicKey = ExportPublicKey,
+    .sign = Sign,
+    .verify = Verify,
+    .importPublicKey = ImportPublicKey,
+    .checkDlPublicKey = CheckDlPublicKey,
+    .checkEcPublicKey = NULL,
+    .bigNumCompare = NULL
+};
+
+const AlgLoader *GetRealLoaderInstance()
+{
+    return &g_huksLoader;
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/linux/lite/mbedtls_hash_to_point.c deviceauth_new/hals/src/linux/lite/mbedtls_hash_to_point.c
--- deviceauth/hals/src/linux/lite/mbedtls_hash_to_point.c	2025-02-12 16:28:23.751894000 +0800
+++ deviceauth_new/hals/src/linux/lite/mbedtls_hash_to_point.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,277 +1,277 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdio.h>
-
-#include <mbedtls/bignum.h>
-#include <securec.h>
-
-#include "alg_defs.h"
-#include "hc_log.h"
-#include "mbedtls_hash_to_point.h"
-
-#define HASH_TO_POINT_PARA_NUMS 6
-
-#define LOG_AND_GOTO_CLEANUP_IF_FAIL(ret, fmt, ...) \
-do { \
-    if ((ret) != 0) { \
-        LOGE(fmt, ##__VA_ARGS__); \
-        goto CLEAN_UP; \
-    } \
-} while(0)
-
-static uint8_t g_hash2pointParas[HASH_TO_POINT_PARA_NUMS][BYTE_LENGTH_CURVE_25519] = {
-    { 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,    /* 0:p */
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed },
-    { 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,    /* 1:divide_minus_p_1_2 */
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6 },
-    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    /* 2:A */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x6d, 0x06 },
-    { 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,    /* 3:-A */
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-      0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x92, 0xe7 },
-    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    /* 4:u = 2 */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 },
-    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    /* 5:1 */
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
-};
-
-static void FreeCleanFiveBns(mbedtls_mpi *bn1, mbedtls_mpi *bn2, mbedtls_mpi *bn3,
-                             mbedtls_mpi *bn4, mbedtls_mpi *bn5)
-{
-    mbedtls_mpi_free(bn1);
-    mbedtls_mpi_free(bn2);
-    mbedtls_mpi_free(bn3);
-    mbedtls_mpi_free(bn4);
-    mbedtls_mpi_free(bn5);
-}
-
-static void SwapEndian(uint8_t *pubKey, int len)
-{
-    if ((pubKey == NULL) || (len <= 0)) {
-        return;
-    }
-    for (int i = 0; i < len / 2; ++i) {
-        uint8_t tmp = pubKey[i];
-        pubKey[i] = pubKey[len - i - 1];
-        pubKey[len - i - 1] = tmp;
-    }
-}
-
-static bool IsInvalidBlob(const Uint8Buff *blob)
-{
-    return blob == NULL || blob->val == NULL || blob->length == 0;
-}
-
-static int32_t CalTmpParaX(mbedtls_mpi *tmpY, const mbedtls_mpi *tmpX, const mbedtls_mpi *modP)
-{
-    int32_t status;
-    mbedtls_mpi tmpBnA;
-    mbedtls_mpi tmpBnB;
-    mbedtls_mpi tmpBnC;
-    mbedtls_mpi tmpBnE;
-    mbedtls_mpi paraBnA;
-    mbedtls_mpi paraBnU;
-
-    mbedtls_mpi_init(&tmpBnA);
-    mbedtls_mpi_init(&tmpBnB);
-    mbedtls_mpi_init(&tmpBnC);
-    mbedtls_mpi_init(&tmpBnE);
-    mbedtls_mpi_init(&paraBnA);
-    mbedtls_mpi_init(&paraBnU);
-
-    status = mbedtls_mpi_read_binary(&paraBnA, g_hash2pointParas[2], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error1");
-
-    status = mbedtls_mpi_read_binary(&paraBnU, g_hash2pointParas[4], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error2");
-
-    status = mbedtls_mpi_copy(&tmpBnB, tmpX);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error3");
-    /* a := b ^ 3 + A * b ^ 2 + b */
-
-    status = mbedtls_mpi_exp_mod(&tmpBnE, &tmpBnB, &paraBnU, modP, NULL);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error4"); // b^2
-
-    status = mbedtls_mpi_mul_mpi(&tmpBnC, &tmpBnE, &tmpBnB);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error5");
-    status = mbedtls_mpi_mod_mpi(&tmpBnC, &tmpBnC, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error6"); // b^3
-
-    status = mbedtls_mpi_mul_mpi(&tmpBnA, &tmpBnE, &paraBnA); // A*b^2
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error7");
-    status = mbedtls_mpi_mod_mpi(&tmpBnA, &tmpBnA, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error8");
-
-    status = mbedtls_mpi_add_mpi(&tmpBnE, &tmpBnC, &tmpBnA); // b^3 + A*b^2
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error9");
-    status = mbedtls_mpi_mod_mpi(&tmpBnE, &tmpBnE, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error10");
-
-    status = mbedtls_mpi_add_mpi(tmpY, &tmpBnE, &tmpBnB); // b^3 + A*b^2 + b
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error11");
-    status = mbedtls_mpi_mod_mpi(tmpY, tmpY, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error12");
-
-CLEAN_UP:
-    FreeCleanFiveBns(&paraBnA, &tmpBnA, &tmpBnB, &tmpBnC, &tmpBnE);
-    mbedtls_mpi_free(&paraBnU);
-    return status;
-}
-
-static int32_t CalTmpParab(mbedtls_mpi *tmpX, const mbedtls_mpi *modP, const uint8_t *hash, uint32_t hashLen)
-{
-    int32_t status;
-    mbedtls_mpi paraBnNegA;
-    mbedtls_mpi paraBNOne;
-    mbedtls_mpi paraBnU;
-    mbedtls_mpi tmpBnA;
-    mbedtls_mpi tmpBnB;
-
-    mbedtls_mpi_init(&paraBnNegA);
-    mbedtls_mpi_init(&paraBNOne);
-    mbedtls_mpi_init(&paraBnU);
-    mbedtls_mpi_init(&tmpBnA);
-    mbedtls_mpi_init(&tmpBnB);
-
-    status = mbedtls_mpi_read_binary(&paraBnNegA, g_hash2pointParas[3], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error1");
-    status = mbedtls_mpi_read_binary(&paraBNOne, g_hash2pointParas[5], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error2");
-    status = mbedtls_mpi_read_binary(&paraBnU, g_hash2pointParas[4], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error3");
-    status = mbedtls_mpi_read_binary(&tmpBnA, hash, hashLen);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error4");
-
-    /* b := -A / (1 + u * a ^ 2) */
-    status = mbedtls_mpi_exp_mod(&tmpBnB, &tmpBnA, &paraBnU, modP, NULL);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error5");
-
-    status = mbedtls_mpi_mul_mpi(&tmpBnA, &tmpBnB, &paraBnU);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error6");
-    status = mbedtls_mpi_mod_mpi(&tmpBnA, &tmpBnA, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error7");
-
-    status = mbedtls_mpi_add_mpi(&tmpBnB, &tmpBnA, &paraBNOne);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error8");
-    status = mbedtls_mpi_mod_mpi(&tmpBnB, &tmpBnB, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error9");
-
-    status = mbedtls_mpi_inv_mod(&tmpBnA, &tmpBnB, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error10");
-
-    status = mbedtls_mpi_mul_mpi(tmpX, &tmpBnA, &paraBnNegA);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error11");
-    status = mbedtls_mpi_mod_mpi(tmpX, tmpX, modP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error12");
-CLEAN_UP:
-    FreeCleanFiveBns(&paraBnNegA, &paraBNOne, &paraBnU, &tmpBnA, &tmpBnB);
-    return status;
-}
-
-/*
- * hash2point function, use BoringSSL big number algorithm library;
- * p_point(little endian): the output pointer of Curve25519 point;
- * p_hash (little endian): the input pointer of string;
- */
-static int32_t Elligator(unsigned char *point, int pointLength, const unsigned char *hash, int hashLength)
-{
-    mbedtls_mpi paraBnP;
-    mbedtls_mpi paraBnSquare;
-    mbedtls_mpi paraBnNegA;
-    mbedtls_mpi tmpBnA;
-    mbedtls_mpi tmpBnB;
-    mbedtls_mpi tmpBnC;
-    mbedtls_mpi tmpBnE;
-
-    mbedtls_mpi_init(&paraBnP);
-    mbedtls_mpi_init(&paraBnSquare);
-    mbedtls_mpi_init(&paraBnNegA);
-    mbedtls_mpi_init(&tmpBnA);
-    mbedtls_mpi_init(&tmpBnB);
-    mbedtls_mpi_init(&tmpBnC);
-    mbedtls_mpi_init(&tmpBnE);
-
-    int32_t status = mbedtls_mpi_read_binary(&paraBnP, g_hash2pointParas[0], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error1");
-    status = mbedtls_mpi_read_binary(&paraBnSquare, g_hash2pointParas[1], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error2");
-    status = mbedtls_mpi_read_binary(&paraBnNegA, g_hash2pointParas[3], BYTE_LENGTH_CURVE_25519);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error3");
-
-    status = CalTmpParab(&tmpBnB, &paraBnP, hash, hashLength);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error4");
-    status = CalTmpParaX(&tmpBnA, &tmpBnB, &paraBnP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error5");
-
-    status = mbedtls_mpi_sub_mpi(&tmpBnC, &paraBnP, &tmpBnB);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error6");
-    status = mbedtls_mpi_mod_mpi(&tmpBnC, &tmpBnC, &paraBnP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error7");
-
-    status = mbedtls_mpi_add_mpi(&tmpBnC, &tmpBnC, &paraBnNegA);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error8");
-    status = mbedtls_mpi_mod_mpi(&tmpBnC, &tmpBnC, &paraBnP);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error9");
-
-    status = mbedtls_mpi_exp_mod(&tmpBnE, &tmpBnA, &paraBnSquare, &paraBnP, NULL);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error10");
-
-    uint8_t swap = (mbedtls_mpi_cmp_mpi(&paraBnSquare, &tmpBnE) == 1);
-    status = mbedtls_mpi_safe_cond_swap(&tmpBnB, &tmpBnC, swap);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error11");
-
-    status = mbedtls_mpi_write_binary(&tmpBnC, point, pointLength);
-    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error12");
-
-    SwapEndian(point, pointLength);
-CLEAN_UP:
-    mbedtls_mpi_free(&paraBnP);
-    mbedtls_mpi_free(&paraBnSquare);
-    FreeCleanFiveBns(&paraBnNegA, &tmpBnA, &tmpBnB, &tmpBnC, &tmpBnE);
-    return status;
-}
-
-int32_t MbedtlsHashToPoint(const Uint8Buff *hash, Uint8Buff *outEcPoint)
-{
-    if (IsInvalidBlob(hash) || IsInvalidBlob(outEcPoint)) {
-        return HC_ERR_INVALID_PARAMS;
-    }
-    if (hash->length != BYTE_LENGTH_CURVE_25519 || outEcPoint->length != BYTE_LENGTH_CURVE_25519) {
-        LOGE("MbedtlsHashToPoint invalid length.");
-        return HC_ERR_INVALID_PARAMS;
-    }
-    uint8_t hashTmp[BYTE_LENGTH_CURVE_25519] = {0};
-    (void)memcpy_s(hashTmp, BYTE_LENGTH_CURVE_25519, hash->val, BYTE_LENGTH_CURVE_25519);
-
-    hashTmp[BYTE_LENGTH_CURVE_25519 - 1] &= ~HASH2POINT_PARA_PREPRO;
-    SwapEndian(hashTmp, BYTE_LENGTH_CURVE_25519);
-    int status = Elligator(outEcPoint->val, BYTE_LENGTH_CURVE_25519, hashTmp, BYTE_LENGTH_CURVE_25519);
-    if (status != 0) {
-        LOGE("Elligator failed, status:%d", status);
-    }
-    return status;
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+
+#include <mbedtls/bignum.h>
+#include <securec.h>
+
+#include "alg_defs.h"
+#include "hc_log.h"
+#include "mbedtls_hash_to_point.h"
+
+#define HASH_TO_POINT_PARA_NUMS 6
+
+#define LOG_AND_GOTO_CLEANUP_IF_FAIL(ret, fmt, ...) \
+do { \
+    if ((ret) != 0) { \
+        LOGE(fmt, ##__VA_ARGS__); \
+        goto CLEAN_UP; \
+    } \
+} while(0)
+
+static uint8_t g_hash2pointParas[HASH_TO_POINT_PARA_NUMS][BYTE_LENGTH_CURVE_25519] = {
+    { 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,    /* 0:p */
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed },
+    { 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,    /* 1:divide_minus_p_1_2 */
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6 },
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    /* 2:A */
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x6d, 0x06 },
+    { 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,    /* 3:-A */
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+      0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x92, 0xe7 },
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    /* 4:u = 2 */
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 },
+    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    /* 5:1 */
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
+};
+
+static void FreeCleanFiveBns(mbedtls_mpi *bn1, mbedtls_mpi *bn2, mbedtls_mpi *bn3,
+                             mbedtls_mpi *bn4, mbedtls_mpi *bn5)
+{
+    mbedtls_mpi_free(bn1);
+    mbedtls_mpi_free(bn2);
+    mbedtls_mpi_free(bn3);
+    mbedtls_mpi_free(bn4);
+    mbedtls_mpi_free(bn5);
+}
+
+static void SwapEndian(uint8_t *pubKey, int len)
+{
+    if ((pubKey == NULL) || (len <= 0)) {
+        return;
+    }
+    for (int i = 0; i < len / 2; ++i) {
+        uint8_t tmp = pubKey[i];
+        pubKey[i] = pubKey[len - i - 1];
+        pubKey[len - i - 1] = tmp;
+    }
+}
+
+static bool IsInvalidBlob(const Uint8Buff *blob)
+{
+    return blob == NULL || blob->val == NULL || blob->length == 0;
+}
+
+static int32_t CalTmpParaX(mbedtls_mpi *tmpY, const mbedtls_mpi *tmpX, const mbedtls_mpi *modP)
+{
+    int32_t status;
+    mbedtls_mpi tmpBnA;
+    mbedtls_mpi tmpBnB;
+    mbedtls_mpi tmpBnC;
+    mbedtls_mpi tmpBnE;
+    mbedtls_mpi paraBnA;
+    mbedtls_mpi paraBnU;
+
+    mbedtls_mpi_init(&tmpBnA);
+    mbedtls_mpi_init(&tmpBnB);
+    mbedtls_mpi_init(&tmpBnC);
+    mbedtls_mpi_init(&tmpBnE);
+    mbedtls_mpi_init(&paraBnA);
+    mbedtls_mpi_init(&paraBnU);
+
+    status = mbedtls_mpi_read_binary(&paraBnA, g_hash2pointParas[2], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error1");
+
+    status = mbedtls_mpi_read_binary(&paraBnU, g_hash2pointParas[4], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error2");
+
+    status = mbedtls_mpi_copy(&tmpBnB, tmpX);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error3");
+    /* a := b ^ 3 + A * b ^ 2 + b */
+
+    status = mbedtls_mpi_exp_mod(&tmpBnE, &tmpBnB, &paraBnU, modP, NULL);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error4"); // b^2
+
+    status = mbedtls_mpi_mul_mpi(&tmpBnC, &tmpBnE, &tmpBnB);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error5");
+    status = mbedtls_mpi_mod_mpi(&tmpBnC, &tmpBnC, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error6"); // b^3
+
+    status = mbedtls_mpi_mul_mpi(&tmpBnA, &tmpBnE, &paraBnA); // A*b^2
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error7");
+    status = mbedtls_mpi_mod_mpi(&tmpBnA, &tmpBnA, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error8");
+
+    status = mbedtls_mpi_add_mpi(&tmpBnE, &tmpBnC, &tmpBnA); // b^3 + A*b^2
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error9");
+    status = mbedtls_mpi_mod_mpi(&tmpBnE, &tmpBnE, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error10");
+
+    status = mbedtls_mpi_add_mpi(tmpY, &tmpBnE, &tmpBnB); // b^3 + A*b^2 + b
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error11");
+    status = mbedtls_mpi_mod_mpi(tmpY, tmpY, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParaX error12");
+
+CLEAN_UP:
+    FreeCleanFiveBns(&paraBnA, &tmpBnA, &tmpBnB, &tmpBnC, &tmpBnE);
+    mbedtls_mpi_free(&paraBnU);
+    return status;
+}
+
+static int32_t CalTmpParab(mbedtls_mpi *tmpX, const mbedtls_mpi *modP, const uint8_t *hash, uint32_t hashLen)
+{
+    int32_t status;
+    mbedtls_mpi paraBnNegA;
+    mbedtls_mpi paraBNOne;
+    mbedtls_mpi paraBnU;
+    mbedtls_mpi tmpBnA;
+    mbedtls_mpi tmpBnB;
+
+    mbedtls_mpi_init(&paraBnNegA);
+    mbedtls_mpi_init(&paraBNOne);
+    mbedtls_mpi_init(&paraBnU);
+    mbedtls_mpi_init(&tmpBnA);
+    mbedtls_mpi_init(&tmpBnB);
+
+    status = mbedtls_mpi_read_binary(&paraBnNegA, g_hash2pointParas[3], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error1");
+    status = mbedtls_mpi_read_binary(&paraBNOne, g_hash2pointParas[5], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error2");
+    status = mbedtls_mpi_read_binary(&paraBnU, g_hash2pointParas[4], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error3");
+    status = mbedtls_mpi_read_binary(&tmpBnA, hash, hashLen);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error4");
+
+    /* b := -A / (1 + u * a ^ 2) */
+    status = mbedtls_mpi_exp_mod(&tmpBnB, &tmpBnA, &paraBnU, modP, NULL);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error5");
+
+    status = mbedtls_mpi_mul_mpi(&tmpBnA, &tmpBnB, &paraBnU);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error6");
+    status = mbedtls_mpi_mod_mpi(&tmpBnA, &tmpBnA, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error7");
+
+    status = mbedtls_mpi_add_mpi(&tmpBnB, &tmpBnA, &paraBNOne);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error8");
+    status = mbedtls_mpi_mod_mpi(&tmpBnB, &tmpBnB, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error9");
+
+    status = mbedtls_mpi_inv_mod(&tmpBnA, &tmpBnB, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error10");
+
+    status = mbedtls_mpi_mul_mpi(tmpX, &tmpBnA, &paraBnNegA);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error11");
+    status = mbedtls_mpi_mod_mpi(tmpX, tmpX, modP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "CalTmpParab error12");
+CLEAN_UP:
+    FreeCleanFiveBns(&paraBnNegA, &paraBNOne, &paraBnU, &tmpBnA, &tmpBnB);
+    return status;
+}
+
+/*
+ * hash2point function, use BoringSSL big number algorithm library;
+ * p_point(little endian): the output pointer of Curve25519 point;
+ * p_hash (little endian): the input pointer of string;
+ */
+static int32_t Elligator(unsigned char *point, int pointLength, const unsigned char *hash, int hashLength)
+{
+    mbedtls_mpi paraBnP;
+    mbedtls_mpi paraBnSquare;
+    mbedtls_mpi paraBnNegA;
+    mbedtls_mpi tmpBnA;
+    mbedtls_mpi tmpBnB;
+    mbedtls_mpi tmpBnC;
+    mbedtls_mpi tmpBnE;
+
+    mbedtls_mpi_init(&paraBnP);
+    mbedtls_mpi_init(&paraBnSquare);
+    mbedtls_mpi_init(&paraBnNegA);
+    mbedtls_mpi_init(&tmpBnA);
+    mbedtls_mpi_init(&tmpBnB);
+    mbedtls_mpi_init(&tmpBnC);
+    mbedtls_mpi_init(&tmpBnE);
+
+    int32_t status = mbedtls_mpi_read_binary(&paraBnP, g_hash2pointParas[0], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error1");
+    status = mbedtls_mpi_read_binary(&paraBnSquare, g_hash2pointParas[1], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error2");
+    status = mbedtls_mpi_read_binary(&paraBnNegA, g_hash2pointParas[3], BYTE_LENGTH_CURVE_25519);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error3");
+
+    status = CalTmpParab(&tmpBnB, &paraBnP, hash, hashLength);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error4");
+    status = CalTmpParaX(&tmpBnA, &tmpBnB, &paraBnP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error5");
+
+    status = mbedtls_mpi_sub_mpi(&tmpBnC, &paraBnP, &tmpBnB);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error6");
+    status = mbedtls_mpi_mod_mpi(&tmpBnC, &tmpBnC, &paraBnP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error7");
+
+    status = mbedtls_mpi_add_mpi(&tmpBnC, &tmpBnC, &paraBnNegA);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error8");
+    status = mbedtls_mpi_mod_mpi(&tmpBnC, &tmpBnC, &paraBnP);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error9");
+
+    status = mbedtls_mpi_exp_mod(&tmpBnE, &tmpBnA, &paraBnSquare, &paraBnP, NULL);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error10");
+
+    uint8_t swap = (mbedtls_mpi_cmp_mpi(&paraBnSquare, &tmpBnE) == 1);
+    status = mbedtls_mpi_safe_cond_swap(&tmpBnB, &tmpBnC, swap);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error11");
+
+    status = mbedtls_mpi_write_binary(&tmpBnC, point, pointLength);
+    LOG_AND_GOTO_CLEANUP_IF_FAIL(status, "Elligator error12");
+
+    SwapEndian(point, pointLength);
+CLEAN_UP:
+    mbedtls_mpi_free(&paraBnP);
+    mbedtls_mpi_free(&paraBnSquare);
+    FreeCleanFiveBns(&paraBnNegA, &tmpBnA, &tmpBnB, &tmpBnC, &tmpBnE);
+    return status;
+}
+
+int32_t MbedtlsHashToPoint(const Uint8Buff *hash, Uint8Buff *outEcPoint)
+{
+    if (IsInvalidBlob(hash) || IsInvalidBlob(outEcPoint)) {
+        return HC_ERR_INVALID_PARAMS;
+    }
+    if (hash->length != BYTE_LENGTH_CURVE_25519 || outEcPoint->length != BYTE_LENGTH_CURVE_25519) {
+        LOGE("MbedtlsHashToPoint invalid length.");
+        return HC_ERR_INVALID_PARAMS;
+    }
+    uint8_t hashTmp[BYTE_LENGTH_CURVE_25519] = {0};
+    (void)memcpy_s(hashTmp, BYTE_LENGTH_CURVE_25519, hash->val, BYTE_LENGTH_CURVE_25519);
+
+    hashTmp[BYTE_LENGTH_CURVE_25519 - 1] &= ~HASH2POINT_PARA_PREPRO;
+    SwapEndian(hashTmp, BYTE_LENGTH_CURVE_25519);
+    int status = Elligator(outEcPoint->val, BYTE_LENGTH_CURVE_25519, hashTmp, BYTE_LENGTH_CURVE_25519);
+    if (status != 0) {
+        LOGE("Elligator failed, status:%d", status);
+    }
+    return status;
+}
diff -Naru deviceauth/hals/src/liteos/hc_condition.c deviceauth_new/hals/src/liteos/hc_condition.c
--- deviceauth/hals/src/liteos/hc_condition.c	2025-02-12 16:28:23.877381500 +0800
+++ deviceauth_new/hals/src/liteos/hc_condition.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,58 +1,58 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_condition.h"
-
-int HcCondWait(struct HcConditionT* hcCond)
-{
-    if (hcCond == NULL) {
-        return -1;
-    }
-
-    return sem_wait(&hcCond->sem);
-}
-
-void HcCondNotify(struct HcConditionT* hcCond)
-{
-    if (hcCond == NULL) {
-        return;
-    }
-
-    sem_post(&hcCond->sem);
-}
-
-int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex)
-{
-    (void)mutex;
-    if (hcCond == NULL) {
-        return -1;
-    }
-    hcCond->wait = HcCondWait;
-    hcCond->notify = HcCondNotify;
-    hcCond->waitWithoutLock = HcCondWait;
-    hcCond->notifyWithoutLock = HcCondNotify;
-
-    // init the signal value to zero
-    return sem_init(&hcCond->sem, 0, 0);
-}
-
-void DestroyHcCond(HcCondition* hcCond)
-{
-    if (hcCond == NULL) {
-        return;
-    }
-
-    sem_destroy(&hcCond->sem);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_condition.h"
+
+int HcCondWait(struct HcConditionT* hcCond)
+{
+    if (hcCond == NULL) {
+        return -1;
+    }
+
+    return sem_wait(&hcCond->sem);
+}
+
+void HcCondNotify(struct HcConditionT* hcCond)
+{
+    if (hcCond == NULL) {
+        return;
+    }
+
+    sem_post(&hcCond->sem);
+}
+
+int32_t InitHcCond(HcCondition* hcCond, HcMutex* mutex)
+{
+    (void)mutex;
+    if (hcCond == NULL) {
+        return -1;
+    }
+    hcCond->wait = HcCondWait;
+    hcCond->notify = HcCondNotify;
+    hcCond->waitWithoutLock = HcCondWait;
+    hcCond->notifyWithoutLock = HcCondNotify;
+
+    // init the signal value to zero
+    return sem_init(&hcCond->sem, 0, 0);
+}
+
+void DestroyHcCond(HcCondition* hcCond)
+{
+    if (hcCond == NULL) {
+        return;
+    }
+
+    sem_destroy(&hcCond->sem);
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/liteos/hc_file.c deviceauth_new/hals/src/liteos/hc_file.c
--- deviceauth/hals/src/liteos/hc_file.c	2025-02-12 16:28:23.909126300 +0800
+++ deviceauth_new/hals/src/liteos/hc_file.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,215 +1,215 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_file.h"
-#include <errno.h>
-#include <fcntl.h>
-#include <securec.h>
-#include <stdio.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include "common_defs.h"
-#include "hc_error.h"
-#include "hc_log.h"
-
-#define MAX_FILE_PATH_SIZE 256
-#define MAX_FOLDER_NAME_SIZE 128
-#define GET_FOLDER_OK 0
-#define GET_FOLDER_FAILED (-1)
-#define GET_FILE_OK 1
-#define DEFAULT_FILE_PERMISSION 0666
-
-typedef struct {
-    FileIdEnum fileId;
-    const char* filePath;
-} FileDefInfo;
-
-static FileDefInfo g_fileDefInfo[FILE_ID_LAST] = {
-    { FILE_ID_GROUP, "user/Hichain/hcgroup.dat" }
-};
-
-static char g_groupPath[MAX_FILE_PATH_SIZE] = { 0 };
-
-void SetFilePath(FileIdEnum fileId, const char *path)
-{
-    if (path == NULL) {
-        LOGE("Invalid path param");
-        return;
-    }
-    if (sprintf_s(g_groupPath, MAX_FILE_PATH_SIZE, "%s", path) != -1) {
-        g_fileDefInfo[fileId].filePath = g_groupPath;
-    }
-}
-
-int GetNextFolder(const char *filePath, int *beginPos, char *dst, int size)
-{
-    int pos = (*beginPos);
-    while (1) {
-        char c = filePath[pos++];
-        if (c == '\0') {
-            if (memcpy_s(dst, size, filePath, pos - 1) != EOK) {
-                return GET_FOLDER_FAILED;
-            }
-            dst[pos - 1] = '\0';
-            (*beginPos) = pos;
-            return GET_FILE_OK;
-        } else if (c == '/') {
-            if (memcpy_s(dst, size, filePath, pos - 1) != EOK) {
-                return GET_FOLDER_FAILED;
-            }
-            dst[pos - 1] = '\0';
-            (*beginPos) = pos;
-            return GET_FOLDER_OK;
-        } else {
-            if (pos >= size) {
-                (*beginPos) = pos;
-                return GET_FOLDER_FAILED;
-            }
-        }
-    }
-}
-
-int HcFileOpenRead(const char *path)
-{
-    return open(path, O_RDONLY);
-}
-
-static int IsFileValid(const char *path)
-{
-    struct stat fileStat;
-    int32_t ret = stat(path, &fileStat);
-    if (ret == -1) {
-        if (errno == ENOENT) {
-            return HAL_ERR_FILE_NOT_EXIST;
-        } else {
-            LOGE("file stat failed, errno = 0x%x", errno);
-            return HAL_ERR_FILE;
-        }
-    }
-
-    return 0;
-}
-
-int HcFileOpenWrite(const char *path)
-{
-    char filePath[MAX_FOLDER_NAME_SIZE + 1];
-    int beginPos = 0;
-    while (1) {
-        int ret = GetNextFolder(path, &beginPos, filePath, sizeof(filePath));
-        if (ret == GET_FOLDER_OK) {
-            if (IsFileValid(filePath) == 0) {
-                continue;
-            }
-            if (mkdir(filePath, DEFAULT_FILE_PERMISSION) != 0) {
-                return -1;
-            }
-        } else if (ret == GET_FOLDER_FAILED) {
-            return -1;
-        } else {
-            int fd = open(filePath, O_RDWR | O_CREAT);
-            if (fd == -1) {
-                LOGE("file stat failed, errno = 0x%x", errno);
-            }
-            return fd;
-        }
-    }
-}
-
-int HcFileOpen(int fileId, int mode, FileHandle *file)
-{
-    if (fileId < 0 || fileId >= FILE_ID_LAST || file == NULL) {
-        return -1;
-    }
-    if (mode == MODE_FILE_READ) {
-        file->fileHandle.fd = HcFileOpenRead(g_fileDefInfo[fileId].filePath);
-    } else {
-        file->fileHandle.fd = HcFileOpenWrite(g_fileDefInfo[fileId].filePath);
-    }
-    if (file->fileHandle.fd == -1) {
-        return -1;
-    }
-    return 0;
-}
-
-int HcFileSize(FileHandle file)
-{
-    int fp = file.fileHandle.fd;
-    int size = lseek(fp, 0, SEEK_END);
-    (void)lseek(fp, 0, SEEK_SET);
-    return size;
-}
-
-int HcFileRead(FileHandle file, void *dst, int dstSize)
-{
-    int fp = file.fileHandle.fd;
-    if (fp  == -1 || dstSize < 0 || dst == NULL) {
-        return -1;
-    }
-
-    char *dstBuffer = (char *)dst;
-    int total = 0;
-    while (total < dstSize) {
-        int readCount = read(fp, dstBuffer + total, dstSize - total);
-        if (readCount < 0 || readCount > (dstSize - total)) {
-            LOGE("read errno :%x", errno);
-            return -1;
-        }
-        if (readCount == 0) {
-            LOGE("read errno :%x", errno);
-            return total;
-        }
-        total += readCount;
-    }
-
-    return total;
-}
-
-int HcFileWrite(FileHandle file, const void *src, int srcSize)
-{
-    int fp = file.fileHandle.fd;
-    if (fp == -1 || srcSize < 0 || src == NULL) {
-        return -1;
-    }
-
-    const char *srcBuffer = (const char *)src;
-    int total = 0;
-    while (total < srcSize) {
-        int writeCount = write(fp, srcBuffer + total, srcSize - total);
-        if (writeCount < 0 || writeCount > (srcSize - total)) {
-            return -1;
-        }
-        total += writeCount;
-    }
-    return total;
-}
-
-void HcFileClose(FileHandle file)
-{
-    int fp = file.fileHandle.fd;
-    if (fp == 0) {
-        return;
-    }
-
-    close(fp);
-}
-
-void HcFileRemove(int fileId)
-{
-    if (fileId >= FILE_ID_LAST) {
-        LOGE("Invalid fileId:%d", fileId);
-        return;
-    }
-    unlink(g_fileDefInfo[fileId].filePath);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_file.h"
+#include <errno.h>
+#include <fcntl.h>
+#include <securec.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include "common_defs.h"
+#include "hc_error.h"
+#include "hc_log.h"
+
+#define MAX_FILE_PATH_SIZE 256
+#define MAX_FOLDER_NAME_SIZE 128
+#define GET_FOLDER_OK 0
+#define GET_FOLDER_FAILED (-1)
+#define GET_FILE_OK 1
+#define DEFAULT_FILE_PERMISSION 0666
+
+typedef struct {
+    FileIdEnum fileId;
+    const char* filePath;
+} FileDefInfo;
+
+static FileDefInfo g_fileDefInfo[FILE_ID_LAST] = {
+    { FILE_ID_GROUP, "user/Hichain/hcgroup.dat" }
+};
+
+static char g_groupPath[MAX_FILE_PATH_SIZE] = { 0 };
+
+void SetFilePath(FileIdEnum fileId, const char *path)
+{
+    if (path == NULL) {
+        LOGE("Invalid path param");
+        return;
+    }
+    if (sprintf_s(g_groupPath, MAX_FILE_PATH_SIZE, "%s", path) != -1) {
+        g_fileDefInfo[fileId].filePath = g_groupPath;
+    }
+}
+
+int GetNextFolder(const char *filePath, int *beginPos, char *dst, int size)
+{
+    int pos = (*beginPos);
+    while (1) {
+        char c = filePath[pos++];
+        if (c == '\0') {
+            if (memcpy_s(dst, size, filePath, pos - 1) != EOK) {
+                return GET_FOLDER_FAILED;
+            }
+            dst[pos - 1] = '\0';
+            (*beginPos) = pos;
+            return GET_FILE_OK;
+        } else if (c == '/') {
+            if (memcpy_s(dst, size, filePath, pos - 1) != EOK) {
+                return GET_FOLDER_FAILED;
+            }
+            dst[pos - 1] = '\0';
+            (*beginPos) = pos;
+            return GET_FOLDER_OK;
+        } else {
+            if (pos >= size) {
+                (*beginPos) = pos;
+                return GET_FOLDER_FAILED;
+            }
+        }
+    }
+}
+
+int HcFileOpenRead(const char *path)
+{
+    return open(path, O_RDONLY);
+}
+
+static int IsFileValid(const char *path)
+{
+    struct stat fileStat;
+    int32_t ret = stat(path, &fileStat);
+    if (ret == -1) {
+        if (errno == ENOENT) {
+            return HAL_ERR_FILE_NOT_EXIST;
+        } else {
+            LOGE("file stat failed, errno = 0x%x", errno);
+            return HAL_ERR_FILE;
+        }
+    }
+
+    return 0;
+}
+
+int HcFileOpenWrite(const char *path)
+{
+    char filePath[MAX_FOLDER_NAME_SIZE + 1];
+    int beginPos = 0;
+    while (1) {
+        int ret = GetNextFolder(path, &beginPos, filePath, sizeof(filePath));
+        if (ret == GET_FOLDER_OK) {
+            if (IsFileValid(filePath) == 0) {
+                continue;
+            }
+            if (mkdir(filePath, DEFAULT_FILE_PERMISSION) != 0) {
+                return -1;
+            }
+        } else if (ret == GET_FOLDER_FAILED) {
+            return -1;
+        } else {
+            int fd = open(filePath, O_RDWR | O_CREAT);
+            if (fd == -1) {
+                LOGE("file stat failed, errno = 0x%x", errno);
+            }
+            return fd;
+        }
+    }
+}
+
+int HcFileOpen(int fileId, int mode, FileHandle *file)
+{
+    if (fileId < 0 || fileId >= FILE_ID_LAST || file == NULL) {
+        return -1;
+    }
+    if (mode == MODE_FILE_READ) {
+        file->fileHandle.fd = HcFileOpenRead(g_fileDefInfo[fileId].filePath);
+    } else {
+        file->fileHandle.fd = HcFileOpenWrite(g_fileDefInfo[fileId].filePath);
+    }
+    if (file->fileHandle.fd == -1) {
+        return -1;
+    }
+    return 0;
+}
+
+int HcFileSize(FileHandle file)
+{
+    int fp = file.fileHandle.fd;
+    int size = lseek(fp, 0, SEEK_END);
+    (void)lseek(fp, 0, SEEK_SET);
+    return size;
+}
+
+int HcFileRead(FileHandle file, void *dst, int dstSize)
+{
+    int fp = file.fileHandle.fd;
+    if (fp  == -1 || dstSize < 0 || dst == NULL) {
+        return -1;
+    }
+
+    char *dstBuffer = (char *)dst;
+    int total = 0;
+    while (total < dstSize) {
+        int readCount = read(fp, dstBuffer + total, dstSize - total);
+        if (readCount < 0 || readCount > (dstSize - total)) {
+            LOGE("read errno :%x", errno);
+            return -1;
+        }
+        if (readCount == 0) {
+            LOGE("read errno :%x", errno);
+            return total;
+        }
+        total += readCount;
+    }
+
+    return total;
+}
+
+int HcFileWrite(FileHandle file, const void *src, int srcSize)
+{
+    int fp = file.fileHandle.fd;
+    if (fp == -1 || srcSize < 0 || src == NULL) {
+        return -1;
+    }
+
+    const char *srcBuffer = (const char *)src;
+    int total = 0;
+    while (total < srcSize) {
+        int writeCount = write(fp, srcBuffer + total, srcSize - total);
+        if (writeCount < 0 || writeCount > (srcSize - total)) {
+            return -1;
+        }
+        total += writeCount;
+    }
+    return total;
+}
+
+void HcFileClose(FileHandle file)
+{
+    int fp = file.fileHandle.fd;
+    if (fp == 0) {
+        return;
+    }
+
+    close(fp);
+}
+
+void HcFileRemove(int fileId)
+{
+    if (fileId >= FILE_ID_LAST) {
+        LOGE("Invalid fileId:%d", fileId);
+        return;
+    }
+    unlink(g_fileDefInfo[fileId].filePath);
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/liteos/hc_mutex.c deviceauth_new/hals/src/liteos/hc_mutex.c
--- deviceauth/hals/src/liteos/hc_mutex.c	2025-02-12 16:28:23.944341500 +0800
+++ deviceauth_new/hals/src/liteos/hc_mutex.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,54 +1,54 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_mutex.h"
-
-static int HcMutexLock(HcMutex *mutex)
-{
-    if (mutex == NULL) {
-        return -1;
-    }
-    return -pthread_mutex_lock(&mutex->mutex);
-}
-
-static void HcMutexUnlock(HcMutex *mutex)
-{
-    if (mutex == NULL) {
-        return;
-    }
-    pthread_mutex_unlock(&mutex->mutex);
-}
-
-int32_t InitHcMutex(struct HcMutexT *mutex)
-{
-    if (mutex == NULL) {
-        return -1;
-    }
-    int res = pthread_mutex_init(&mutex->mutex, NULL);
-    if (res != 0) {
-        return res;
-    }
-    mutex->lock = HcMutexLock;
-    mutex->unlock = HcMutexUnlock;
-    return 0;
-}
-
-void DestroyHcMutex(struct HcMutexT *mutex)
-{
-    if (mutex == NULL) {
-        return;
-    }
-    pthread_mutex_destroy(&mutex->mutex);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_mutex.h"
+
+static int HcMutexLock(HcMutex *mutex)
+{
+    if (mutex == NULL) {
+        return -1;
+    }
+    return -pthread_mutex_lock(&mutex->mutex);
+}
+
+static void HcMutexUnlock(HcMutex *mutex)
+{
+    if (mutex == NULL) {
+        return;
+    }
+    pthread_mutex_unlock(&mutex->mutex);
+}
+
+int32_t InitHcMutex(struct HcMutexT *mutex)
+{
+    if (mutex == NULL) {
+        return -1;
+    }
+    int res = pthread_mutex_init(&mutex->mutex, NULL);
+    if (res != 0) {
+        return res;
+    }
+    mutex->lock = HcMutexLock;
+    mutex->unlock = HcMutexUnlock;
+    return 0;
+}
+
+void DestroyHcMutex(struct HcMutexT *mutex)
+{
+    if (mutex == NULL) {
+        return;
+    }
+    pthread_mutex_destroy(&mutex->mutex);
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/liteos/hc_thread.c deviceauth_new/hals/src/liteos/hc_thread.c
--- deviceauth/hals/src/liteos/hc_thread.c	2025-02-12 16:28:23.981045600 +0800
+++ deviceauth_new/hals/src/liteos/hc_thread.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,143 +1,143 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_thread.h"
-
-#define MAX_THREAD_STACK_SIZE (8 * 1024 * 1024)
-
-void *StaticThreadFunc(void *args)
-{
-    HcThread *thread = (HcThread*)args;
-    if (thread == NULL) {
-        return NULL;
-    }
-
-    if (thread->threadFunc) {
-        thread->threadFunc(args);
-    }
-    thread->threadLock.lock(&thread->threadLock);
-    thread->running = HC_FALSE;
-    thread->threadWaitObj.notifyWithoutLock(&thread->threadWaitObj);
-    thread->threadLock.unlock(&thread->threadLock);
-    return NULL;
-}
-
-int Start(struct HcThreadT *thread)
-{
-    if (thread == NULL) {
-        return -1;
-    }
-    thread->threadLock.lock(&thread->threadLock);
-    if (thread->running) {
-        thread->threadLock.unlock(&thread->threadLock);
-        return 0;
-    }
-    thread->running = HC_TRUE;
-
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
-
-    if (thread->stackSize > 0 && thread->stackSize <= MAX_THREAD_STACK_SIZE) {
-        pthread_attr_setstacksize(&attr, thread->stackSize);
-    }
-
-    int result = pthread_create(&thread->thread, &attr, StaticThreadFunc, thread);
-    pthread_attr_destroy(&attr);
-    if (result != 0) {
-        thread->running = HC_FALSE;
-    }
-    thread->threadLock.unlock(&thread->threadLock);
-    return result;
-}
-
-void Join(struct HcThreadT *thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-
-    if (thread->running) {
-        thread->threadWaitObj.waitWithoutLock(&thread->threadWaitObj);
-    }
-    void *status = NULL;
-    pthread_join(thread->thread, &status);
-}
-
-void BizWait(struct HcThreadT *thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-    thread->bizWaitObj.wait(&thread->bizWaitObj);
-}
-
-void BizNotify(struct HcThreadT *thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-    thread->bizWaitObj.notify(&thread->bizWaitObj);
-}
-
-int32_t InitThread(HcThread *thread, ThreadFunc func, size_t stackSize, const char *threadName)
-{
-    if (thread == NULL) {
-        return -1;
-    }
-
-    thread->threadFunc = func;
-    thread->start = Start;
-    thread->wait = BizWait;
-    thread->notify = BizNotify;
-    thread->join = Join;
-    thread->stackSize = stackSize;
-    thread->running = HC_FALSE;
-    thread->name = CreateString();
-    if (StringSetPointer(&thread->name, threadName) != HC_TRUE) {
-        return -1;
-    }
-
-    int32_t res = InitHcMutex(&thread->threadLock);
-    if (res != 0) {
-        DeleteString(&thread->name);
-        return res;
-    }
-    res = InitHcCond(&thread->threadWaitObj, &thread->threadLock);
-    if (res != 0) {
-        DeleteString(&thread->name);
-        DestroyHcMutex(&thread->threadLock);
-        return res;
-    }
-    res = InitHcCond(&thread->bizWaitObj, NULL);
-    if (res != 0) {
-        DeleteString(&thread->name);
-        DestroyHcMutex(&thread->threadLock);
-        DestroyHcCond(&thread->threadWaitObj);
-    }
-    return res;
-}
-
-void DestroyThread(HcThread *thread)
-{
-    if (thread == NULL) {
-        return;
-    }
-
-    DestroyHcCond(&thread->bizWaitObj);
-    DestroyHcCond(&thread->threadWaitObj);
-    DestroyHcMutex(&thread->threadLock);
-    DeleteString(&thread->name);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_thread.h"
+
+#define MAX_THREAD_STACK_SIZE (8 * 1024 * 1024)
+
+void *StaticThreadFunc(void *args)
+{
+    HcThread *thread = (HcThread*)args;
+    if (thread == NULL) {
+        return NULL;
+    }
+
+    if (thread->threadFunc) {
+        thread->threadFunc(args);
+    }
+    thread->threadLock.lock(&thread->threadLock);
+    thread->running = HC_FALSE;
+    thread->threadWaitObj.notifyWithoutLock(&thread->threadWaitObj);
+    thread->threadLock.unlock(&thread->threadLock);
+    return NULL;
+}
+
+int Start(struct HcThreadT *thread)
+{
+    if (thread == NULL) {
+        return -1;
+    }
+    thread->threadLock.lock(&thread->threadLock);
+    if (thread->running) {
+        thread->threadLock.unlock(&thread->threadLock);
+        return 0;
+    }
+    thread->running = HC_TRUE;
+
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    if (thread->stackSize > 0 && thread->stackSize <= MAX_THREAD_STACK_SIZE) {
+        pthread_attr_setstacksize(&attr, thread->stackSize);
+    }
+
+    int result = pthread_create(&thread->thread, &attr, StaticThreadFunc, thread);
+    pthread_attr_destroy(&attr);
+    if (result != 0) {
+        thread->running = HC_FALSE;
+    }
+    thread->threadLock.unlock(&thread->threadLock);
+    return result;
+}
+
+void Join(struct HcThreadT *thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+
+    if (thread->running) {
+        thread->threadWaitObj.waitWithoutLock(&thread->threadWaitObj);
+    }
+    void *status = NULL;
+    pthread_join(thread->thread, &status);
+}
+
+void BizWait(struct HcThreadT *thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+    thread->bizWaitObj.wait(&thread->bizWaitObj);
+}
+
+void BizNotify(struct HcThreadT *thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+    thread->bizWaitObj.notify(&thread->bizWaitObj);
+}
+
+int32_t InitThread(HcThread *thread, ThreadFunc func, size_t stackSize, const char *threadName)
+{
+    if (thread == NULL) {
+        return -1;
+    }
+
+    thread->threadFunc = func;
+    thread->start = Start;
+    thread->wait = BizWait;
+    thread->notify = BizNotify;
+    thread->join = Join;
+    thread->stackSize = stackSize;
+    thread->running = HC_FALSE;
+    thread->name = CreateString();
+    if (StringSetPointer(&thread->name, threadName) != HC_TRUE) {
+        return -1;
+    }
+
+    int32_t res = InitHcMutex(&thread->threadLock);
+    if (res != 0) {
+        DeleteString(&thread->name);
+        return res;
+    }
+    res = InitHcCond(&thread->threadWaitObj, &thread->threadLock);
+    if (res != 0) {
+        DeleteString(&thread->name);
+        DestroyHcMutex(&thread->threadLock);
+        return res;
+    }
+    res = InitHcCond(&thread->bizWaitObj, NULL);
+    if (res != 0) {
+        DeleteString(&thread->name);
+        DestroyHcMutex(&thread->threadLock);
+        DestroyHcCond(&thread->threadWaitObj);
+    }
+    return res;
+}
+
+void DestroyThread(HcThread *thread)
+{
+    if (thread == NULL) {
+        return;
+    }
+
+    DestroyHcCond(&thread->bizWaitObj);
+    DestroyHcCond(&thread->threadWaitObj);
+    DestroyHcMutex(&thread->threadLock);
+    DeleteString(&thread->name);
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/liteos/hc_time.c deviceauth_new/hals/src/liteos/hc_time.c
--- deviceauth/hals/src/liteos/hc_time.c	2025-02-12 16:28:24.014278500 +0800
+++ deviceauth_new/hals/src/liteos/hc_time.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,49 +1,49 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_time.h"
-#include <stdio.h>
-#include <time.h>
-#include "hc_log.h"
-
-int64_t HcGetCurTime()
-{
-    struct timespec start;
-    int res = clock_gettime(CLOCK_MONOTONIC, &start);
-    if (res != 0) {
-        LOGE("clock_gettime failed, res:%d", res);
-        return -1;
-    }
-    return start.tv_sec;
-}
-
-int64_t HcGetIntervalTime(int64_t startTime)
-{
-    if (startTime < 0) {
-        LOGE("Start time is invalid");
-        return -1;
-    }
-    struct timespec end;
-    int res = clock_gettime(CLOCK_MONOTONIC, &end);
-    if (res != 0) {
-        LOGE("clock_gettime failed, res:%d", res);
-        return -1;
-    }
-    if (end.tv_sec < startTime) {
-        LOGE("End time is invalid");
-        return -1;
-    }
-    return (end.tv_sec - startTime);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_time.h"
+#include <stdio.h>
+#include <time.h>
+#include "hc_log.h"
+
+int64_t HcGetCurTime()
+{
+    struct timespec start;
+    int res = clock_gettime(CLOCK_MONOTONIC, &start);
+    if (res != 0) {
+        LOGE("clock_gettime failed, res:%d", res);
+        return -1;
+    }
+    return start.tv_sec;
+}
+
+int64_t HcGetIntervalTime(int64_t startTime)
+{
+    if (startTime < 0) {
+        LOGE("Start time is invalid");
+        return -1;
+    }
+    struct timespec end;
+    int res = clock_gettime(CLOCK_MONOTONIC, &end);
+    if (res != 0) {
+        LOGE("clock_gettime failed, res:%d", res);
+        return -1;
+    }
+    if (end.tv_sec < startTime) {
+        LOGE("End time is invalid");
+        return -1;
+    }
+    return (end.tv_sec - startTime);
 }
\ No newline at end of file
diff -Naru deviceauth/hals/src/liteos/hc_types.c deviceauth_new/hals/src/liteos/hc_types.c
--- deviceauth/hals/src/liteos/hc_types.c	2025-02-12 16:28:24.045526300 +0800
+++ deviceauth_new/hals/src/liteos/hc_types.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,59 +1,59 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_types.h"
-#include <stdlib.h>
-#include <string.h>
-#include "hc_log.h"
-#include "ohos_mem_pool.h"
-
-void *HcMalloc(uint32_t size, char val)
-{
-    if (size == 0) {
-        LOGE("Malloc size is invalid.");
-        return NULL;
-    }
-#if defined(OHOS_MEM)
-    void *addr = OhosMalloc(MEM_TYPE_HICHAIN, size);
-#else
-    void *addr = malloc(size);
-#endif
-    if (addr != NULL) {
-        (void)memset_s(addr, size, val, size);
-    }
-    return addr;
-}
-
-void HcFree(void *addr)
-{
-    if (addr != NULL) {
-#if defined(OHOS_MEM)
-    OhosFree(addr);
-#else
-    free(addr);
-#endif
-    }
-}
-
-uint32_t HcStrlen(const char *str)
-{
-    if (str == NULL) {
-        return 0;
-    }
-    const char *p = str;
-    while (*p++ != '\0') {}
-    return p - str - 1;
-}
-
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_types.h"
+#include <stdlib.h>
+#include <string.h>
+#include "hc_log.h"
+#include "ohos_mem_pool.h"
+
+void *HcMalloc(uint32_t size, char val)
+{
+    if (size == 0) {
+        LOGE("Malloc size is invalid.");
+        return NULL;
+    }
+#if defined(OHOS_MEM)
+    void *addr = OhosMalloc(MEM_TYPE_HICHAIN, size);
+#else
+    void *addr = malloc(size);
+#endif
+    if (addr != NULL) {
+        (void)memset_s(addr, size, val, size);
+    }
+    return addr;
+}
+
+void HcFree(void *addr)
+{
+    if (addr != NULL) {
+#if defined(OHOS_MEM)
+    OhosFree(addr);
+#else
+    free(addr);
+#endif
+    }
+}
+
+uint32_t HcStrlen(const char *str)
+{
+    if (str == NULL) {
+        return 0;
+    }
+    const char *p = str;
+    while (*p++ != '\0') {}
+    return p - str - 1;
+}
+
diff -Naru deviceauth/hals/src/liteos/L0/hc_file.c deviceauth_new/hals/src/liteos/L0/hc_file.c
--- deviceauth/hals/src/liteos/L0/hc_file.c	2025-02-12 16:28:24.101078600 +0800
+++ deviceauth_new/hals/src/liteos/L0/hc_file.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,138 +1,138 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_file.h"
-#include <errno.h>
-#include <fcntl.h>
-#include <securec.h>
-#include <stdio.h>
-#include "common_defs.h"
-#include "hc_error.h"
-#include "hc_log.h"
-#include "utils_file.h"
-
-#define MAX_FILE_PATH_SIZE 64
-#define MAX_FOLDER_NAME_SIZE 128
-#define GET_FOLDER_OK 0
-#define GET_FOLDER_FAILED (-1)
-#define GET_FILE_OK 1
-#define DEFAULT_FILE_PERMISSION 0666
-
-typedef struct {
-    FileIdEnum fileId;
-    char filePath[MAX_FILE_PATH_SIZE];
-} FileDefInfo;
-
-static FileDefInfo g_fileDefInfo[FILE_ID_LAST] = {
-    { FILE_ID_GROUP, "/data/hcgroup.dat" }
-};
-
-void SetFilePath(FileIdEnum fileId, const char *path)
-{
-    if (fileId < 0 || fileId >= FILE_ID_LAST || path == NULL) {
-        LOGE("Invalid path param");
-        return;
-    }
-    if (sprintf_s(g_fileDefInfo[fileId].filePath, MAX_FILE_PATH_SIZE, "%s", path) == HAL_FAILED) {
-        LOGE("Set file path failed fileId:%d", fileId);
-    }
-}
-
-int HcFileOpenRead(const char *path)
-{
-    int ret = UtilsFileOpen(path, O_RDONLY, 0);
-    LOGI("ret = %d", ret);
-    return ret;
-}
-
-int HcFileOpenWrite(const char *path)
-{
-    int ret = UtilsFileOpen(path, O_RDWR_FS | O_CREAT_FS | O_TRUNC_FS, 0);
-    LOGI("ret = %d", ret);
-    return ret;
-}
-
-int HcFileOpen(int fileId, int mode, FileHandle *file)
-{
-    if (fileId < 0 || fileId >= FILE_ID_LAST || file == NULL) {
-        return HAL_FAILED;
-    }
-    if (mode == MODE_FILE_READ) {
-        file->fileHandle.fd = HcFileOpenRead(g_fileDefInfo[fileId].filePath);
-        file->filePath = g_fileDefInfo[fileId].filePath;
-    } else {
-        file->fileHandle.fd = HcFileOpenWrite(g_fileDefInfo[fileId].filePath);
-        file->filePath = g_fileDefInfo[fileId].filePath;
-    }
-    if (file->fileHandle.fd == HAL_FAILED) {
-        return HAL_FAILED;
-    }
-    return HAL_SUCCESS;
-}
-
-int HcFileSize(FileHandle file)
-{
-    int fileSize = 0;
-    int ret = UtilsFileStat(file.filePath, (unsigned int *)&fileSize);
-    LOGI("ret = %d, fileSize = %d\n", ret, fileSize);
-    if (ret == HAL_SUCCESS) {
-        return fileSize;
-    } else {
-        return HAL_FAILED;
-    }
-    return HAL_FAILED;
-}
-
-int HcFileRead(FileHandle file, void *dst, int dstSize)
-{
-    int fp = file.fileHandle.fd;
-    if (fp  == HAL_FAILED || dstSize < 0 || dst == NULL) {
-        return HAL_FAILED;
-    }
-    int ret = UtilsFileRead(fp, (char *)dst, dstSize);
-    LOGI("ret = %d", ret);
-    return ret;
-}
-
-int HcFileWrite(FileHandle file, const void *src, int srcSize)
-{
-    int fp = file.fileHandle.fd;
-    if (fp  == HAL_FAILED || srcSize < 0 || src == NULL) {
-        return HAL_FAILED;
-    }
-    int ret = UtilsFileWrite(fp, src, srcSize);
-    LOGI("ret = %d", ret);
-    return ret;
-}
-
-void HcFileClose(FileHandle file)
-{
-    int fp = file.fileHandle.fd;
-    if (fp < 0) {
-        return;
-    }
-    int ret = UtilsFileClose(fp);
-    LOGI("ret = %d", ret);
-}
-
-void HcFileRemove(int fileId)
-{
-    if (fileId >= FILE_ID_LAST) {
-        LOGE("Invalid fileId:%d", fileId);
-        return;
-    }
-    int ret = UtilsFileDelete(g_fileDefInfo[fileId].filePath);
-    LOGI("File delete result:%d", ret);
-}
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_file.h"
+#include <errno.h>
+#include <fcntl.h>
+#include <securec.h>
+#include <stdio.h>
+#include "common_defs.h"
+#include "hc_error.h"
+#include "hc_log.h"
+#include "utils_file.h"
+
+#define MAX_FILE_PATH_SIZE 64
+#define MAX_FOLDER_NAME_SIZE 128
+#define GET_FOLDER_OK 0
+#define GET_FOLDER_FAILED (-1)
+#define GET_FILE_OK 1
+#define DEFAULT_FILE_PERMISSION 0666
+
+typedef struct {
+    FileIdEnum fileId;
+    char filePath[MAX_FILE_PATH_SIZE];
+} FileDefInfo;
+
+static FileDefInfo g_fileDefInfo[FILE_ID_LAST] = {
+    { FILE_ID_GROUP, "/data/hcgroup.dat" }
+};
+
+void SetFilePath(FileIdEnum fileId, const char *path)
+{
+    if (fileId < 0 || fileId >= FILE_ID_LAST || path == NULL) {
+        LOGE("Invalid path param");
+        return;
+    }
+    if (sprintf_s(g_fileDefInfo[fileId].filePath, MAX_FILE_PATH_SIZE, "%s", path) == HAL_FAILED) {
+        LOGE("Set file path failed fileId:%d", fileId);
+    }
+}
+
+int HcFileOpenRead(const char *path)
+{
+    int ret = UtilsFileOpen(path, O_RDONLY, 0);
+    LOGI("ret = %d", ret);
+    return ret;
+}
+
+int HcFileOpenWrite(const char *path)
+{
+    int ret = UtilsFileOpen(path, O_RDWR_FS | O_CREAT_FS | O_TRUNC_FS, 0);
+    LOGI("ret = %d", ret);
+    return ret;
+}
+
+int HcFileOpen(int fileId, int mode, FileHandle *file)
+{
+    if (fileId < 0 || fileId >= FILE_ID_LAST || file == NULL) {
+        return HAL_FAILED;
+    }
+    if (mode == MODE_FILE_READ) {
+        file->fileHandle.fd = HcFileOpenRead(g_fileDefInfo[fileId].filePath);
+        file->filePath = g_fileDefInfo[fileId].filePath;
+    } else {
+        file->fileHandle.fd = HcFileOpenWrite(g_fileDefInfo[fileId].filePath);
+        file->filePath = g_fileDefInfo[fileId].filePath;
+    }
+    if (file->fileHandle.fd == HAL_FAILED) {
+        return HAL_FAILED;
+    }
+    return HAL_SUCCESS;
+}
+
+int HcFileSize(FileHandle file)
+{
+    int fileSize = 0;
+    int ret = UtilsFileStat(file.filePath, (unsigned int *)&fileSize);
+    LOGI("ret = %d, fileSize = %d\n", ret, fileSize);
+    if (ret == HAL_SUCCESS) {
+        return fileSize;
+    } else {
+        return HAL_FAILED;
+    }
+    return HAL_FAILED;
+}
+
+int HcFileRead(FileHandle file, void *dst, int dstSize)
+{
+    int fp = file.fileHandle.fd;
+    if (fp  == HAL_FAILED || dstSize < 0 || dst == NULL) {
+        return HAL_FAILED;
+    }
+    int ret = UtilsFileRead(fp, (char *)dst, dstSize);
+    LOGI("ret = %d", ret);
+    return ret;
+}
+
+int HcFileWrite(FileHandle file, const void *src, int srcSize)
+{
+    int fp = file.fileHandle.fd;
+    if (fp  == HAL_FAILED || srcSize < 0 || src == NULL) {
+        return HAL_FAILED;
+    }
+    int ret = UtilsFileWrite(fp, src, srcSize);
+    LOGI("ret = %d", ret);
+    return ret;
+}
+
+void HcFileClose(FileHandle file)
+{
+    int fp = file.fileHandle.fd;
+    if (fp < 0) {
+        return;
+    }
+    int ret = UtilsFileClose(fp);
+    LOGI("ret = %d", ret);
+}
+
+void HcFileRemove(int fileId)
+{
+    if (fileId >= FILE_ID_LAST) {
+        LOGE("Invalid fileId:%d", fileId);
+        return;
+    }
+    int ret = UtilsFileDelete(g_fileDefInfo[fileId].filePath);
+    LOGI("File delete result:%d", ret);
+}
diff -Naru deviceauth/hals/src/liteos/L0/hc_init_protection.c deviceauth_new/hals/src/liteos/L0/hc_init_protection.c
--- deviceauth/hals/src/liteos/L0/hc_init_protection.c	2025-02-12 16:28:24.129847300 +0800
+++ deviceauth_new/hals/src/liteos/L0/hc_init_protection.c	2025-02-12 15:01:27.834543400 +0800
@@ -1,89 +1,89 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hc_init_protection.h"
-#include <stdbool.h>
-#include <stdlib.h>
-#include "hc_log.h"
-#include "hc_thread.h"
-#include "ohos_init.h"
-
-static HcMutex g_countMutex;
-static int g_singleCount = 0;
-
-int CheckInit()
-{
-    g_countMutex.lock(&g_countMutex);
-    if (g_singleCount < 0) {
-        g_singleCount = 0;
-    } else if (g_singleCount > 0) {
-        g_singleCount++;
-        g_countMutex.unlock(&g_countMutex);
-        return FINISH_INIT;
-    }
-    g_countMutex.unlock(&g_countMutex);
-    return CONTINUE_INIT;
-}
-
-int CheckDestroy()
-{
-    g_countMutex.lock(&g_countMutex);
-    if (g_singleCount == 0) {
-        g_countMutex.unlock(&g_countMutex);
-        return FINISH_DESTROY;
-    }
-    if (g_singleCount < 0) {
-        g_singleCount = 0;
-        g_countMutex.unlock(&g_countMutex);
-        return FINISH_DESTROY;
-    }
-    if (g_singleCount > 1) {
-        g_singleCount--;
-        g_countMutex.unlock(&g_countMutex);
-        return FINISH_DESTROY;
-    }
-    g_countMutex.unlock(&g_countMutex);
-    return CONTINUE_DESTROY;
-}
-
-void SetInitStatus()
-{
-    g_countMutex.lock(&g_countMutex);
-    g_singleCount = 1;
-    g_countMutex.unlock(&g_countMutex);
-    return;
-}
-
-void SetDeInitStatus()
-{
-    g_countMutex.lock(&g_countMutex);
-    g_singleCount = 0;
-    g_countMutex.unlock(&g_countMutex);
-    return;
-}
-
-void InitSecurityDevAuth()
-{
-    int32_t res = InitHcMutex(&g_countMutex);
-    if (res != 0) {
-        LOGE("When init security auth, init mutex failed");
-    }
-}
-SYS_SERVICE_INIT(InitSecurityDevAuth);
-
-void DestroySecurityDevAuth()
-{
-    DestroyHcMutex(&g_countMutex);
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hc_init_protection.h"
+#include <stdbool.h>
+#include <stdlib.h>
+#include "hc_log.h"
+#include "hc_thread.h"
+#include "ohos_init.h"
+
+static HcMutex g_countMutex;
+static int g_singleCount = 0;
+
+int CheckInit()
+{
+    g_countMutex.lock(&g_countMutex);
+    if (g_singleCount < 0) {
+        g_singleCount = 0;
+    } else if (g_singleCount > 0) {
+        g_singleCount++;
+        g_countMutex.unlock(&g_countMutex);
+        return FINISH_INIT;
+    }
+    g_countMutex.unlock(&g_countMutex);
+    return CONTINUE_INIT;
+}
+
+int CheckDestroy()
+{
+    g_countMutex.lock(&g_countMutex);
+    if (g_singleCount == 0) {
+        g_countMutex.unlock(&g_countMutex);
+        return FINISH_DESTROY;
+    }
+    if (g_singleCount < 0) {
+        g_singleCount = 0;
+        g_countMutex.unlock(&g_countMutex);
+        return FINISH_DESTROY;
+    }
+    if (g_singleCount > 1) {
+        g_singleCount--;
+        g_countMutex.unlock(&g_countMutex);
+        return FINISH_DESTROY;
+    }
+    g_countMutex.unlock(&g_countMutex);
+    return CONTINUE_DESTROY;
+}
+
+void SetInitStatus()
+{
+    g_countMutex.lock(&g_countMutex);
+    g_singleCount = 1;
+    g_countMutex.unlock(&g_countMutex);
+    return;
+}
+
+void SetDeInitStatus()
+{
+    g_countMutex.lock(&g_countMutex);
+    g_singleCount = 0;
+    g_countMutex.unlock(&g_countMutex);
+    return;
+}
+
+void InitSecurityDevAuth()
+{
+    int32_t res = InitHcMutex(&g_countMutex);
+    if (res != 0) {
+        LOGE("When init security auth, init mutex failed");
+    }
+}
+SYS_SERVICE_INIT(InitSecurityDevAuth);
+
+void DestroySecurityDevAuth()
+{
+    DestroyHcMutex(&g_countMutex);
 }
\ No newline at end of file
diff -Naru deviceauth/interfaces/innerkits/device_auth.h deviceauth_new/interfaces/innerkits/device_auth.h
--- deviceauth/interfaces/innerkits/device_auth.h	2025-02-12 16:28:24.296502300 +0800
+++ deviceauth_new/interfaces/innerkits/device_auth.h	2025-02-12 15:01:27.834543400 +0800
@@ -1,167 +1,167 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef DEVICE_AUTH_H
-#define DEVICE_AUTH_H
-
-#include <stdint.h>
-#include <stdbool.h>
-
-#if defined(__LINUX__) || defined(_UNIX)
-#define DEVICE_AUTH_API_PUBLIC __attribute__ ((visibility("default")))
-#else
-#define DEVICE_AUTH_API_PUBLIC
-#endif
-
-#define FIELD_GROUP_ID "groupId"
-#define FIELD_GROUP_TYPE "groupType"
-#define FIELD_GROUP_NAME "groupName"
-#define FIELD_PEER_DEVICE_ID "peerDeviceId"
-#define FIELD_IS_ADMIN "isAdmin"
-#define FIELD_CREDENTIAL_TYPE "credentialType"
-#define FIELD_IS_FORCE_DELETE "isForceDelete"
-#define FIELD_IS_IGNORE_CHANNEL "isIgnoreChannel"
-#define FIELD_CONNECT_PARAMS "connectParams"
-#define FIELD_ADD_ID "addId"
-#define FIELD_DELETE_ID "deleteId"
-#define FIELD_APP_ID "appId"
-#define FIELD_SERVICE_TYPE "serviceType"
-#define FIELD_PEER_AUTH_STATE "peerAuthState"
-#define FIELD_IS_DEVICE_LEVEL "isDeviceLevel"
-#define FIELD_ALTERNATIVE "alternative"
-#define FIELD_PEER_UDID "peerUdid"
-#define FIELD_PEER_CONN_DEVICE_ID "peerConnDeviceId"
-#define FIELD_KEY_LENGTH "keyLength"
-#define FIELD_IS_CLIENT "isClient"
-#define FIELD_SESSION_KEY "sessionKey"
-#define FIELD_AUTH_FORM "authForm"
-#define FIELD_CONFIRMATION "confirmation"
-#define FIELD_GROUP_OWNER "groupOwner"
-#define FIELD_PEER_AUTH_ID "peerAuthId"
-#define FIELD_PEER_USER_TYPE "peerUserType"
-#define FIELD_PEER_USER_ID "peerUserId"
-#define FIELD_SERVICE_PKG_NAME "servicePkgName"
-#define FIELD_USER_TYPE "userType"
-#define FIELD_USER_ID "userId"
-#define FIELD_DEVICE_ID "deviceId"
-#define FIELD_UID_HASH "uidHash"
-#define FIELD_PIN_CODE "pinCode"
-#define FIELD_AUTH_ID "authId"
-#define FIELD_GROUP_VISIBILITY "groupVisibility"
-#define FIELD_EXPIRE_TIME "expireTime"
-#define FIELD_IS_DELETE_ALL "isDeleteAll"
-
-typedef enum {
-    GROUP_CREATE = 0,
-    GROUP_DISBAND = 1,
-    MEMBER_INVITE = 2,
-    MEMBER_JOIN = 3,
-    MEMBER_DELETE = 4,
-    ACCOUNT_BIND = 5
-} GroupOperationCode;
-
-typedef enum {
-    CREDENTIAL_SAVE = 0,
-    CREDENTIAL_CLEAR = 1,
-    CREDENTIAL_UPDATE = 2,
-    CREDENTIAL_QUERY = 3,
-} CredentialCode;
-
-typedef enum {
-    DEVICE_TYPE_ACCESSORY = 0,
-    DEVICE_TYPE_CONTROLLER = 1,
-    DEVICE_TYPE_PROXY = 2
-} UserType;
-
-#define REQUEST_REJECTED 0x80000005
-#define REQUEST_ACCEPTED 0x80000006
-#define REQUEST_WAITING 0x80000007
-
-typedef struct {
-    void (*onGroupCreated)(const char *groupInfo);
-    void (*onGroupDeleted)(const char *groupInfo);
-    void (*onDeviceBound)(const char *peerUdid, const char *groupInfo);
-    void (*onDeviceUnBound)(const char *peerUdid, const char *groupInfo);
-    void (*onDeviceNotTrusted)(const char *peerUdid);
-    void (*onLastGroupDeleted)(const char *peerUdid, int groupType);
-    void (*onTrustedDeviceNumChanged)(int curTrustedDeviceNum);
-} DataChangeListener;
-
-typedef struct {
-    bool (*onTransmit)(int64_t requestId, const uint8_t *data, uint32_t dataLen);
-    void (*onSessionKeyReturned)(int64_t requestId, const uint8_t *sessionKey, uint32_t sessionKeyLen);
-    void (*onFinish)(int64_t requestId, int operationCode, const char *returnData);
-    void (*onError)(int64_t requestId, int operationCode, int errorCode, const char *errorReturn);
-    char *(*onRequest)(int64_t requestId, int operationCode, const char *reqParams);
-} DeviceAuthCallback;
-
-typedef struct {
-    int32_t (*processData)(int64_t authReqId, const uint8_t *data, uint32_t dataLen,
-        const DeviceAuthCallback *gaCallback);
-    int32_t (*queryTrustedDeviceNum)(void);
-    bool (*isTrustedDevice)(const char *udid);
-    int32_t (*getAuthState)(int64_t authReqId, const char *groupId, const char *peerUdid,
-        uint8_t *out, uint32_t *outLen);
-    int32_t (*authDevice)(int64_t authReqId, const char *authParams, const DeviceAuthCallback *gaCallback);
-    void (*informDeviceDisconnection)(const char *udid);
-} GroupAuthManager;
-
-typedef struct {
-    int32_t (*regCallback)(const char *appId, const DeviceAuthCallback *callback);
-    int32_t (*unRegCallback)(const char *appId);
-    int32_t (*regDataChangeListener)(const char *appId, const DataChangeListener *listener);
-    int32_t (*unRegDataChangeListener)(const char *appId);
-    int32_t (*createGroup)(int64_t requestId, const char *appId, const char *createParams);
-    int32_t (*deleteGroup)(int64_t requestId, const char *appId, const char *disbandParams);
-    int32_t (*addMemberToGroup)(int64_t requestId, const char *appId, const char *addParams);
-    int32_t (*deleteMemberFromGroup)(int64_t requestId, const char *appId, const char *deleteParams);
-    int32_t (*processData)(int64_t requestId, const uint8_t *data, uint32_t dataLen);
-    int32_t (*confirmRequest)(int64_t requestId, const char *appId, const char *confirmParams);
-    int32_t (*bindPeer)(int64_t requestId, const char *appId, const char *bindParams);
-    int32_t (*unbindPeer)(int64_t requestId, const char *appId, const char *unBindParams);
-    int32_t (*processLiteData)(int64_t requestId, const char *appId, const uint8_t *data, uint32_t dataLen);
-    int32_t (*authKeyAgree)(int64_t requestId, const char *appId, const char *buildParams);
-    int32_t (*processKeyAgreeData)(int64_t requestId, const char *appId, const uint8_t *data, uint32_t dataLen);
-    int32_t (*processCredential)(int operationCode, const char *reqJsonStr, char **returnJsonStr);
-    int32_t (*getRegisterInfo)(char **returnRegisterInfo);
-    int32_t (*getLocalConnectInfo)(char *returnInfo, int32_t bufLen);
-    int32_t (*addGroupManager)(const char *appId, const char *groupId, const char *managerAppId);
-    int32_t (*addGroupFriend)(const char *appId, const char *groupId, const char *friendAppId);
-    int32_t (*deleteGroupManager)(const char *appId, const char *groupId, const char *managerAppId);
-    int32_t (*deleteGroupFriend)(const char *appId, const char *groupId, const char *friendAppId);
-    int32_t (*getGroupManagers)(const char *appId, const char *groupId, char **returnManagers, uint32_t *returnSize);
-    int32_t (*getGroupFriends)(const char *appId, const char *groupId, char **returnFriends, uint32_t *returnSize);
-    int32_t (*getGroupInfoById)(const char *appId, const char *groupId, char **returnGroupInfo);
-    int32_t (*getGroupInfo)(const char *appId, const char *queryParams, char **returnGroupVec, uint32_t *groupNum);
-    int32_t (*getJoinedGroups)(const char *appId, int groupType, char **returnGroupVec, uint32_t *groupNum);
-    int32_t (*getRelatedGroups)(const char *appId, const char *peerDeviceId, char **returnGroupVec, uint32_t *groupNum);
-    int32_t (*getDeviceInfoById)(const char *appId, const char *deviceId, const char *groupId, char **returnDeviceInfo);
-    int32_t (*getTrustedDevices)(const char *appId, const char *groupId, char **returnDevInfoVec, uint32_t *deviceNum);
-    int32_t (*checkAccessToGroup)(const char *appId, const char *groupId);
-    bool (*isDeviceInGroup)(const char *appId, const char *groupId, const char *deviceId);
-    void (*destroyInfo)(char **returnInfo);
-} DeviceGroupManager;
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-DEVICE_AUTH_API_PUBLIC int InitDeviceAuthService(void);
-DEVICE_AUTH_API_PUBLIC void DestroyDeviceAuthService(void);
-DEVICE_AUTH_API_PUBLIC const GroupAuthManager *GetGaInstance(void);
-DEVICE_AUTH_API_PUBLIC const DeviceGroupManager *GetGmInstance(void);
-#ifdef __cplusplus
-}
-#endif
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DEVICE_AUTH_H
+#define DEVICE_AUTH_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#if defined(__LINUX__) || defined(_UNIX)
+#define DEVICE_AUTH_API_PUBLIC __attribute__ ((visibility("default")))
+#else
+#define DEVICE_AUTH_API_PUBLIC
+#endif
+
+#define FIELD_GROUP_ID "groupId"
+#define FIELD_GROUP_TYPE "groupType"
+#define FIELD_GROUP_NAME "groupName"
+#define FIELD_PEER_DEVICE_ID "peerDeviceId"
+#define FIELD_IS_ADMIN "isAdmin"
+#define FIELD_CREDENTIAL_TYPE "credentialType"
+#define FIELD_IS_FORCE_DELETE "isForceDelete"
+#define FIELD_IS_IGNORE_CHANNEL "isIgnoreChannel"
+#define FIELD_CONNECT_PARAMS "connectParams"
+#define FIELD_ADD_ID "addId"
+#define FIELD_DELETE_ID "deleteId"
+#define FIELD_APP_ID "appId"
+#define FIELD_SERVICE_TYPE "serviceType"
+#define FIELD_PEER_AUTH_STATE "peerAuthState"
+#define FIELD_IS_DEVICE_LEVEL "isDeviceLevel"
+#define FIELD_ALTERNATIVE "alternative"
+#define FIELD_PEER_UDID "peerUdid"
+#define FIELD_PEER_CONN_DEVICE_ID "peerConnDeviceId"
+#define FIELD_KEY_LENGTH "keyLength"
+#define FIELD_IS_CLIENT "isClient"
+#define FIELD_SESSION_KEY "sessionKey"
+#define FIELD_AUTH_FORM "authForm"
+#define FIELD_CONFIRMATION "confirmation"
+#define FIELD_GROUP_OWNER "groupOwner"
+#define FIELD_PEER_AUTH_ID "peerAuthId"
+#define FIELD_PEER_USER_TYPE "peerUserType"
+#define FIELD_PEER_USER_ID "peerUserId"
+#define FIELD_SERVICE_PKG_NAME "servicePkgName"
+#define FIELD_USER_TYPE "userType"
+#define FIELD_USER_ID "userId"
+#define FIELD_DEVICE_ID "deviceId"
+#define FIELD_UID_HASH "uidHash"
+#define FIELD_PIN_CODE "pinCode"
+#define FIELD_AUTH_ID "authId"
+#define FIELD_GROUP_VISIBILITY "groupVisibility"
+#define FIELD_EXPIRE_TIME "expireTime"
+#define FIELD_IS_DELETE_ALL "isDeleteAll"
+
+typedef enum {
+    GROUP_CREATE = 0,
+    GROUP_DISBAND = 1,
+    MEMBER_INVITE = 2,
+    MEMBER_JOIN = 3,
+    MEMBER_DELETE = 4,
+    ACCOUNT_BIND = 5
+} GroupOperationCode;
+
+typedef enum {
+    CREDENTIAL_SAVE = 0,
+    CREDENTIAL_CLEAR = 1,
+    CREDENTIAL_UPDATE = 2,
+    CREDENTIAL_QUERY = 3,
+} CredentialCode;
+
+typedef enum {
+    DEVICE_TYPE_ACCESSORY = 0,
+    DEVICE_TYPE_CONTROLLER = 1,
+    DEVICE_TYPE_PROXY = 2
+} UserType;
+
+#define REQUEST_REJECTED 0x80000005
+#define REQUEST_ACCEPTED 0x80000006
+#define REQUEST_WAITING 0x80000007
+
+typedef struct {
+    void (*onGroupCreated)(const char *groupInfo);
+    void (*onGroupDeleted)(const char *groupInfo);
+    void (*onDeviceBound)(const char *peerUdid, const char *groupInfo);
+    void (*onDeviceUnBound)(const char *peerUdid, const char *groupInfo);
+    void (*onDeviceNotTrusted)(const char *peerUdid);
+    void (*onLastGroupDeleted)(const char *peerUdid, int groupType);
+    void (*onTrustedDeviceNumChanged)(int curTrustedDeviceNum);
+} DataChangeListener;
+
+typedef struct {
+    bool (*onTransmit)(int64_t requestId, const uint8_t *data, uint32_t dataLen);
+    void (*onSessionKeyReturned)(int64_t requestId, const uint8_t *sessionKey, uint32_t sessionKeyLen);
+    void (*onFinish)(int64_t requestId, int operationCode, const char *returnData);
+    void (*onError)(int64_t requestId, int operationCode, int errorCode, const char *errorReturn);
+    char *(*onRequest)(int64_t requestId, int operationCode, const char *reqParams);
+} DeviceAuthCallback;
+
+typedef struct {
+    int32_t (*processData)(int64_t authReqId, const uint8_t *data, uint32_t dataLen,
+        const DeviceAuthCallback *gaCallback);
+    int32_t (*queryTrustedDeviceNum)(void);
+    bool (*isTrustedDevice)(const char *udid);
+    int32_t (*getAuthState)(int64_t authReqId, const char *groupId, const char *peerUdid,
+        uint8_t *out, uint32_t *outLen);
+    int32_t (*authDevice)(int64_t authReqId, const char *authParams, const DeviceAuthCallback *gaCallback);
+    void (*informDeviceDisconnection)(const char *udid);
+} GroupAuthManager;
+
+typedef struct {
+    int32_t (*regCallback)(const char *appId, const DeviceAuthCallback *callback);
+    int32_t (*unRegCallback)(const char *appId);
+    int32_t (*regDataChangeListener)(const char *appId, const DataChangeListener *listener);
+    int32_t (*unRegDataChangeListener)(const char *appId);
+    int32_t (*createGroup)(int64_t requestId, const char *appId, const char *createParams);
+    int32_t (*deleteGroup)(int64_t requestId, const char *appId, const char *disbandParams);
+    int32_t (*addMemberToGroup)(int64_t requestId, const char *appId, const char *addParams);
+    int32_t (*deleteMemberFromGroup)(int64_t requestId, const char *appId, const char *deleteParams);
+    int32_t (*processData)(int64_t requestId, const uint8_t *data, uint32_t dataLen);
+    int32_t (*confirmRequest)(int64_t requestId, const char *appId, const char *confirmParams);
+    int32_t (*bindPeer)(int64_t requestId, const char *appId, const char *bindParams);
+    int32_t (*unbindPeer)(int64_t requestId, const char *appId, const char *unBindParams);
+    int32_t (*processLiteData)(int64_t requestId, const char *appId, const uint8_t *data, uint32_t dataLen);
+    int32_t (*authKeyAgree)(int64_t requestId, const char *appId, const char *buildParams);
+    int32_t (*processKeyAgreeData)(int64_t requestId, const char *appId, const uint8_t *data, uint32_t dataLen);
+    int32_t (*processCredential)(int operationCode, const char *reqJsonStr, char **returnJsonStr);
+    int32_t (*getRegisterInfo)(char **returnRegisterInfo);
+    int32_t (*getLocalConnectInfo)(char *returnInfo, int32_t bufLen);
+    int32_t (*addGroupManager)(const char *appId, const char *groupId, const char *managerAppId);
+    int32_t (*addGroupFriend)(const char *appId, const char *groupId, const char *friendAppId);
+    int32_t (*deleteGroupManager)(const char *appId, const char *groupId, const char *managerAppId);
+    int32_t (*deleteGroupFriend)(const char *appId, const char *groupId, const char *friendAppId);
+    int32_t (*getGroupManagers)(const char *appId, const char *groupId, char **returnManagers, uint32_t *returnSize);
+    int32_t (*getGroupFriends)(const char *appId, const char *groupId, char **returnFriends, uint32_t *returnSize);
+    int32_t (*getGroupInfoById)(const char *appId, const char *groupId, char **returnGroupInfo);
+    int32_t (*getGroupInfo)(const char *appId, const char *queryParams, char **returnGroupVec, uint32_t *groupNum);
+    int32_t (*getJoinedGroups)(const char *appId, int groupType, char **returnGroupVec, uint32_t *groupNum);
+    int32_t (*getRelatedGroups)(const char *appId, const char *peerDeviceId, char **returnGroupVec, uint32_t *groupNum);
+    int32_t (*getDeviceInfoById)(const char *appId, const char *deviceId, const char *groupId, char **returnDeviceInfo);
+    int32_t (*getTrustedDevices)(const char *appId, const char *groupId, char **returnDevInfoVec, uint32_t *deviceNum);
+    int32_t (*checkAccessToGroup)(const char *appId, const char *groupId);
+    bool (*isDeviceInGroup)(const char *appId, const char *groupId, const char *deviceId);
+    void (*destroyInfo)(char **returnInfo);
+} DeviceGroupManager;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+DEVICE_AUTH_API_PUBLIC int InitDeviceAuthService(void);
+DEVICE_AUTH_API_PUBLIC void DestroyDeviceAuthService(void);
+DEVICE_AUTH_API_PUBLIC const GroupAuthManager *GetGaInstance(void);
+DEVICE_AUTH_API_PUBLIC const DeviceGroupManager *GetGmInstance(void);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naru deviceauth/interfaces/innerkits/device_auth_defines.h deviceauth_new/interfaces/innerkits/device_auth_defines.h
--- deviceauth/interfaces/innerkits/device_auth_defines.h	2025-02-12 16:28:24.326263100 +0800
+++ deviceauth_new/interfaces/innerkits/device_auth_defines.h	2025-02-12 15:01:27.834543400 +0800
@@ -1,138 +1,138 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef DEVICE_AUTH_DEFINES_H
-#define DEVICE_AUTH_DEFINES_H
-
-#define HC_GROUP_FRIEND_MAX_NUM 100 /* Visibility is 1, friend list is available, and max is 100 */
-#define HC_GROUP_MANAGER_MAX_NUM 10 /* manager max number is 10, it includes owner and other managers */
-
-enum {
-    /* common error code, 0x00000000 ~ 0x00000FFF */
-    HC_SUCCESS = 0x00000000,
-
-    HC_ERROR = 0x00000001,
-    HC_ERR_INVALID_PARAMS = 0x00000002,
-    HC_ERR_INVALID_LEN = 0x00000003,
-    HC_ERR_NULL_PTR = 0x00000004,
-    HC_ERR_ALLOC_MEMORY = 0x00000005,
-    HC_ERR_MEMORY_COPY = 0x00000006,
-    HC_ERR_CONVERT_FAILED = 0x00000007,
-    HC_ERR_NOT_SUPPORT = 0x00000008,
-    HC_ERR_TIME_OUT = 0x00000009,
-    HC_ERR_CASE = 0x0000000A,
-    HC_ERR_BAD_TIMING = 0x0000000B,
-    HC_ERR_PEER_ERROR = 0x0000000C,
-
-    /* error code for huks adapter , 0x00001000 ~ 0x00001FFF */
-    HC_ERR_KEY_NOT_EXIST = 0x00001001,
-    HC_ERR_GENERATE_KEY_FAILED = 0x000010002,
-    HC_ERR_INVALID_PUBLIC_KEY = 0x00001003,
-    HC_ERR_VERIFY_FAILED = 0x00001004,
-    HC_ERR_HASH_FAIL = 0x00001005,
-    HC_ERR_INIT_FAILED = 0x00001006,
-
-    /* error code for json util , 0x00002000 ~ 0x00002FFF */
-    HC_ERR_JSON_FAIL = 0x00002001,
-    HC_ERR_JSON_CREATE = 0x00002002,
-    HC_ERR_JSON_GET = 0x00002003,
-    HC_ERR_JSON_ADD = 0x00002004,
-    HC_ERR_PACKAGE_JSON_TO_STRING_FAIL = 0x00002005,
-
-    /* error code for ipc, 0x00003000 ~ 0x00003FFF */
-    HC_ERR_IPC_INTERNAL_FAILED = 0x00003001,
-    HC_ERR_IPC_UNKNOW_OPCODE = 0x00003002,
-    HC_ERR_IPC_CALL_DATA_LENGTH = 0x00003003,
-    HC_ERR_IPC_METHOD_ID_INVALID = 0x00003004,
-    HC_ERR_IPC_BAD_MESSAGE_LENGTH = 0x00003005,
-    HC_ERR_IPC_BAD_VAL_LENGTH = 0x00003006,
-    HC_ERR_IPC_BAD_PARAM_NUM = 0x00003007,
-    HC_ERR_IPC_BAD_MSG_TYPE = 0x00003008,
-    HC_ERR_IPC_GET_SERVICE = 0x00003009,
-    HC_ERR_IPC_GET_PROXY = 0x0000300A,
-    HC_ERR_IPC_INIT = 0x0000300B,
-    HC_ERR_IPC_BUILD_PARAM = 0x0000300C,
-    HC_ERR_IPC_PROC_FAILED = 0x0000300D,
-    HC_ERR_IPC_UNKNOW_REPLY = 0x0000300E,
-    HC_ERR_IPC_OUT_DATA_NUM = 0x0000300F,
-    HC_ERR_IPC_OUT_DATA = 0x00003010,
-    HC_ERR_IPC_BAD_PARAM = 0x00003011,
-
-    /* error code for module , 0x00004000 ~ 0x00004FFF */
-    HC_ERR_MODULE_NOT_FOUNT = 0x00004001,
-    HC_ERR_UNSUPPORTED_METHOD = 0x00004002,
-    HC_ERR_UNSUPPORTED_VERSION = 0x00004003,
-    HC_ERR_UNSUPPORTED_CURVE = 0x00004004,
-    HC_ERR_BAD_MESSAGE = 0x00004005,
-    HC_ERR_PROOF_NOT_MATCH = 0x00004006,
-    HC_ERR_INIT_TASK_FAIL = 0x00004007,
-    HC_ERR_TASK_IS_NULL = 0x00004008,
-    HC_ERR_TASK_ID_IS_NOT_MATCH = 0x00004009,
-    HC_ERR_INVALID_ALG = 0x0000400A,
-    HC_ERR_IGNORE_MSG = 0x0000400B,
-    HC_ERR_LOCAL_IDENTITY_NOT_EXIST = 0x0000400C,
-
-    /* error code for group , 0x00005000 ~ 0x00005FFF */
-    HC_ERR_ACCESS_DENIED = 0x00005001,
-    HC_ERR_CALLBACK_NOT_FOUND = 0x00005002,
-    HC_ERR_SERVICE_NEED_RESTART = 0x00005003,
-    HC_ERR_NO_CANDIDATE_GROUP = 0x00005004,
-    HC_ERR_TRANSMIT_FAIL = 0x00005005,
-    HC_ERR_REQUEST_EXIST = 0x00005006,
-    HC_ERR_REQUEST_NOT_FOUND = 0x00005007,
-    HC_ERR_SESSION_NOT_EXIST = 0x00005008,
-    HC_ERR_SESSION_ID_CONFLICT = 0x00005009,
-    HC_ERR_REQ_REJECTED = 0x0000500A,
-    HC_ERR_SERVER_CONFIRM_FAIL = 0x0000500B,
-    HC_ERR_CREATE_SESSION_FAIL = 0x0000500C,
-    HC_ERR_SESSION_IS_FULL = 0x0000500D,
-
-    /* error code for database , 0x00006000 ~ 0x00006FFF */
-    HC_ERR_DB = 0x00006001,
-    HC_ERR_BEYOND_LIMIT = 0x00006002,
-    HC_ERR_SAVE_DB_FAILED = 0x00006003,
-    HC_ERR_FRIEND_NOT_EXIST = 0x00006004,
-    HC_ERR_MANAGER_NOT_EXIST = 0x00006005,
-    HC_ERR_GROUP_DUPLICATE = 0x00006006,
-    HC_ERR_GROUP_NOT_EXIST = 0x00006007,
-    HC_ERR_DEVICE_NOT_EXIST = 0x00006008,
-    HC_ERR_DEVICE_DUPLICATE = 0x00006009,
-    HC_ERR_LOST_DATA = 0x0000600A,
-
-    /* error code for broadcast , 0x00007000 ~ 0x00007FFF */
-    HC_ERR_LISTENER_NOT_EXIST = 0x00007001,
-
-    /* error code for channel , 0x00008000 ~ 0x00008FFF */
-    HC_ERR_CHANNEL_NOT_EXIST = 0x00008001,
-    HC_ERR_SOFT_BUS = 0x00008002,
-
-    /* error code used on DAS service */
-    INVALID_PARAMETERS = 0xF0000001,
-    EXCEED_AUTHORITY = 0xF0000002,
-    TIMEOUT = 0xF0000003,
-    NOT_REGISTERED = 0xF0000004,
-    NOT_TRUST_PEER = 0xF0000005,
-    NOT_TRUST_CONTROLLER = 0xF0000006,
-    NOT_TRUST_ACCESSORY = 0xF0000007,
-    OVER_MAX_TRUST_NUM = 0xF0000008,
-    CONNECTION_INTERRUPTED = 0xF0000009,
-    UNSUPPORTED_VERSION = 0xF000000A,
-    BAD_PAYLOAD = 0xF000000B,
-    ALGORITHM_UNSUPPORTED = 0xF000000C,
-    PROOF_MISMATCH = 0xF000000D,
-    UNKOWN = 0xF0000000,
-};
-
-#endif
+/*
+ * Copyright (C) 2021 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DEVICE_AUTH_DEFINES_H
+#define DEVICE_AUTH_DEFINES_H
+
+#define HC_GROUP_FRIEND_MAX_NUM 100 /* Visibility is 1, friend list is available, and max is 100 */
+#define HC_GROUP_MANAGER_MAX_NUM 10 /* manager max number is 10, it includes owner and other managers */
+
+enum {
+    /* common error code, 0x00000000 ~ 0x00000FFF */
+    HC_SUCCESS = 0x00000000,
+
+    HC_ERROR = 0x00000001,
+    HC_ERR_INVALID_PARAMS = 0x00000002,
+    HC_ERR_INVALID_LEN = 0x00000003,
+    HC_ERR_NULL_PTR = 0x00000004,
+    HC_ERR_ALLOC_MEMORY = 0x00000005,
+    HC_ERR_MEMORY_COPY = 0x00000006,
+    HC_ERR_CONVERT_FAILED = 0x00000007,
+    HC_ERR_NOT_SUPPORT = 0x00000008,
+    HC_ERR_TIME_OUT = 0x00000009,
+    HC_ERR_CASE = 0x0000000A,
+    HC_ERR_BAD_TIMING = 0x0000000B,
+    HC_ERR_PEER_ERROR = 0x0000000C,
+
+    /* error code for huks adapter , 0x00001000 ~ 0x00001FFF */
+    HC_ERR_KEY_NOT_EXIST = 0x00001001,
+    HC_ERR_GENERATE_KEY_FAILED = 0x000010002,
+    HC_ERR_INVALID_PUBLIC_KEY = 0x00001003,
+    HC_ERR_VERIFY_FAILED = 0x00001004,
+    HC_ERR_HASH_FAIL = 0x00001005,
+    HC_ERR_INIT_FAILED = 0x00001006,
+
+    /* error code for json util , 0x00002000 ~ 0x00002FFF */
+    HC_ERR_JSON_FAIL = 0x00002001,
+    HC_ERR_JSON_CREATE = 0x00002002,
+    HC_ERR_JSON_GET = 0x00002003,
+    HC_ERR_JSON_ADD = 0x00002004,
+    HC_ERR_PACKAGE_JSON_TO_STRING_FAIL = 0x00002005,
+
+    /* error code for ipc, 0x00003000 ~ 0x00003FFF */
+    HC_ERR_IPC_INTERNAL_FAILED = 0x00003001,
+    HC_ERR_IPC_UNKNOW_OPCODE = 0x00003002,
+    HC_ERR_IPC_CALL_DATA_LENGTH = 0x00003003,
+    HC_ERR_IPC_METHOD_ID_INVALID = 0x00003004,
+    HC_ERR_IPC_BAD_MESSAGE_LENGTH = 0x00003005,
+    HC_ERR_IPC_BAD_VAL_LENGTH = 0x00003006,
+    HC_ERR_IPC_BAD_PARAM_NUM = 0x00003007,
+    HC_ERR_IPC_BAD_MSG_TYPE = 0x00003008,
+    HC_ERR_IPC_GET_SERVICE = 0x00003009,
+    HC_ERR_IPC_GET_PROXY = 0x0000300A,
+    HC_ERR_IPC_INIT = 0x0000300B,
+    HC_ERR_IPC_BUILD_PARAM = 0x0000300C,
+    HC_ERR_IPC_PROC_FAILED = 0x0000300D,
+    HC_ERR_IPC_UNKNOW_REPLY = 0x0000300E,
+    HC_ERR_IPC_OUT_DATA_NUM = 0x0000300F,
+    HC_ERR_IPC_OUT_DATA = 0x00003010,
+    HC_ERR_IPC_BAD_PARAM = 0x00003011,
+
+    /* error code for module , 0x00004000 ~ 0x00004FFF */
+    HC_ERR_MODULE_NOT_FOUNT = 0x00004001,
+    HC_ERR_UNSUPPORTED_METHOD = 0x00004002,
+    HC_ERR_UNSUPPORTED_VERSION = 0x00004003,
+    HC_ERR_UNSUPPORTED_CURVE = 0x00004004,
+    HC_ERR_BAD_MESSAGE = 0x00004005,
+    HC_ERR_PROOF_NOT_MATCH = 0x00004006,
+    HC_ERR_INIT_TASK_FAIL = 0x00004007,
+    HC_ERR_TASK_IS_NULL = 0x00004008,
+    HC_ERR_TASK_ID_IS_NOT_MATCH = 0x00004009,
+    HC_ERR_INVALID_ALG = 0x0000400A,
+    HC_ERR_IGNORE_MSG = 0x0000400B,
+    HC_ERR_LOCAL_IDENTITY_NOT_EXIST = 0x0000400C,
+
+    /* error code for group , 0x00005000 ~ 0x00005FFF */
+    HC_ERR_ACCESS_DENIED = 0x00005001,
+    HC_ERR_CALLBACK_NOT_FOUND = 0x00005002,
+    HC_ERR_SERVICE_NEED_RESTART = 0x00005003,
+    HC_ERR_NO_CANDIDATE_GROUP = 0x00005004,
+    HC_ERR_TRANSMIT_FAIL = 0x00005005,
+    HC_ERR_REQUEST_EXIST = 0x00005006,
+    HC_ERR_REQUEST_NOT_FOUND = 0x00005007,
+    HC_ERR_SESSION_NOT_EXIST = 0x00005008,
+    HC_ERR_SESSION_ID_CONFLICT = 0x00005009,
+    HC_ERR_REQ_REJECTED = 0x0000500A,
+    HC_ERR_SERVER_CONFIRM_FAIL = 0x0000500B,
+    HC_ERR_CREATE_SESSION_FAIL = 0x0000500C,
+    HC_ERR_SESSION_IS_FULL = 0x0000500D,
+
+    /* error code for database , 0x00006000 ~ 0x00006FFF */
+    HC_ERR_DB = 0x00006001,
+    HC_ERR_BEYOND_LIMIT = 0x00006002,
+    HC_ERR_SAVE_DB_FAILED = 0x00006003,
+    HC_ERR_FRIEND_NOT_EXIST = 0x00006004,
+    HC_ERR_MANAGER_NOT_EXIST = 0x00006005,
+    HC_ERR_GROUP_DUPLICATE = 0x00006006,
+    HC_ERR_GROUP_NOT_EXIST = 0x00006007,
+    HC_ERR_DEVICE_NOT_EXIST = 0x00006008,
+    HC_ERR_DEVICE_DUPLICATE = 0x00006009,
+    HC_ERR_LOST_DATA = 0x0000600A,
+
+    /* error code for broadcast , 0x00007000 ~ 0x00007FFF */
+    HC_ERR_LISTENER_NOT_EXIST = 0x00007001,
+
+    /* error code for channel , 0x00008000 ~ 0x00008FFF */
+    HC_ERR_CHANNEL_NOT_EXIST = 0x00008001,
+    HC_ERR_SOFT_BUS = 0x00008002,
+
+    /* error code used on DAS service */
+    INVALID_PARAMETERS = 0xF0000001,
+    EXCEED_AUTHORITY = 0xF0000002,
+    TIMEOUT = 0xF0000003,
+    NOT_REGISTERED = 0xF0000004,
+    NOT_TRUST_PEER = 0xF0000005,
+    NOT_TRUST_CONTROLLER = 0xF0000006,
+    NOT_TRUST_ACCESSORY = 0xF0000007,
+    OVER_MAX_TRUST_NUM = 0xF0000008,
+    CONNECTION_INTERRUPTED = 0xF0000009,
+    UNSUPPORTED_VERSION = 0xF000000A,
+    BAD_PAYLOAD = 0xF000000B,
+    ALGORITHM_UNSUPPORTED = 0xF000000C,
+    PROOF_MISMATCH = 0xF000000D,
+    UNKOWN = 0xF0000000,
+};
+
+#endif
diff -Naru deviceauth/LICENSE deviceauth_new/LICENSE
--- deviceauth/LICENSE	2025-02-12 16:28:24.358502700 +0800
+++ deviceauth_new/LICENSE	2025-02-12 15:01:27.762543400 +0800
@@ -1,177 +1,177 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
    END OF TERMS AND CONDITIONS
\ No newline at end of file
diff -Naru deviceauth/services/common/src/data_base/database_manager.c deviceauth_new/services/common/src/data_base/database_manager.c
--- deviceauth/services/common/src/data_base/database_manager.c	2025-02-12 16:28:25.071754000 +0800
+++ deviceauth_new/services/common/src/data_base/database_manager.c	2025-02-12 15:01:27.858543400 +0800
@@ -1,4 +1,4 @@
-/*
+﻿/*
  * Copyright (C) 2021 Huawei Device Co., Ltd.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff -Naru deviceauth/services/module/src/das_module/pake_task/standard_exchange_task/standard_client_bind_exchange_task.c deviceauth_new/services/module/src/das_module/pake_task/standard_exchange_task/standard_client_bind_exchange_task.c
--- deviceauth/services/module/src/das_module/pake_task/standard_exchange_task/standard_client_bind_exchange_task.c	2025-02-12 16:28:29.768884500 +0800
+++ deviceauth_new/services/module/src/das_module/pake_task/standard_exchange_task/standard_client_bind_exchange_task.c	2025-02-12 15:01:27.950543500 +0800
@@ -59,7 +59,11 @@
     }
 
     // execute
-    GOTO_ERR_AND_SET_RET(ClientRequestStandardBindExchange(params, &(realTask->params)), res);
+    res = ClientRequestStandardBindExchange(params, &(realTask->params));
+    if (res != HC_SUCCESS) {
+        LOGE("ClientRequestStandardBindExchange failed");
+        return res;
+    }
 
     // package message
     GOTO_ERR_AND_SET_RET(AddIntToJson(sendToPeer, FIELD_MESSAGE, PAKE_BIND_EXCHANGE_REQUEST), res);
diff -Naru deviceauth/services/session/src/auth_session/auth_session_client.c deviceauth_new/services/session/src/auth_session/auth_session_client.c
--- deviceauth/services/session/src/auth_session/auth_session_client.c	2025-02-12 16:28:31.438921400 +0800
+++ deviceauth_new/services/session/src/auth_session/auth_session_client.c	2025-02-12 15:01:27.962543500 +0800
@@ -151,8 +151,8 @@
     CJson *out = CreateJson();
     if (out == NULL) {
         LOGE("Failed to create json for out!");
-        InformPeerAuthError(paramInSession, realSession->base.callback);
         InformLocalAuthError(paramInSession, realSession->base.callback);
+        InformPeerAuthError(paramInSession, realSession->base.callback);
         return HC_ERR_ALLOC_MEMORY;
     }
     res = ProcessClientAuthTask(realSession, GetAuthModuleType(paramInSession), in, out);
diff -Naru deviceauth/services/session/src/auth_session/auth_session_common.c deviceauth_new/services/session/src/auth_session/auth_session_common.c
--- deviceauth/services/session/src/auth_session/auth_session_common.c	2025-02-12 16:28:31.482569200 +0800
+++ deviceauth_new/services/session/src/auth_session/auth_session_common.c	2025-02-12 15:01:27.962543500 +0800
@@ -24,7 +24,6 @@
 #include "hc_log.h"
 #include "json_utils.h"
 
-#define MIN_PROTOCOL_VERSION "1.0.0"
 IMPLEMENT_HC_VECTOR(ParamsVec, void *, 1)
 
 static bool IsOldFormatParams(const CJson *param)
@@ -500,64 +499,6 @@
     return res;
 }
 
-static int32_t AddVersionMsgToPeer(CJson *errorToPeer)
-{
-    CJson *version = CreateJson();
-    if (version == NULL) {
-        LOGE("Failed to create json for version!");
-        return HC_ERR_JSON_CREATE;
-    }
-    CJson *payload = CreateJson();
-    if (payload == NULL) {
-        LOGE("Failed to create json for payload!");
-        FreeJson(version);
-        return HC_ERR_JSON_CREATE;
-    }
-    int32_t res = HC_SUCCESS;
-    do {
-        if (AddStringToJson(version, FIELD_MIN_VERSION, MIN_PROTOCOL_VERSION) != HC_SUCCESS) {
-            LOGE("Failed to add min version to json!");
-            res = HC_ERR_JSON_ADD;
-            break;
-        }
-        if (AddStringToJson(version, FIELD_CURRENT_VERSION, MIN_PROTOCOL_VERSION) != HC_SUCCESS) {
-            LOGE("Failed to add max version to json!");
-            res = HC_ERR_JSON_ADD;
-            break;
-        }
-        if (AddObjToJson(payload, FIELD_VERSION, version) != HC_SUCCESS) {
-            LOGE("Add version object to errorToPeer failed.");
-            res = HC_ERR_JSON_ADD;
-            break;
-        }
-        if (AddIntToJson(payload, FIELD_ERROR_CODE, -1) != HC_SUCCESS) {
-            LOGE("Failed to add errorCode for peer!");
-            res = HC_ERR_JSON_ADD;
-            break;
-        }
-        if (AddObjToJson(errorToPeer, FIELD_PAYLOAD, payload) != HC_SUCCESS) {
-            res = HC_ERR_JSON_ADD;
-            break;
-        }
-    } while (0);
-    FreeJson(version);
-    FreeJson(payload);
-    return res;
-}
-
-static int32_t PrepareErrorMsgToPeer(CJson *errorToPeer)
-{
-    if (AddIntToJson(errorToPeer, FIELD_GROUP_ERROR_MSG, GROUP_ERR_MSG) != HC_SUCCESS) {
-        LOGE("Failed to add groupErrorMsg for peer!");
-        return HC_ERR_JSON_FAIL;
-    }
-    if (AddIntToJson(errorToPeer, FIELD_MESSAGE, GROUP_ERR_MSG) != HC_SUCCESS) {
-        LOGE("Failed to add message for peer!");
-        return HC_ERR_JSON_FAIL;
-    }
-    return AddVersionMsgToPeer(errorToPeer);
-}
-
 static int32_t ReturnErrorToPeerBySession(const CJson *authParam, const DeviceAuthCallback *callback)
 {
     int64_t requestId = 0;
@@ -570,10 +511,10 @@
         LOGE("Failed to allocate memory for errorToPeer!");
         return HC_ERR_ALLOC_MEMORY;
     }
-    int32_t res = PrepareErrorMsgToPeer(errorToPeer);
-    if (res != HC_SUCCESS) {
+    if (AddIntToJson(errorToPeer, FIELD_GROUP_ERROR_MSG, GROUP_ERR_MSG) != HC_SUCCESS) {
+        LOGE("Failed to add err message to return data!");
         FreeJson(errorToPeer);
-        return res;
+        return HC_ERR_JSON_FAIL;
     }
     char *errorToPeerStr = PackJsonToString(errorToPeer);
     FreeJson(errorToPeer);
@@ -582,6 +523,7 @@
         return HC_ERR_ALLOC_MEMORY;
     }
 
+    int32_t res = HC_SUCCESS;
     do {
         if ((callback == NULL) || (callback->onTransmit == NULL)) {
             LOGE("The callback of onTransmit is null!");
diff -Naru deviceauth/services/session/src/auth_session/auth_session_server.c deviceauth_new/services/session/src/auth_session/auth_session_server.c
--- deviceauth/services/session/src/auth_session/auth_session_server.c	2025-02-12 16:28:31.533657100 +0800
+++ deviceauth_new/services/session/src/auth_session/auth_session_server.c	2025-02-12 15:01:27.962543500 +0800
@@ -187,8 +187,8 @@
     CJson *out = CreateJson();
     if (out == NULL) {
         LOGE("Failed to create json!");
-        InformPeerAuthError(receivedData, session->base.callback);
         InformLocalAuthError(receivedData, session->base.callback);
+        InformPeerAuthError(receivedData, session->base.callback);
         return HC_ERR_ALLOC_MEMORY;
     }
     int32_t status = 0;
@@ -238,8 +238,8 @@
     CJson *out = CreateJson();
     if (out == NULL) {
         LOGE("Failed to create json for out!");
-        InformPeerAuthError(paramInSession, realSession->base.callback);
         InformLocalAuthError(paramInSession, realSession->base.callback);
+        InformPeerAuthError(paramInSession, realSession->base.callback);
         return HC_ERR_ALLOC_MEMORY;
     }
     int32_t moduleType = GetAuthModuleType(paramInSession);
@@ -288,8 +288,8 @@
     }
     return (AuthSession *)session;
 err:
-    InformPeerAuthError(param, callback);
     InformLocalAuthError(param, callback);
+    InformPeerAuthError(param, callback);
     return NULL;
 }
 
@@ -298,8 +298,8 @@
     AuthSession *session = NULL;
     if (AddIntToJson(param, FIELD_OPERATION_CODE, AUTHENTICATE) != HC_SUCCESS) {
         LOGE("Failed to add operation code to json!");
-        InformPeerAuthError(param, callback);
         InformLocalAuthError(param, callback);
+        InformPeerAuthError(param, callback);
         return NULL;
     }
     session = CreateServerAuthSessionInner(param, callback);
diff -Naru deviceauth/services/session/src/session_manager.c deviceauth_new/services/session/src/session_manager.c
--- deviceauth/services/session/src/session_manager.c	2025-02-12 16:28:32.396203600 +0800
+++ deviceauth_new/services/session/src/session_manager.c	2025-02-12 15:01:27.966543500 +0800
@@ -176,8 +176,8 @@
 
 int32_t ProcessSession(int64_t requestId, int32_t type, CJson *in)
 {
-    RemoveOverTimeSession();
     int64_t sessionId = 0;
+    RemoveOverTimeSession();
     int32_t result = GetSessionIdByType(requestId, type, &sessionId);
     if (result != HC_SUCCESS) {
         LOGE("The corresponding session is not found!");
@@ -212,13 +212,11 @@
 int32_t CreateSession(int64_t requestId, SessionTypeValue sessionType, CJson *params,
     const DeviceAuthCallback *callback)
 {
-    RemoveOverTimeSession();
     int32_t res = CheckForCreateSession(requestId, params, callback);
     if (res != HC_SUCCESS) {
         return res;
     }
     uint32_t vecSize = g_sessionManagerVec.size(&g_sessionManagerVec);
-    LOGI("Current session num: %d", vecSize);
     if (vecSize >= MAX_SESSION_COUNT) {
         LOGE("Session vector is full.");
         return HC_ERR_SESSION_IS_FULL;
